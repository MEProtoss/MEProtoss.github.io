<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Protoss想要平静生活</title>
  
  <subtitle>神圣的卡拉连接着我们每一个人</subtitle>
  <link href="http://www.meprotoss.com/atom.xml" rel="self"/>
  
  <link href="http://www.meprotoss.com/"/>
  <updated>2024-11-10T15:14:30.176Z</updated>
  <id>http://www.meprotoss.com/</id>
  
  <author>
    <name>Mr.Chen</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>日语学习指南</title>
    <link href="http://www.meprotoss.com/undefined/3f2382d7.html"/>
    <id>http://www.meprotoss.com/undefined/3f2382d7.html</id>
    <published>2024-11-10T15:00:30.000Z</published>
    <updated>2024-11-10T15:14:30.176Z</updated>
    
    <content type="html"><![CDATA[<h2 id="日语"><a href="#日语" class="headerlink" title="日语"></a>日语</h2><ul><li>日语电台</li><li>阿飞老师的课+叶子老师的课</li><li>综艺+脱口秀</li></ul><h2 id="背单词"><a href="#背单词" class="headerlink" title="背单词"></a>背单词</h2><ul><li>沪江开心词场一天30个</li></ul><h2 id="刷题"><a href="#刷题" class="headerlink" title="刷题"></a>刷题</h2><ul><li>刷真题</li><li>红宝书+蓝宝书</li></ul><h2 id="课外读物"><a href="#课外读物" class="headerlink" title="课外读物"></a>课外读物</h2><ul><li>初心日语联盟(天声人语)</li><li>公众号（日语阅读进阶</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;日语&quot;&gt;&lt;a href=&quot;#日语&quot; class=&quot;headerlink&quot; title=&quot;日语&quot;&gt;&lt;/a&gt;日语&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;日语电台&lt;/li&gt;
&lt;li&gt;阿飞老师的课+叶子老师的课&lt;/li&gt;
&lt;li&gt;综艺+脱口秀&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;背</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>git</title>
    <link href="http://www.meprotoss.com/undefined/518e617c.html"/>
    <id>http://www.meprotoss.com/undefined/518e617c.html</id>
    <published>2024-11-01T16:30:38.000Z</published>
    <updated>2024-11-01T16:30:44.114Z</updated>
    
    
    
    
    
  </entry>
  
  <entry>
    <title>八股文骚套路之实习拷打</title>
    <link href="http://www.meprotoss.com/undefined/6bdd1875.html"/>
    <id>http://www.meprotoss.com/undefined/6bdd1875.html</id>
    <published>2024-10-28T03:00:46.000Z</published>
    <updated>2024-11-01T16:30:44.114Z</updated>
    
    <content type="html"><![CDATA[<h2 id="介绍一下你的实习"><a href="#介绍一下你的实习" class="headerlink" title="介绍一下你的实习"></a>介绍一下你的实习</h2><p>我在实习期间做的工作主要是使用python整合现有的美术资源脚本，搭建可拓展的框架，实现美术资源的批量crud</p><p>美术资源的信息保存在一个个svn仓库中，每个svn仓库中有一个repository.resouce的索引文件，是xml格式的，里面的每一行为一个object，对应着仓库中的一个美术资源<br>在这一行里面记录了仓库的基本信息，例如<type>&lt;虚拟地址&gt;&lt;实际地址的映射&gt;&lt;资源依赖&gt;等一些信息，美术人员只能看到&#x2F;只关注这个文件<br>每一个美术资源对应着仓库某个文件夹下面的具体的配置文件，这个文件是xml格式的，可以通过基本信息通过一定的处理映射到，里面存储了这个美术资源的具体信息，比如<numfaces><numvertics>这样的信息，本质上就是根据条件来对这个文件里的标签内文本进行crud</p><p>原先的脚本是零散的，有很多复用的逻辑，重复代码很多，给我安排的任务就是搭建一个基本框架出来，将现有的脚本整合进来，并且在新需求来的时候能够基于这个框架快速开发，实现需求</p><h2 id="实习期间遇到的最大的困难是什么，你是怎么解决的"><a href="#实习期间遇到的最大的困难是什么，你是怎么解决的" class="headerlink" title="实习期间遇到的最大的困难是什么，你是怎么解决的"></a>实习期间遇到的最大的困难是什么，你是怎么解决的</h2><p>问题主要是美术资源整合脚本的框架设计上，面对单个明确的需求，去编写单独一条脚本难度并不是很大，但是需要建立一个框架出来，不知道怎么下手。我中间一共是有过3个方案吧。</p><p>我首先想到的是用数据库方案，将xml文本的数据存储到</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;介绍一下你的实习&quot;&gt;&lt;a href=&quot;#介绍一下你的实习&quot; class=&quot;headerlink&quot; title=&quot;介绍一下你的实习&quot;&gt;&lt;/a&gt;介绍一下你的实习&lt;/h2&gt;&lt;p&gt;我在实习期间做的工作主要是使用python整合现有的美术资源脚本，搭建可拓展的框架，实现美术</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>八股文骚套路之Spring</title>
    <link href="http://www.meprotoss.com/undefined/5b1a3186.html"/>
    <id>http://www.meprotoss.com/undefined/5b1a3186.html</id>
    <published>2024-10-21T03:55:52.000Z</published>
    <updated>2024-11-01T16:30:44.114Z</updated>
    
    <content type="html"><![CDATA[<h2 id="谈谈对ioc的理解"><a href="#谈谈对ioc的理解" class="headerlink" title="谈谈对ioc的理解"></a>谈谈对ioc的理解</h2><ul><li>将手动<strong>创建对象的控制权</strong>交由<strong>外部环境</strong>Spring框架处理</li></ul><h2 id="什么是Bean"><a href="#什么是Bean" class="headerlink" title="什么是Bean?"></a>什么是Bean?</h2><ul><li>代指被IoC容器管理的对象</li></ul><h2 id="将一个类声明为Bean的注解有哪些？"><a href="#将一个类声明为Bean的注解有哪些？" class="headerlink" title="将一个类声明为Bean的注解有哪些？"></a>将一个类声明为Bean的注解有哪些？</h2><ul><li>@Component</li><li>@Repository</li><li>@Service</li><li>@Controller</li></ul><h2 id="Component-和-Bean-的区别是什么？"><a href="#Component-和-Bean-的区别是什么？" class="headerlink" title="@Component 和 @Bean 的区别是什么？"></a>@Component 和 @Bean 的区别是什么？</h2><ul><li>@Component 注解作用于类，而@Bean注解作用于方法</li><li>@Component通常是通过类路径扫描来自动侦测以及<strong>自动装配</strong>到 Spring 容器中（我们可以使用@ComponentScan 注解定义要扫描的路径,从中找出标识了需要装配的类自动装配到 Spring 的 bean 容器中）。@Bean 注解通常是我们在标有该注解的方法中定义产生这个 bean,@Bean告诉了 Spring 这是某个类的实例，当我需要用它的时候还给我。</li><li>@Bean 注解比 @Component 注解的自定义性更强，而且很多地方我们只能通过 @Bean 注解来注册 bean。比如当我们引用第三方库中的类需要装配到 Spring容器时，则只能通过 @Bean来实现</li></ul><h2 id="Autowired-和-Resource-的区别是什么？"><a href="#Autowired-和-Resource-的区别是什么？" class="headerlink" title="@Autowired 和 @Resource 的区别是什么？"></a>@Autowired 和 @Resource 的区别是什么？</h2><ul><li>@Autowired 是 Spring 提供的注解，@Resource 是 JDK 提供的注解。</li><li>Autowired 默认的注入方式为byType（根据类型进行匹配），@Resource默认注入方式为 byName（根据名称进行匹配）。当一个接口存在多个实现类的情况下，@Autowired 和@Resource都需要通过名称才能正确匹配到对应的 Bean。</li><li>Autowired 可以通过 @Qualifier 注解来显式指定名称，@Resource可以通过 name 属性来显式指定名称。</li><li>@Autowired 支持在构造函数、方法、字段和参数上使用。@Resource 主要用于字段和方法上的注入，不支持在构造函数或参数上使用。</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;谈谈对ioc的理解&quot;&gt;&lt;a href=&quot;#谈谈对ioc的理解&quot; class=&quot;headerlink&quot; title=&quot;谈谈对ioc的理解&quot;&gt;&lt;/a&gt;谈谈对ioc的理解&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;将手动&lt;strong&gt;创建对象的控制权&lt;/strong&gt;交由&lt;stron</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>八股文骚套路之Java并发</title>
    <link href="http://www.meprotoss.com/undefined/b97f760e.html"/>
    <id>http://www.meprotoss.com/undefined/b97f760e.html</id>
    <published>2024-10-21T02:43:41.000Z</published>
    <updated>2024-11-01T16:30:44.114Z</updated>
    
    <content type="html"><![CDATA[<h2 id="什么是线程和进程"><a href="#什么是线程和进程" class="headerlink" title="什么是线程和进程"></a>什么是线程和进程</h2><p>进程：是程序一次执行的过程，是系统运行程序的基本单位。系统一个程序的运行就是一个程序从创建、运行到消亡的过程</p><p>线程：在Java中，启动一个main函数就是启动了一个JVM进程，而main函数所在的线程就是这个进程中的一个线程，也称为主线程</p><blockquote><p>[!TIP]<br>用户线程和内核线程的区别和特点主要体现在：1.创建线程和切换线程的成本 2.能否利用多核</p></blockquote><h2 id="线程和进程的区别"><a href="#线程和进程的区别" class="headerlink" title="线程和进程的区别"></a>线程和进程的区别</h2><ol><li>进程是独立的，但是线程之间则不一定，同意进程中的多个线程极有可能会相互影响（共享堆和方法区）。</li><li>进程开销大，线程开销小，但是线程不利于资源的管理和保护</li></ol><h2 id="程序计数器的作用-为什么要私有？"><a href="#程序计数器的作用-为什么要私有？" class="headerlink" title="程序计数器的作用,为什么要私有？"></a>程序计数器的作用,为什么要私有？</h2><ol><li>进行代码的流程控制</li><li>记录当前线程执行的位置</li></ol><p>所以计数器的私有化主要是为了保证线程切换后能恢复到正确的执行位置</p><h2 id="虚拟机栈和本地方法栈为什么是私有的？"><a href="#虚拟机栈和本地方法栈为什么是私有的？" class="headerlink" title="虚拟机栈和本地方法栈为什么是私有的？"></a>虚拟机栈和本地方法栈为什么是私有的？</h2><p>为了保证线程中的局部变量不被别的线程访问到</p><h2 id="如何创建线程"><a href="#如何创建线程" class="headerlink" title="如何创建线程"></a>如何创建线程</h2><p>严格来说 Java中只有 <code>new Thread.().start</code>能创建线程</p><h2 id="线程的生命周期"><a href="#线程的生命周期" class="headerlink" title="线程的生命周期"></a>线程的生命周期</h2><ul><li>new 创建了还没start</li><li>runnable 运行 被start等待运行的状态</li><li>blocked 阻塞 等待释放</li><li>waiting 等待，表示需要等待其他线程执行完一些特定动作</li><li>time_waiting 超时等待 可以在等待一定时间之后自行返回</li><li>terminated 线程终止</li></ul><!-- TODO: -->]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;什么是线程和进程&quot;&gt;&lt;a href=&quot;#什么是线程和进程&quot; class=&quot;headerlink&quot; title=&quot;什么是线程和进程&quot;&gt;&lt;/a&gt;什么是线程和进程&lt;/h2&gt;&lt;p&gt;进程：是程序一次执行的过程，是系统运行程序的基本单位。系统一个程序的运行就是一个程序从创建、</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>八股文骚套路之python基础</title>
    <link href="http://www.meprotoss.com/undefined/7c8bfb9d.html"/>
    <id>http://www.meprotoss.com/undefined/7c8bfb9d.html</id>
    <published>2024-10-15T14:19:32.000Z</published>
    <updated>2024-11-09T02:53:34.471Z</updated>
    
    <content type="html"><![CDATA[<h2 id="讲讲python中的装饰器"><a href="#讲讲python中的装饰器" class="headerlink" title="讲讲python中的装饰器"></a>讲讲python中的装饰器</h2><ul><li>Python中的装饰器，本质上就是一个高阶函数，就是函数的函数，一个返回值是函数的函数（类似二阶导）</li><li>在函数中再嵌套一个函数，并且引用外部函数的变量，也就是一个闭包</li><li>不用更改原函数的代码前提下给函数增加新的功能。它可以让其他函数在不需要做任何代码变动的前提下增加额外功能，相当于一个语法糖。使用时，再需要的函数前加上@demo即可。</li></ul><h2 id="sleep和wait有什么区别？"><a href="#sleep和wait有什么区别？" class="headerlink" title="sleep和wait有什么区别？"></a>sleep和wait有什么区别？</h2><ul><li>两者都可以使当前线程进入阻塞状态</li><li>两者所属的类不同，sleep()是Thread类中的方法，wait()是Object类中的方法</li><li>两者的使用范围不一样，sleep()可以使用在任何有需要的场景下，而wait()方法只能使用在同步代码块和同步方法中</li><li>是否释放锁：sleep()方法不会释放锁，而wait()方法会释放锁</li><li>用法不同：使用sleep()方法，睡眠时间到了以后线程会自动苏醒；而使用wait()方法必须通过调用对象的notify()或notifyAll()方法唤醒</li><li>作用不同：sleep()方法是用来暂停线程的，而wait()方法是用来进行线程间交互的</li></ul><h2 id="python中有关的自动化测试的？"><a href="#python中有关的自动化测试的？" class="headerlink" title="python中有关的自动化测试的？"></a>python中有关的自动化测试的？</h2><ul><li>Unittest,Doctest,py.test,Nose,tox,Unittest2</li></ul><h3 id="Unittest-测试框架"><a href="#Unittest-测试框架" class="headerlink" title="Unittest 测试框架"></a>Unittest 测试框架</h3><p>简介:</p><ul><li>Unittest是Python自带的单元测试框架，不仅适用于单元测试，还可用于Web、Appium、接口自动化测试用例的开发与执行</li><li>该测试框架可组织执行测试用例，并且提供丰富的断言方法，判断测试用例是否通过，并最终生成测试结果。<br>核心要素:</li><li>TestCase：即测试用例，一条测试用例就是一个完整的测试流程，包括测试前准备环境的搭建(setUp)，执行测试代码(run)，以及测试后环境的还原(tearDown)，通过运行一条测试用例，可以对某一个问题进行验证。</li><li>Fixture：即测试固件，用于测试用例环境的搭建和销毁。在测试步骤执行前需要为该测试用例准备环境（SetUp），如启动app或打开浏览器，测试步骤执行后需要恢复环境（TearDown），如关闭app或浏览器，这时候就需要用到Fixture，使代码更简洁。</li><li>TestSuite：即测试套件，把需要执行的测试用例集合在一起就是TestSuite。使用TestLoader来加载TestCase到TestSuite中。</li><li>TextTestRunner：即测试执行器，用于执行测试用例。该模块中提供run方法执行TestSuite中的测试用例，并返回测试用例的执行结果，如运行的用例总数、用例通过数、用例失败数。</li><li>report：即测试报告。unittest框架没有自带的用于生成测试报告的模块或接口，需要使用第三方的扩展模块HTMLTestRunner。</li></ul><h2 id="怎么保存小数点后三位？"><a href="#怎么保存小数点后三位？" class="headerlink" title="怎么保存小数点后三位？"></a>怎么保存小数点后三位？</h2><ul><li>round（x，3），%.3f %x</li></ul><h2 id="字典和列表哪个快"><a href="#字典和列表哪个快" class="headerlink" title="字典和列表哪个快"></a>字典和列表哪个快</h2><ul><li>字典在存储时将字典的键利用哈希算法生成哈希值, 并将所有键生成的哈希值组成一张哈希表,在对字典进行查询时, 会先对字典的键利用哈希算法生成哈希值, 然后再到哈希表中查询, 而不像列表一样遍历索引位置元素进行查询, 所以比列表查询速度快</li></ul><h2 id="字典遍历方式"><a href="#字典遍历方式" class="headerlink" title="字典遍历方式"></a>字典遍历方式</h2><pre><code>1、用dict.keys()遍历：用dict.keys()方法会返回一个类型为dict_keys的序列类型，里面有字典的key，然后遍历即可2、有dict.values()遍历：类似的，会返回字典的所有value值组成的一个序列，类型为dict_values,3、用dict.items()遍历：会返回一个由key和value组成的一个个成对数据，通常同时获得二者：</code></pre><h1 id="如何实现两个列表的合并"><a href="#如何实现两个列表的合并" class="headerlink" title="如何实现两个列表的合并"></a>如何实现两个列表的合并</h1><ul><li>使用”+”运算符：可以使用”+”运算符将两个列表直接相加，生成一个新的列表</li><li>使用extend()方法：使用extend()方法将第二个列表的元素逐个添加到第一个列表中。</li><li>使用列表解析：可以使用列表解析语法来合并两个列表。</li><li>使用append()方法：可以使用循环遍历第二个列表的元素，并使用append()方法将其逐个添加到第一个列表后面。</li></ul><h1 id="怎么去除列表里面最后一个元素"><a href="#怎么去除列表里面最后一个元素" class="headerlink" title="怎么去除列表里面最后一个元素"></a>怎么去除列表里面最后一个元素</h1><ul><li>使用Python内置的pop()函数来删除列表最后一个元素，pop()函数会删除列表中的最后一个元素，并返回该元素的值。如果不需要返回该元素的值，可以直接使用pop()函数</li><li>还可以使用Python的del关键字来删除列表最后一个元素，使用del关键字删除元素时，需要指定要删除的元素的索引。可以使用 索引 -1 访问列表的最后一个元素</li><li>可以使用 remove() 方法，它删除列表中指定值的第一个出现</li></ul><h1 id="深拷贝和浅拷贝有什么区别，加入b列表深拷贝为a列表，修改b会影响到a吗，如何实现深拷贝"><a href="#深拷贝和浅拷贝有什么区别，加入b列表深拷贝为a列表，修改b会影响到a吗，如何实现深拷贝" class="headerlink" title="深拷贝和浅拷贝有什么区别，加入b列表深拷贝为a列表，修改b会影响到a吗，如何实现深拷贝"></a>深拷贝和浅拷贝有什么区别，加入b列表深拷贝为a列表，修改b会影响到a吗，如何实现深拷贝</h1><ul><li>浅拷贝不拷贝子对象的内容，只是拷贝子对象的引用</li><li>通俗说浅拷贝只拷贝个体，后期指向相同的子对象，子对象的实际内容并没有被拷贝</li><li>深拷贝会连子对象的内存全部拷贝一份，对子对象的修改不会影响源对象，对源对象的修改也不会影响子对象运行结果</li></ul><h2 id="python中的闭包"><a href="#python中的闭包" class="headerlink" title="python中的闭包"></a>python中的闭包</h2><ul><li><p>闭包是一个函数，通常用于创建灵活的函数和实现函数的封装。</p></li><li><p>函数是嵌套定义的，一个函数内部定义了另一个函数</p></li><li><p>内部函数引用了外部函数中的局部变量，这些局部变量称为自由变量</p></li><li><p>Python中的装饰器是闭包的一个实际应用</p></li><li><p>python装饰器是在不改变函数本身，为其动态的添加功能的设计模式本质上是一个函数，接受一个函数作为输入，返回一个经过修改或增强的函数,我的代码中，用装饰器记录一个脚本的执行时间和记录日志</p></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;讲讲python中的装饰器&quot;&gt;&lt;a href=&quot;#讲讲python中的装饰器&quot; class=&quot;headerlink&quot; title=&quot;讲讲python中的装饰器&quot;&gt;&lt;/a&gt;讲讲python中的装饰器&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;Python中的装饰器，本质上就是一个高</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>八股文骚套路之python3算法常用方法总结</title>
    <link href="http://www.meprotoss.com/undefined/495bdedc.html"/>
    <id>http://www.meprotoss.com/undefined/495bdedc.html</id>
    <published>2024-09-26T06:12:57.000Z</published>
    <updated>2024-09-27T02:10:01.781Z</updated>
    
    <content type="html"><![CDATA[<h2 id="遍历"><a href="#遍历" class="headerlink" title="遍历"></a>遍历</h2><ul><li><p>enumerate() 函数用于同时获取字符的索引 j 和字符值 c。</p></li><li><p>set(nums) 可以将数组直接转化为集合，做到去重获取其中所有元素</p></li><li><p>交换数组中的两个元素，不需要像java那样使用temp，直接写在一行中交换即可</p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">nums[cur], nums[index] = nums[index], nums[cur]</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>map() 是一个内置函数，用于将函数应用于可迭代对象（如列表、元组等）的每个元素，<strong>并返回一个迭代器</strong>。它的基本语法如下：</li></ul><p>map(function, iterable)</p><p>例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># 注意 因为返回的是一个迭代器，因此注意使用的时候要进行类型转换</span><br><span class="line">nums_ = list(map(int, nums)) </span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;遍历&quot;&gt;&lt;a href=&quot;#遍历&quot; class=&quot;headerlink&quot; title=&quot;遍历&quot;&gt;&lt;/a&gt;遍历&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;enumerate() 函数用于同时获取字符的索引 j 和字符值 c。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;set(nums</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>八股文骚套路之项目拷打</title>
    <link href="http://www.meprotoss.com/undefined/824f9b28.html"/>
    <id>http://www.meprotoss.com/undefined/824f9b28.html</id>
    <published>2024-09-22T01:53:54.000Z</published>
    <updated>2024-10-15T02:57:50.795Z</updated>
    
    <content type="html"><![CDATA[<h2 id="介绍一下项目"><a href="#介绍一下项目" class="headerlink" title="介绍一下项目"></a>介绍一下项目</h2><ul><li><p>功能：这是一个集校园美食、美景分享、店铺搜索、店家优惠券秒杀等功能于一体的生活分享平台。</p></li><li><p>项目框架：由springboot开发的前后端分类项目，使用了redis集群、tomcat集群、<br>mysql集群来提高服务器的性能</p></li><li><p>项目的技术栈: springboot+nginx+mysql+lombok+mybatis+hutool+redis</p></li></ul><h2 id="集成第三方登录"><a href="#集成第三方登录" class="headerlink" title="集成第三方登录"></a>集成第三方登录</h2><!-- TODO: --><h2 id="短信登录功能"><a href="#短信登录功能" class="headerlink" title="短信登录功能"></a>短信登录功能</h2><h3 id="初次登录"><a href="#初次登录" class="headerlink" title="初次登录"></a>初次登录</h3><p>注册之后，校验用户登陆的手机号和验证码，然后根据手机号查询用户信息，不存在则创建，然后将用户信息保存到redis，以生成的token作为redis的key</p><h3 id="为什么用redis？"><a href="#为什么用redis？" class="headerlink" title="为什么用redis？"></a>为什么用redis？</h3><p>因为使用了负载均衡有许多服务器，而不同的服务器之间session无法共享，所以用redis代替session</p><h3 id="校验登录状态"><a href="#校验登录状态" class="headerlink" title="校验登录状态"></a>校验登录状态</h3><p>用户携带token进行访问，从redis中取出token对应的value，判断是否存在这个数据，如果没有则拦截，如果存在则将其保存到<strong>threadLocal</strong>中，并且放行。</p><blockquote><p>[!TIP]<br>因为不同服务器之间的session无法共享，使用redis可以实现数据共享<br>将部分可展示属性封装成dto单独传递是为了实现数据的脱敏处理</p></blockquote><h3 id="双重拦截器干什么用的？"><a href="#双重拦截器干什么用的？" class="headerlink" title="双重拦截器干什么用的？"></a>双重拦截器干什么用的？</h3><p>浏览需要验证身份的模块时，在这些模块的共同的拦截器中拦截请求，刷新token。</p><p>但是有些页面不需要验证登录状态，但是也要刷新token，所以新添加一层拦截器专门用来刷新token有效期，避免出现token过期用户需要重新登录</p><h3 id="threadLocal是干什么用的？"><a href="#threadLocal是干什么用的？" class="headerlink" title="threadLocal是干什么用的？"></a>threadLocal是干什么用的？</h3><p>服务器获取用户信息 获取到之后将用户缓存到<code>ThreadLocal</code>中,方便后续的使用。<br>因为在业务中，<strong>每一个请求都是一个独立的线程</strong>，所以不能将用户信息保存到本地变量中，这样会导致多线程并发修改的安全问题，<strong>使用threadLocal就是在拦截器拦截到用户请求传递给控制器的时候，让每一个请求都开启一个独立的线程，避免出现线程安全问题</strong></p><h2 id="使用延迟双删方案解决缓存与数据的数据一致性问题？"><a href="#使用延迟双删方案解决缓存与数据的数据一致性问题？" class="headerlink" title="使用延迟双删方案解决缓存与数据的数据一致性问题？"></a>使用延迟双删方案解决缓存与数据的数据一致性问题？</h2><p>首先为什么会出现数据一致性问题？</p><p>数据一致性问题值的是数据库和缓存中保存的数据不一致。</p><p>使用redis来缓存商户商品信息，提升访问速度</p><p>查询数据库之前先查询缓存，如果缓存数据存在，则直接从缓存中返回</p><p>如果缓存数据不存在，再查询数据库，然后将数据存入redis。</p><h3 id="缓存与数据库的数据一致性问题及其解决方案"><a href="#缓存与数据库的数据一致性问题及其解决方案" class="headerlink" title="缓存与数据库的数据一致性问题及其解决方案"></a>缓存与数据库的数据一致性问题及其解决方案</h3><h4 id="什么是延迟双删方案"><a href="#什么是延迟双删方案" class="headerlink" title="什么是延迟双删方案?"></a>什么是延迟双删方案?</h4><p>其实就是缓存更新方案中的双写方案,也叫旁路缓存读写策略</p><ul><li><p>双写方案（也叫旁路缓存读写策略）：<br>查询时，如果缓存中没有，那么查询数据库，将数据库结果写入缓存，并设置超时时间<br>修改时，<strong>先修改数据库，再删除缓存</strong>。等再查询数据时，再从数据库中加载到缓存中</p></li><li><p>并采用超时删除和内存淘汰机制作为兜底方案</p></li><li><p><strong>双删</strong>指的是更新数据库的时候一并删除缓存</p></li><li><p><strong>延迟</strong>指的是延迟更新缓存，当查询的时候再去更新缓存</p></li><li><p>解决数据一致性问题有几种常见的缓存更新策略：</p><ul><li>内存淘汰: 内存不足的时候自动淘汰部分数据，下次查询的时候更新缓存</li><li>超时删除: 给数据添加ttl，到期自动删除</li><li>主动更新</li></ul></li></ul><h3 id="为什么要使用延迟双删方案"><a href="#为什么要使用延迟双删方案" class="headerlink" title="为什么要使用延迟双删方案?"></a>为什么要使用延迟双删方案?</h3><p>延迟双删主要就是先操作数据库，再操作缓存</p><ul><li>因为数据库操作太慢，为了防止删除缓存到更新数据库的时候有其他线程过来查询数据出现<strong>缓存击穿问题</strong>，因此必须先操作数据库,<strong>将缓存和数据库的操作放到同一个事务</strong>中就可以保证缓存与数据库操作的原子性</li></ul><h2 id="使用缓存空值和布隆过滤器缓存穿透问题"><a href="#使用缓存空值和布隆过滤器缓存穿透问题" class="headerlink" title="使用缓存空值和布隆过滤器缓存穿透问题"></a>使用缓存空值和布隆过滤器缓存穿透问题</h2><ul><li><p>缓存穿透问题是什么？：客户端请求的数据在数据库和缓存中都不存在</p></li><li><p>自定义布隆过滤器：在缓存之前添加一个布隆过滤器，提前将用户可能查询的数据放在过滤器里，用<strong>hash</strong>思想判断数据是否存在，但是布隆过滤器会有误判可能（存在的不一定存在，不存在的一定不存在）</p></li><li><p>缓存空值：如果查询的数据数据库中没有，那么就在缓存中缓存一个空对象，下次再来查的时候就不会找到数据库了，在缓存中发现是空值则直接结束查询</p></li></ul><h3 id="使用缓存预热解决缓存雪崩问题"><a href="#使用缓存预热解决缓存雪崩问题" class="headerlink" title="使用缓存预热解决缓存雪崩问题"></a>使用缓存预热解决缓存雪崩问题</h3><ul><li><p>什么是缓存雪崩？：<strong>同一时间大量缓存key同时失效</strong> 或者 <strong>redis服务器宕机</strong>导致大量请求同时到达数据库</p></li><li><p>针对redis宕机:可以使用reids集群和多级缓存</p></li><li><p>针对大量key同时失效:可以采用缓存预热：提前将热点key存入缓存中<strong>并设置合理的不同的过期时间</strong>,这个过滤实践可以手动设置逻辑过期</p><ul><li>缓存预热方法：这里可使用<strong>消息队列kafka</strong>，异步地进行缓存预热。将数据库中的热点数据的主键或者 ID 发送到消息队列中，然后由缓存服务 消费 消息队列中的数据，根据主键或者 ID 查询数据库并更新缓存）</li></ul></li></ul><h3 id="什么是kafka？"><a href="#什么是kafka？" class="headerlink" title="什么是kafka？"></a>什么是kafka？</h3><p><strong>分布式</strong>消息队列,一般用于系统或服务之间的消息传递</p><h3 id="使用互斥锁解决缓存击穿问题"><a href="#使用互斥锁解决缓存击穿问题" class="headerlink" title="使用互斥锁解决缓存击穿问题"></a>使用互斥锁解决缓存击穿问题</h3><ul><li><p>缓存击穿是什么？:也叫热点key问题，指的是一个高并发访问且缓存重建比较复杂的key突然失效</p></li><li><p>热点key过期之后，使用一把互斥锁，让失效key排队依次重建。查询缓存之后之后如果没查到，会先去获取互斥锁，获取到互斥锁才能进行查询数据库;还可以设置逻辑过期来解决缓存过期问题</p></li></ul><blockquote><p>[!TIP]<br>利用redis的setnx方法来获取锁</p></blockquote><h2 id="使用rabbitmq消息队列实现优惠券秒杀功能，并通过乐观锁解决超卖问题，使用分布式锁解决一人一单问题"><a href="#使用rabbitmq消息队列实现优惠券秒杀功能，并通过乐观锁解决超卖问题，使用分布式锁解决一人一单问题" class="headerlink" title="使用rabbitmq消息队列实现优惠券秒杀功能，并通过乐观锁解决超卖问题，使用分布式锁解决一人一单问题"></a>使用rabbitmq消息队列实现优惠券秒杀功能，并通过乐观锁解决超卖问题，使用分布式锁解决一人一单问题</h2><h3 id="⭐️rabbitmq消息队列-令牌桶算法实现优惠券秒杀问题-你项目的亮点是是什么！！！？？"><a href="#⭐️rabbitmq消息队列-令牌桶算法实现优惠券秒杀问题-你项目的亮点是是什么！！！？？" class="headerlink" title="⭐️rabbitmq消息队列+令牌桶算法实现优惠券秒杀问题(你项目的亮点是是什么！！！？？)"></a>⭐️rabbitmq消息队列+令牌桶算法实现优惠券秒杀问题(你项目的亮点是是什么！！！？？)</h3><p>因为为秒杀涉及到很多步骤，查询用户是否持有优惠券，判断库存是否充足，查询用户是否下单，校验是否一人一单，扣减库存，创建订单这些步骤，很多操作是要操作数据库的，这样如果是一个线程串行执行就会很慢,而我们只需要确认用户有下单资格（持有优惠券、库存充足）就可以了。因此将将耗时比较短的逻辑判断放入到redis中,确认能下单之后在后台再开一个线程执行后续步骤，实现异步下单。</p><p>其次秒杀是一个高并发的场景，短时间内后端访问量巨大，可能会压垮系统，只有少许人能秒杀成功，因此首先要做的是限流，针对用户的id进行限流<br>令牌桶算法是这样的：<br>首先定义一个容积给定的桶，可以存放一定数量的令牌，按照一定的速率往桶里放令牌，桶满了多余的令牌被丢弃。<br>当一个请求来了，必须先从桶里拿令牌，然后执行，执行完将令牌丢弃，如果桶里没有令牌了，那么请求被拒绝或等待</p><h3 id="令牌桶的优点"><a href="#令牌桶的优点" class="headerlink" title="令牌桶的优点"></a>令牌桶的优点</h3><ul><li>速率是平均的，可以动态调整速率</li></ul><h3 id="令牌桶的缺点"><a href="#令牌桶的缺点" class="headerlink" title="令牌桶的缺点"></a>令牌桶的缺点</h3><ol><li>速率和桶的容量需要合理设置</li></ol><h3 id="还有什么限流策略"><a href="#还有什么限流策略" class="headerlink" title="还有什么限流策略"></a>还有什么限流策略</h3><ol><li>滑动窗口：把固定窗口的时间片再细分，可以更平滑限流</li><li>漏桶算法：以一定速率往桶里添加请求排队，满出来的直接丢弃，再以一定速率从桶里漏水处理请求（类似于消息队列）</li><li>固定窗口：限制单位时间处理的请求数量</li></ol><h3 id="乐观锁解决超卖问题"><a href="#乐观锁解决超卖问题" class="headerlink" title="乐观锁解决超卖问题"></a>乐观锁解决超卖问题</h3><p>首先什么是超卖问题：线程a来查库存，此时大于1，要去扣库存但还没来得及扣，此时线程b来查库存，发现也大于1，那么两个线程都去扣减库存，导致超卖</p><p>乐观锁：只在<strong>数据更新时</strong>判断有没有其他线程对数据进行了修改</p><blockquote><p>[!TIP]<br>悲观锁：认为线程安全问题一定会发生，因此每次执行数据库操作的时候都需要加锁<br>常见的悲观锁有：synchronized、lock</p></blockquote><ul><li>操作数据库的时候对数据的版本号进行+1 <strong>只有当版本号不变的时候才能操作</strong> ，假设线程a操作之后，version号从1变成了2，那么线程2操作的时候发现version !&#x3D; 1 因此不能操作</li></ul><h3 id="使用分布式锁解决一人一单问题"><a href="#使用分布式锁解决一人一单问题" class="headerlink" title="使用分布式锁解决一人一单问题"></a>使用分布式锁解决一人一单问题</h3><ul><li><p>一人一单问题是指，同一个优惠券，一个用户只能下一单</p></li><li><p>分布式锁：满足分布式系统或者集群模式下<strong>多线程可见</strong>并且<strong>互斥</strong>的锁。</p></li></ul><ol><li><p>分布式系统 集群模式</p></li><li><p>多线程可见 互斥</p></li></ol><p>使用<strong>redis的setNx方法</strong>，当多个线程过来抢优惠券，第一个线程抢到锁之后，去执行业务，然后删除释放锁，其他线程等待并重试</p><blockquote><p>[!TIP]<br>利用setnx的方法加锁，同时设置过期时间，防止死锁</p></blockquote><ul><li>误删别人的锁的问题： 如果持有锁的线程在锁的内部出现了阻塞，导致他的锁自动释放，这时其他线程，线程2来尝试获得锁，就拿到了这把锁，然后线程2在持有锁执行过程中，线程1反应过来，继续执行，而线程1执行过程中，走到了删除锁逻辑，此时就会把本应该属于线程2的锁进行删除，这就是误删别人锁，<strong>因此在删除锁之前要判断这把锁是不是自己的</strong></li></ul><p>综上：使用redisson分布式锁替代setnx解决这些问题</p><h2 id="压测的时候主要关注的指标"><a href="#压测的时候主要关注的指标" class="headerlink" title="压测的时候主要关注的指标"></a>压测的时候主要关注的指标</h2><ul><li>并发量</li><li>响应时间</li><li>错误率</li><li>吞吐量<ul><li>QPS：每秒能够处理的<strong>查询</strong>数量</li><li>TPS：每秒能够处理的<strong>事务</strong>数量</li></ul></li><li>资源使用率</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;介绍一下项目&quot;&gt;&lt;a href=&quot;#介绍一下项目&quot; class=&quot;headerlink&quot; title=&quot;介绍一下项目&quot;&gt;&lt;/a&gt;介绍一下项目&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;功能：这是一个集校园美食、美景分享、店铺搜索、店家优惠券秒杀等功能于一体的生活分享平台。&lt;</summary>
      
    
    
    
    
    <category term="八股" scheme="http://www.meprotoss.com/tags/%E5%85%AB%E8%82%A1/"/>
    
  </entry>
  
  <entry>
    <title>八股文骚套路之设计模式</title>
    <link href="http://www.meprotoss.com/undefined/cb77a7ee.html"/>
    <id>http://www.meprotoss.com/undefined/cb77a7ee.html</id>
    <published>2024-09-21T08:06:20.000Z</published>
    <updated>2024-10-17T03:38:56.027Z</updated>
    
    <content type="html"><![CDATA[<h2 id="jdk中常见的设计模式"><a href="#jdk中常见的设计模式" class="headerlink" title="jdk中常见的设计模式"></a>jdk中常见的设计模式</h2><ul><li>单例</li><li>工厂模式（简单工厂、抽象工厂）</li><li>装饰器模式</li></ul><h2 id="你是否在你的代码里使用过设计模式？"><a href="#你是否在你的代码里使用过设计模式？" class="headerlink" title="你是否在你的代码里使用过设计模式？"></a>你是否在你的代码里使用过设计模式？</h2><ul><li>面向对象编程中，使用工厂模式来创建对象<!-- TODO: 举一个黑马点评中的例子 --></li></ul><h2 id="Java中什么叫单例设计模式？请写出Java中线程安全的单例模式"><a href="#Java中什么叫单例设计模式？请写出Java中线程安全的单例模式" class="headerlink" title="Java中什么叫单例设计模式？请写出Java中线程安全的单例模式"></a>Java中什么叫单例设计模式？请写出Java中线程安全的单例模式</h2><ul><li>一个类只有一个实例,主要有懒汉式和饿汉式两种创建方式，懒汉式仅初始化类，但是仅在调用<strong>getInstance</strong>方法时才创建对象；<br>饿汉式则在初始化类的时候一并创建对象</li><li>懒汉式，线程不安全</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance;</span><br><span class="line">  <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(instance == <span class="literal">null</span>)&#123;</span><br><span class="line">      instance = <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> instance;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>懒汉式，线程安全(使用synchronized来保证线程安全)</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(instance == <span class="literal">null</span>)&#123;</span><br><span class="line">      instance = <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> instance;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>饿汉式</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">Singleton</span> <span class="variable">instance</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span> &#123;&#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="为什么说枚举是实现单例的最好方式"><a href="#为什么说枚举是实现单例的最好方式" class="headerlink" title="为什么说枚举是实现单例的最好方式"></a>为什么说枚举是实现单例的最好方式</h2><ul><li>线程安全</li><li>简洁性和可读性</li><li>序列化安全性</li><li>反射安全性</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;jdk中常见的设计模式&quot;&gt;&lt;a href=&quot;#jdk中常见的设计模式&quot; class=&quot;headerlink&quot; title=&quot;jdk中常见的设计模式&quot;&gt;&lt;/a&gt;jdk中常见的设计模式&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;单例&lt;/li&gt;
&lt;li&gt;工厂模式（简单工厂、抽象工厂）&lt;</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>八股文骚套路之Redis</title>
    <link href="http://www.meprotoss.com/undefined/eaffd6f8.html"/>
    <id>http://www.meprotoss.com/undefined/eaffd6f8.html</id>
    <published>2024-09-21T02:55:09.000Z</published>
    <updated>2024-09-23T09:14:48.812Z</updated>
    
    <content type="html"><![CDATA[<h2 id="缓存雪崩的解决方案"><a href="#缓存雪崩的解决方案" class="headerlink" title="缓存雪崩的解决方案"></a>缓存雪崩的解决方案</h2><p><strong>缓存在同一时间大面积的失效</strong>，导致大量的请求都直接落到了数据库上，对数据库造成了巨大的压力</p><p><strong>缓存服务宕机</strong>也会导致缓存雪崩现象</p><h3 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h3><h4 id="针对redis服务不可用的情况"><a href="#针对redis服务不可用的情况" class="headerlink" title="针对redis服务不可用的情况"></a>针对redis服务不可用的情况</h4><ul><li>Redis 集群:采用 Redis 集群，避免单机出现问题整个缓存服务都没办法使用</li><li>多级缓存</li></ul><h4 id="针对大量缓存同时失效的情况"><a href="#针对大量缓存同时失效的情况" class="headerlink" title="针对大量缓存同时失效的情况"></a>针对大量缓存同时失效的情况</h4><ul><li>设置随机失效时间：避免大量缓存同时到期</li><li>提前预热：针对热点数据提前预热，将其存入缓存中并设置合理的过期时间 （比如秒杀场景下的数据在秒杀结束之前不过期(逻辑过期))。<ul><li>缓存预热的常见实现方式：<strong>定时任务</strong>和<strong>消息队列</strong>，<strong>Kafka</strong>可以异步的进行缓存预热</li></ul></li></ul><h2 id="如何保证缓存和数据库中数据的一致性"><a href="#如何保证缓存和数据库中数据的一致性" class="headerlink" title="如何保证缓存和数据库中数据的一致性"></a>如何保证缓存和数据库中数据的一致性</h2><ul><li>让缓存失效的时间变短,这样缓存就会很快从数据库从加载数据。(不推荐)</li><li>增加缓存更新重试机制：针对缓存不可用导致的缓存删除失败，可以引入消息队列实现<strong>异步</strong>重试，将删除缓存重试的消息投递到消息队列，然后由专门的消费者来重试，直到成功。</li></ul><h2 id="缓存击穿-热点key问题"><a href="#缓存击穿-热点key问题" class="headerlink" title="缓存击穿(热点key问题)"></a>缓存击穿(热点key问题)</h2><p>请求的 key 对应的是<strong>热点数据 ，该数据存在于数据库中，但不存在于缓存中</strong>,瞬时大量的请求直接打到了数据库上</p><p>举个例子：秒杀进行过程中，缓存中的某个秒杀商品的数据突然过期，这就导致瞬时大量对该商品的请求直接落到数据库上，对数据库造成了巨大的压力</p><h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><ul><li>提前预热：提前将热点key存入缓存</li><li>加锁：在缓存失效之后，通过设置互斥锁确保只有一个请求取查询数据库更新缓存。</li><li>永不过期（不推荐）</li></ul><h2 id="缓存穿透"><a href="#缓存穿透" class="headerlink" title="缓存穿透"></a>缓存穿透</h2><p><strong>大量请求的key 不存在于缓存中，也不存在于数据库中</strong></p><h3 id="解决方法-1"><a href="#解决方法-1" class="headerlink" title="解决方法"></a>解决方法</h3><ul><li>缓存空值</li><li>设置布隆过滤器：布隆过滤器可以很方便的判断一个给定数据是否存在于海量数据中。相当于在用户请求和缓存之间添加了一层过滤，将所有可能存在的请求值都存放在布隆过滤器中，当用户请求过来，先判断在不在过滤器中，如果不存在，则直接返回请求参数错误给客户端。</li></ul><h2 id="缓存穿透vs缓存击穿"><a href="#缓存穿透vs缓存击穿" class="headerlink" title="缓存穿透vs缓存击穿"></a>缓存穿透vs缓存击穿</h2><p>缓存穿透: 请求的key在缓存中不存在，也不存在在数据库中<br>缓存击穿：请求的key是热点数据，不在缓存中，在数据库中</p><h2 id="缓存雪崩vs缓存击穿"><a href="#缓存雪崩vs缓存击穿" class="headerlink" title="缓存雪崩vs缓存击穿"></a>缓存雪崩vs缓存击穿</h2><p>缓存雪崩： 缓存中的大量或所有数据失效<br>缓存击穿： 热点数据不在缓存中（通常是由于缓存中的那份数据已经过期）</p><h2 id="解决数据一致性问题常用的缓存读写策略"><a href="#解决数据一致性问题常用的缓存读写策略" class="headerlink" title="解决数据一致性问题常用的缓存读写策略"></a>解决数据一致性问题常用的缓存读写策略</h2><ul><li>旁路缓存：<ul><li>写：先更新数据库，然后直接删除缓存（数据库优先）</li><li>读：先读缓存；读不到就读db返回；然后把数据写入缓存</li><li>适用于读请求较多的场景</li></ul></li><li>读写穿透<ul><li>写：先查缓存，缓存中没有直接更新数据库；缓存中存在则先更新缓存，然后缓存同步更新数据库（缓存优先）</li><li>读：先读缓存；读不到就读db，写入缓存再返回</li></ul></li><li>异步缓存写入：<ul><li>类似读写穿透，<strong>两者都是由 cache 服务来负责 cache 和 db 的读写。</strong></li><li>两者区别在于：读写穿透<strong>同步更新数据库和缓存</strong>；异步缓存写入<strong>只更新缓存，异步批量更新数据库</strong></li></ul></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;缓存雪崩的解决方案&quot;&gt;&lt;a href=&quot;#缓存雪崩的解决方案&quot; class=&quot;headerlink&quot; title=&quot;缓存雪崩的解决方案&quot;&gt;&lt;/a&gt;缓存雪崩的解决方案&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;缓存在同一时间大面积的失效&lt;/strong&gt;，导致大量的请求都直接落</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>八股文骚套路之mysql</title>
    <link href="http://www.meprotoss.com/undefined/c53b31d1.html"/>
    <id>http://www.meprotoss.com/undefined/c53b31d1.html</id>
    <published>2024-09-20T09:05:20.000Z</published>
    <updated>2024-10-16T03:19:45.147Z</updated>
    
    <content type="html"><![CDATA[<h2 id="关系型数据库和非关系型数据库的区别"><a href="#关系型数据库和非关系型数据库的区别" class="headerlink" title="关系型数据库和非关系型数据库的区别"></a>关系型数据库和非关系型数据库的区别</h2><p>关系型数据库：</p><ol><li>用表存储数据，表表之间存在外键联系，存在一对一、一对多、多对多的联系</li><li>支持ACID事务，确保数据的一致性</li><li>用SQL语言进行查询和操作</li><li>存在数据冗余，还会用索引来提高检索速度，占用空间较大</li></ol><p>非关系型数据库：</p><ol><li>存储数据的方式多种多样，键值型、文档型、图形型等等</li><li>性能强大，适合高并发场景</li><li>数据冗余较少，相比关系型数据库节省内存空间</li></ol><h2 id="ORDER-BY、LIMIT、GROUP-BY、HAVING-这些关键字的作用"><a href="#ORDER-BY、LIMIT、GROUP-BY、HAVING-这些关键字的作用" class="headerlink" title="ORDER BY、LIMIT、GROUP BY、HAVING 这些关键字的作用"></a>ORDER BY、LIMIT、GROUP BY、HAVING 这些关键字的作用</h2><ul><li>order by：排序</li><li>limit: 限制查询返回的行数</li><li>group by：根据一个或多个列对查询结果分组</li><li>having: 用于过滤分组后的数据<ul><li>相比较where:HAVING 在分组后应用条件，而 WHERE 在分组前应用条件</li></ul></li></ul><h2 id="左链接和右链接的区别"><a href="#左链接和右链接的区别" class="headerlink" title="左链接和右链接的区别"></a>左链接和右链接的区别</h2><p>一个以左边的表为基础，确保左表中的行都出现在结果中,反之亦然</p><h2 id="InnoDB-mysql数据库管理系统的一个存储引擎-相关"><a href="#InnoDB-mysql数据库管理系统的一个存储引擎-相关" class="headerlink" title="InnoDB(mysql数据库管理系统的一个存储引擎)相关"></a>InnoDB(mysql数据库管理系统的一个存储引擎)相关</h2><p>索引的本质是一种排序好的数据结构</p><h3 id="InnoDB-和-MyISAM-的区别是什么"><a href="#InnoDB-和-MyISAM-的区别是什么" class="headerlink" title="InnoDB 和 MyISAM 的区别是什么"></a>InnoDB 和 MyISAM 的区别是什么</h3><ul><li>InnoDB 支持行级锁，MyISAM只有表级锁</li><li>MyISAM 不提供事务支持。</li><li>InnoDB 提供事务支持，MyISAM不支持。</li><li>MyISAM 不支持外键，而 InnoDB 支持。</li><li>MyISAM 不支持 MVCC，而 InnoDB 支持。</li><li>虽然 MyISAM 引擎和 InnoDB 引擎都是使用 B+Tree 作为索引结构，但是两者的实现方式不太一样。</li><li>MyISAM 不支持数据库异常崩溃后的安全恢复，而 InnoDB 支持。</li><li>InnoDB 的性能比 MyISAM 更强大<br>整个数据库，提高检索效率</li></ul><h2 id="索引相关"><a href="#索引相关" class="headerlink" title="索引相关"></a>索引相关</h2><h2 id="介绍一下索引的原理"><a href="#介绍一下索引的原理" class="headerlink" title="介绍一下索引的原理"></a>介绍一下索引的原理</h2><p>索引是一种用于快速查询和检索的数据结构，本质可以看作一种排序好的数据结构</p><p>索引的作用相当于书的目录，使得在检索数据库的时候不需要遍历</p><p>索引是基于某个或多个列的值创建的数据结构。它通过使用一种特定的算法和数据结构，将数据的键值与其物理存储位置进行映射</p><h3 id="索引所采用的数据结构，以及为什么要这样设计"><a href="#索引所采用的数据结构，以及为什么要这样设计" class="headerlink" title="索引所采用的数据结构，以及为什么要这样设计"></a>索引所采用的数据结构，以及为什么要这样设计</h3><p>常见的索引结构有:</p><ul><li><strong>hash表</strong> 不支持顺序和范围查询</li><li>红黑树</li><li><strong>B树</strong></li><li><strong>B+树</strong><ul><li>节点存放key，叶子存放key和data</li><li>叶子节点有一条引用鲢指向与他相邻的叶子节点</li><li>任何查找都是从根节点到叶子节点的过程，检索效率稳定</li><li>B+树的范围查找只需要对叶子节点作范围查询</li></ul></li><li>二叉查找树(左小右大)</li><li>平衡二叉树(优化的二叉查找树 左右子树高度之差不超过 1)</li></ul><h3 id="BTree-索引和-Hash-索引的适用范围"><a href="#BTree-索引和-Hash-索引的适用范围" class="headerlink" title="BTree 索引和 Hash 索引的适用范围"></a>BTree 索引和 Hash 索引的适用范围</h3><p>InnoDB数据库和MyISM数据库默认使用BTree索引</p><ul><li>hash索引适用于<strong>等值查询</strong>，尤其是在<strong>内存密集</strong>的环境中；</li><li>不适用于范围查询、排序和处理大量哈希冲突的情况</li></ul><h2 id="SQL优化问题"><a href="#SQL优化问题" class="headerlink" title="SQL优化问题"></a>SQL优化问题</h2><h3 id="索引的应用场景"><a href="#索引的应用场景" class="headerlink" title="索引的应用场景"></a>索引的应用场景</h3><p>数据库查询的几个常见函数：</p><ul><li>排序</li><li>连接</li><li>唯一性约束</li><li>聚集函数</li><li>范围查询</li></ul><h3 id="索引在哪些情况会失效"><a href="#索引在哪些情况会失效" class="headerlink" title="索引在哪些情况会失效"></a>索引在哪些情况会失效</h3><ul><li>不能对索引列进行查询和函数操作</li><li>数据分布不均匀</li><li>数据量很大</li><li>频繁更新的列</li><li>索引列参与复杂的表达式或者条件</li></ul><h2 id="事务四大特性，并解释这四大特性的含义"><a href="#事务四大特性，并解释这四大特性的含义" class="headerlink" title="事务四大特性，并解释这四大特性的含义"></a>事务四大特性，并解释这四大特性的含义</h2><p>ACID</p><ul><li>原子性 事务是最小执行单位，不允许分割</li><li>一致性 执行事务前后 数据保持一致</li><li>隔离性 并发访问数据库时，一个用户的事务不被其他事务所干扰</li><li>持久性 事务提交之后对数据库的影响是永久的</li></ul><p>只有保证了事务的持久性、原子性、隔离性之后，一致性才能得到保障。也就是说 A、I、D 是手段，C 是目的！</p><h2 id="并发事务处理会带来哪些问题？"><a href="#并发事务处理会带来哪些问题？" class="headerlink" title="并发事务处理会带来哪些问题？"></a>并发事务处理会带来哪些问题？</h2><ul><li>脏读 a读到了b修改未提交的数据</li><li>幻读 a多次读同一个数据，但是期间其他事务对数据进行了修改</li><li>丢失修改 a读一个数据，b也访问该数据，第一个事务修改数据之后，b也修改了这个数据，导致a的修改结果丢失</li></ul><h2 id="事务隔离级别"><a href="#事务隔离级别" class="headerlink" title="事务隔离级别"></a>事务隔离级别</h2><ul><li>读未提交 读取尚未提交的数据变更 会导致<strong>脏读 不可重读 幻读</strong></li><li>读已提交 允许读取并发事务已经提交的数据 会导致<strong>不可重读 幻读</strong></li><li>可重读 对同一字段的多次读取结果是一致的 会导致<strong>幻读</strong></li><li>可串行化 满足acid</li></ul><h2 id="InnoDB-行锁实现方式"><a href="#InnoDB-行锁实现方式" class="headerlink" title="InnoDB 行锁实现方式"></a>InnoDB 行锁实现方式</h2><ul><li><p>共享锁(s)（读锁）和排它锁(x)（写锁）</p></li><li><p>MVCC（多版本并发控制）MVCC可以在<strong>读取数据时不加锁</strong>，同时保证事务的一致性。每个事务在开始时都会生成一个唯一的事务ID，每行数据也会保存这个事务ID的版本信息。这样，即使其他事务在修改数据，当前事务也可以读取到之前版本的数据。</p></li><li><p>MVCC（多版本并发控制） 是一种<strong>并发控制机制</strong>，通过<strong>在每个数据行上维护多个版本的数据</strong>，当一个事务要对数据库中的数据进行修改的时候，MVCC会为该事务创建一个数据快照，而不是直接修改实际的数据行，用于在多个并发事务同时读写数据库时保持数据的一致性和隔离性</p></li></ul><p><strong>读操作使用旧版本数据的快照，写操作创建新版本，并确保原始版本仍然可用</strong></p><h2 id="你了解-Next-key-锁吗？"><a href="#你了解-Next-key-锁吗？" class="headerlink" title="你了解 Next-key 锁吗？"></a>你了解 Next-key 锁吗？</h2><p>Next-Key锁是一种特殊类型的锁，通常在实现范围查询时用于避免幻读（Phantom Read）问题。</p><p>Next-Key锁结合了行锁（Row Lock）和间隙锁（Gap Lock）的特性，用于确保范围查询的一致性。</p><ul><li>普通select读取的时候读取mvcc的快照</li><li>使用当前读的时候读取最新数据，并且防止其他事务在查询范围内插入数据</li></ul><h2 id="如何避免-InnoDB-中的死锁"><a href="#如何避免-InnoDB-中的死锁" class="headerlink" title="如何避免 InnoDB 中的死锁"></a>如何避免 InnoDB 中的死锁</h2><ul><li><strong>尽量使用索引</strong></li><li><strong>使用事务的隔离级别</strong></li><li>减少并发</li><li>合理设计事务</li></ul><h2 id="死锁的类型"><a href="#死锁的类型" class="headerlink" title="死锁的类型"></a>死锁的类型</h2><p>死锁是指多个事务在相互持有资源的情况下，同时等待对方释放资源</p><ul><li><p>简单死锁<br>涉及两个事务，互相等待</p></li><li><p>递归死锁<br>多个事务，循环等待</p></li><li><p>资源不足死锁<br>资源紧张的情况下，多个事务由于资源不足进入等待</p></li></ul><h2 id="如何优化数据库？"><a href="#如何优化数据库？" class="headerlink" title="如何优化数据库？"></a>如何优化数据库？</h2><ul><li>索引</li><li>分库分表: 就是将数据库中的数据分散到不同的数据库上,是<strong>对单表的数据进行拆分</strong>。</li><li>读写分离：将对数据库的读写操作分散到不同的数据库节点</li><li>数据冷热分离:根据数据的访问频率和业务重要性，将数据分为冷数据和热数据，冷数据一般存储在存储在低成本、低性能的介质中，热数据存放在高性能存储介质中。</li></ul><h2 id="数据库中的乐观锁和悲观锁，以及适用场景？"><a href="#数据库中的乐观锁和悲观锁，以及适用场景？" class="headerlink" title="数据库中的乐观锁和悲观锁，以及适用场景？"></a>数据库中的乐观锁和悲观锁，以及适用场景？</h2><ul><li><p>悲观锁：假设并发访问会导致冲突，因此在<strong>访问数据之前获取锁</strong>，以防止别的事务对数据进行修改,<strong>适用于频繁写的场景</strong>。（例如数据库中的行级锁和表级锁）</p></li><li><p>乐观锁：假设并发访问不会导致冲突，因此在访问数据时不会立即获取锁，<strong>在更新数据时检查数据是否被其他事务修改过</strong>，如果没有则进行更新，否则会进行回滚或者重试。<strong>适用于读操作多，写操作少的场景</strong></p></li></ul><h2 id="数据库响应慢可能有什么原因"><a href="#数据库响应慢可能有什么原因" class="headerlink" title="数据库响应慢可能有什么原因"></a>数据库响应慢可能有什么原因</h2><ul><li>查询复杂性：复杂的查询语句、多表连接、大量的数据过滤和排序等操作会增加数据库的负载。</li><li>索引缺失或失效：数据库需要进行全表扫描，导致响应时间变慢。</li><li>数据量过大</li><li>硬件资源不足</li><li>网络延迟：数据库服务器与应用服务器之间的网络延迟会影响数据库的响应时间。</li><li>锁竞争：并发访问数据库时，如果多个事务需要同时修改同一行数据或同一数据页，可能会出现锁竞争，导致等待时间增加，响应变慢。</li><li>数据库配置不当：数据库的配置参数（如缓冲池大小、并发连接数等）设置不合理，未充分利用硬件资源，导致性能下降。</li></ul><h2 id="如何删除大表中的所有数据"><a href="#如何删除大表中的所有数据" class="headerlink" title="如何删除大表中的所有数据"></a>如何删除大表中的所有数据</h2><ul><li>每次删除限定一定数量，然后分批次循环删除</li><li>直接按照需求删除指定分区表</li><li>拷贝表结构，生成临时表，删除原表，升级临时表为正式表</li><li>直接删除物理文件</li></ul><h2 id="数据库主从"><a href="#数据库主从" class="headerlink" title="数据库主从"></a>数据库主从</h2><p>用于数据库的读写分离，主库写，从库读，可以提高读的性能，应对数据库读并发问题</p><h2 id="视图有什么作用"><a href="#视图有什么作用" class="headerlink" title="视图有什么作用"></a>视图有什么作用</h2><ul><li>可以看到表结构，隐藏一些敏感信息</li><li>可以用来筛选数据表</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;关系型数据库和非关系型数据库的区别&quot;&gt;&lt;a href=&quot;#关系型数据库和非关系型数据库的区别&quot; class=&quot;headerlink&quot; title=&quot;关系型数据库和非关系型数据库的区别&quot;&gt;&lt;/a&gt;关系型数据库和非关系型数据库的区别&lt;/h2&gt;&lt;p&gt;关系型数据库：&lt;/p</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>八股文骚套路之Linux</title>
    <link href="http://www.meprotoss.com/undefined/f7999b22.html"/>
    <id>http://www.meprotoss.com/undefined/f7999b22.html</id>
    <published>2024-09-20T07:33:09.000Z</published>
    <updated>2024-10-17T03:04:24.943Z</updated>
    
    <content type="html"><![CDATA[<h2 id="inode（索引节点）"><a href="#inode（索引节点）" class="headerlink" title="inode（索引节点）"></a>inode（索引节点）</h2><p>unix系统中用于存储文件元数据的数据结构</p><p>index + node</p><p>inode就是用来维护某个文件被分成几块、每一块在的地址、文件拥有者，创建时间，权限，大小等信息。</p><h2 id="Linux常用指令"><a href="#Linux常用指令" class="headerlink" title="Linux常用指令"></a>Linux常用指令</h2><table><thead><tr><th>指令</th><th>作用</th></tr></thead><tbody><tr><td>stat</td><td>查看文件的 inode 信息</td></tr><tr><td>ln</td><td>创建硬链接</td></tr><tr><td>file</td><td>查看文件类型信息</td></tr><tr><td>tar</td><td>压缩和解压缩</td></tr><tr><td>ls -l</td><td>查看某个目录下的文件或目录的权限</td></tr><tr><td>top</td><td>查看系统的 CPU 使用率、内存使用率、进程信息等</td></tr><tr><td>systemctl</td><td>查看系统服务的状态、启动、停止、重启等</td></tr></tbody></table><h2 id="Linux获取实时刷新的日志"><a href="#Linux获取实时刷新的日志" class="headerlink" title="Linux获取实时刷新的日志"></a>Linux获取实时刷新的日志</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 实时刷新</span></span><br><span class="line"><span class="built_in">tail</span> -f logfile.log</span><br><span class="line"><span class="comment"># 每5分钟执行一次查询(watch -n 300 表示每300s执行一次后面的命令)</span></span><br><span class="line">watch -n 300 <span class="string">&#x27;tail logfile.log&#x27;</span></span><br><span class="line"></span><br><span class="line">journalctl -f</span><br></pre></td></tr></table></figure><h2 id="进程相关"><a href="#进程相关" class="headerlink" title="进程相关"></a>进程相关</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看进程</span></span><br><span class="line">ps -ef | grep xxx</span><br><span class="line"></span><br><span class="line"><span class="comment"># 杀死进程</span></span><br><span class="line"><span class="built_in">kill</span> -9 PID</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看端口号</span></span><br><span class="line">lsof -i:PORT</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看系统进程</span></span><br><span class="line">top</span><br><span class="line">ps</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看文件a的第7到9行 (head表示展示前几行，tail表示展示后几行)</span></span><br><span class="line"><span class="built_in">cat</span> a.txt | <span class="built_in">tail</span> -n +7 | <span class="built_in">head</span> -n 9</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看a.txt的第5行</span></span><br><span class="line"><span class="built_in">head</span> a.txt -n 5 | <span class="built_in">tail</span> -n 1</span><br></pre></td></tr></table></figure><h2 id="给文件夹或者文件增加权限"><a href="#给文件夹或者文件增加权限" class="headerlink" title="给文件夹或者文件增加权限"></a>给文件夹或者文件增加权限</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">chmod</span> +777</span><br></pre></td></tr></table></figure><h2 id="一次性关闭所有和qq相关的进程"><a href="#一次性关闭所有和qq相关的进程" class="headerlink" title="一次性关闭所有和qq相关的进程"></a>一次性关闭所有和qq相关的进程</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo killall qq</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;inode（索引节点）&quot;&gt;&lt;a href=&quot;#inode（索引节点）&quot; class=&quot;headerlink&quot; title=&quot;inode（索引节点）&quot;&gt;&lt;/a&gt;inode（索引节点）&lt;/h2&gt;&lt;p&gt;unix系统中用于存储文件元数据的数据结构&lt;/p&gt;
&lt;p&gt;index</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>八股文骚套路之测开</title>
    <link href="http://www.meprotoss.com/undefined/aec9bf64.html"/>
    <id>http://www.meprotoss.com/undefined/aec9bf64.html</id>
    <published>2024-06-23T12:07:23.000Z</published>
    <updated>2024-09-23T10:00:17.579Z</updated>
    
    <content type="html"><![CDATA[<h2 id="常用自动话测试工具"><a href="#常用自动话测试工具" class="headerlink" title="常用自动话测试工具"></a>常用自动话测试工具</h2><h3 id="Selenium"><a href="#Selenium" class="headerlink" title="Selenium"></a>Selenium</h3><p>Web自动化测试</p><h3 id="Postman"><a href="#Postman" class="headerlink" title="Postman"></a>Postman</h3><p>接口测试</p><h3 id="Jmeter"><a href="#Jmeter" class="headerlink" title="Jmeter"></a>Jmeter</h3><h3 id="Jenkins"><a href="#Jenkins" class="headerlink" title="Jenkins"></a>Jenkins</h3><h2 id="手机兼容性测试"><a href="#手机兼容性测试" class="headerlink" title="手机兼容性测试"></a>手机兼容性测试</h2><ul><li>系统兼容性</li><li>屏幕兼容性</li><li>型号兼容性</li><li>数据来源</li></ul><h2 id="软件开发流程"><a href="#软件开发流程" class="headerlink" title="软件开发流程"></a>软件开发流程</h2><ul><li>需求分析</li><li>指定测试计划</li><li>用例设计</li><li>用例执行</li><li>缺陷管理</li><li>测试报告</li></ul><h2 id="软件测试方法"><a href="#软件测试方法" class="headerlink" title="软件测试方法 *****"></a>软件测试方法 *****</h2><ol><li>软件测试方法：白盒、黑盒(功能测试)、灰盒、 静态测试、动态测试</li></ol><p>白盒测试一般可被分为<strong>静态分析</strong>和<strong>动态分析</strong>两类技术：</p><ul><li>静态分析主要有：控制流分析技术、数据流分析技术、信息流分析技术。</li><li>动态分析主要有：逻辑覆盖率测试(分支测试、路径测试等)，程序插装等。</li><li>白盒测试优点：迫使测试人员去仔细的思考软件的实现；可以检测代码中的每条分支和路径；揭示隐藏在代码中的错误；对代码的测试比较彻底</li><li>白盒测试缺点：昂贵；无法检测代码中遗漏的路径和数据敏感性错误；不验证规格的正确性。</li></ul><p>静态测试：是一种不通过执行程序而进行测试的技术。它的关键功能是检查软件的表示和描述是否一致，没有冲突或者没有歧义</p><p>动态测试：包含了程序在受控的环境下使用特定的期望结果进行正式的运行。它显示了一个系统在检查状态下是正确还是不正确。<br> 单元测试属于白盒测试范畴；集成测试属于灰盒测试范畴；系统测试属于黑盒测试范畴。</p><h2 id="CI-CD理解"><a href="#CI-CD理解" class="headerlink" title="CI&#x2F;CD理解"></a>CI&#x2F;CD理解</h2><ul><li>CI(Continuous Integration)持续集成</li></ul><p>持续集成强调开发人员提交了新代码之后，立刻进行构建、（单元）测试。根据测试结果，我们可以确定新代码和原有代码能否正确地集成在一起。<br><strong>集成</strong>是指软件个人研发的部分向软件整体部分交付，以便尽早发现个人开发部分的问题；</p><ul><li><p>CD(Continuous Delivery)持续交付<br>持续交付在持续集成的基础上，将集成后的代码部署到更贴近真实运行环境的「类生产环境」（production-like environments）中。比如，我们完成单元测试后，可以把代码部署到连接数据库的 Staging 环境中更多的测试。如果代码没有问题，可以继续手动部署到生产环境中。<br><strong>交付</strong>是指研发尽快向客户交付，以便尽早发现生产环境中存在的问题。</p></li><li><p>CD(Continuous Deployment)持续部署<br>持续部署则是在持续交付的基础上，把部署到生产环境的过程自动化。<br><strong>部署</strong>是代码尽快向可运行的开发&#x2F;测试节交付，以便尽早测试；</p></li></ul><p>所谓的<strong>持续</strong>，就是说每完成一个完整的部分，就向下个环节交付，发现问题可以马上调整。是的问题不会放大到其他部分和后面的环节。</p><h2 id="单元测试"><a href="#单元测试" class="headerlink" title="单元测试 ***"></a>单元测试 ***</h2><p>单元测试是指，对软件中的<strong>最小可测试单元</strong>在与程序其他部分相隔离的情况下进行检查和验证的工作，这里的最小可测试单元通常是指<strong>函数或者类</strong>。</p><h2 id="时间紧任务重不能加人的情况怎么尽最大努力测试"><a href="#时间紧任务重不能加人的情况怎么尽最大努力测试" class="headerlink" title="时间紧任务重不能加人的情况怎么尽最大努力测试?"></a>时间紧任务重不能加人的情况怎么尽最大努力测试?</h2><p>答：1. 不写测试用例，先和产品人员沟通覆盖主要业务，选出重要的模块先正向后逆向2. 可以使用错误推荐法<strong>根据经验复测</strong>。</p><h2 id="任何测试都应该先走业务"><a href="#任何测试都应该先走业务" class="headerlink" title="任何测试都应该先走业务"></a>任何测试都应该先走<strong>业务</strong></h2><p>而测业务需要使用场景法</p><h2 id="针对某一个产品写测试用例-性-功能-兼-用-安-稳"><a href="#针对某一个产品写测试用例-性-功能-兼-用-安-稳" class="headerlink" title="针对某一个产品写测试用例(性 功能 兼 用 安 稳)"></a>针对某一个产品写测试用例(性 功能 兼 用 安 稳)</h2><p>基本思路：可以从功能测试，UI测试，稳定性测试，压力测试（边界极限），安全测试，本地化测试等角度去考虑</p><p><strong>首先应从正向和逆向考虑功能</strong></p><h3 id="测试水杯"><a href="#测试水杯" class="headerlink" title="测试水杯 *"></a>测试水杯 *</h3><ol><li>基本功能<br>硬度、装载能力、装载种类、漏水、冷水&#x2F;热水&#x2F;冰水、保温</li><li>界面测试(UI)<br>看其形状、大小设计是否符合需求规格说明书的定义，适合人方便拿起喝水；<br>外观是否吸引人，赏心悦目；<br>广告图案沾水后是否掉色、模糊；<br>广告图案是否使用环保材料、不影响使用者健康和回收再利用；<br>广告图案是否和当地政治、宗教符合，没有冲突；<br>广告图案是否做到了本地化和国际化。</li><li>易用性测试</li><li>稳定性测试</li><li>安全性</li><li>本地化测试<br>为国际化和本地化的需要，广告图案和文字是否在政治、宗教和文化方面具有广泛的适用性；</li><li>性能测试</li></ol><h3 id="测试一个输入框-计数"><a href="#测试一个输入框-计数" class="headerlink" title="测试一个输入框(计数) **"></a>测试一个输入框(计数) **</h3><p>通常是一个登陆页面，上面有用户名，密码的输入框，再多一点的有个验证码。</p><h3 id="针对“用户登录”设计测试用例"><a href="#针对“用户登录”设计测试用例" class="headerlink" title="针对“用户登录”设计测试用例 ***"></a>针对“用户登录”设计测试用例 ***</h3><h4 id="功能测试"><a href="#功能测试" class="headerlink" title="功能测试"></a>功能测试</h4><ul><li><p>正向用例:</p><ol><li>输入已注册的用户名和正确的密码，验证是否登录成功；</li></ol></li><li><p>逆向用例：</p><ol start="2"><li>输入已注册的用户名和不正确的密码，验证是否登录失败，并且提示信息正确；</li><li>输入未注册的用户名和任意密码，验证是否登录失败，并且提示信息正确；</li><li>用户名和密码两者都为空，验证是否登录失败，并且提示信息正确；</li><li>用户名和密码两者之一为空，验证是否登录失败，并且提示信息正确；</li><li>如果登录功能启用了验证码功能，在用户名和密码正确的前提下，输入正确的验证码，验证是否登录成功；</li><li>如果登录功能启用了验证码功能，在用户名和密码正确的前提下，输入错误的验证码，验证是否登录失败，并且提示信息正确。</li></ol></li></ul><p>以上是基本的</p><ul><li><p>有经验的测试测试工程师还会增加:</p><ol><li>用户名和密码是否大小写敏感；</li><li>页面上的密码框是否加密显示；</li><li>后台系统创建的用户第一次登录成功时，是否提示修改密码；</li><li>忘记用户名和忘记密码的功能是否可用；</li><li>前端页面是否根据设计要求限制用户名和密码长度；</li><li>如果登录功能需要验证码，点击验证码图片是否可以更换验证码，更换后的验证码是否可用；</li><li>刷新页面是否会刷新验证码；</li><li>如果验证码具有时效性，需要分别验证时效内和时效外验证码的有效性；</li><li>用户登录成功但是会话超时后，继续操作是否会重定向到用户登录界面；</li><li>不同级别的用户，比如管理员用户和普通用户，登录系统后的权限是否正确；</li><li>页面默认焦点是否定位在用户名的输入框中；</li><li>快捷键Tab 和Enter等，是否可以正常使用。</li></ol></li></ul><h4 id="性能"><a href="#性能" class="headerlink" title="性能"></a>性能</h4><ol><li>单用户登录的响应时间是否小于3秒；</li><li>单用户登录时，后台请求数量是否过多；</li><li>高并发场景下用户登录的响应时间是否小于5秒；</li><li>高并发场景下服务端的监控指标是否符合预期；</li><li>高集合点并发场景下，是否存在资源死锁和不合理的资源等待；</li><li>长时间大量用户连续登录和登出，服务器端是否存在内存泄漏。</li></ol><h4 id="安全性"><a href="#安全性" class="headerlink" title="安全性"></a>安全性</h4><ol><li>用户密码后台存储是否加密；</li><li>用户密码在网络传输过程中是否加密；</li><li>密码是否具有有效期，密码有效期到期后，是否提示需要修改密码；</li><li>不登录的情况下，在浏览器中直接输入登录后的URL地址，验证是否会重新定向到用户登录界面；</li><li>密码输入框是否不支持复制和粘贴；</li><li>密码输入框内输入的密码是否都可以在页面源码模式下被查看；</li><li>用户名和密码的输入框中分别输入典型的“SQL注入攻击”字符串，验证系统的返回页面；</li><li>用户名和密码的输入框中分别输入典型的“XSS跨站脚本攻击”字符串，验证系统行为是否被篡改；</li><li>连续多次登录失败情况下，系统是否会阻止后续的尝试以应对暴力破解；</li><li>同一用户在同一终端的多种浏览器上登录，验证登录功能的互斥性是否符合设计预期；</li><li>同一用户先后在多台终端的浏览器上登录，验证登录是否具有互斥性。</li></ol><h4 id="兼容性"><a href="#兼容性" class="headerlink" title="兼容性"></a>兼容性</h4><ol><li>不同浏览器下，验证登录页面的显示以及功能正确性；</li><li>相同浏览器的不同版本下，验证登录页面的显示以及功能正确性；</li><li>不同移动设备终端的不同浏览器下，验证登录页面的显示以及功能正确性；</li><li>不同分辨率的界面下，验证登录页面的显示以及功能正确性。</li></ol><h3 id="微信红包测试用例"><a href="#微信红包测试用例" class="headerlink" title="微信红包测试用例 *****"></a>微信红包测试用例 *****</h3><p>从业务流程考虑:</p><p>单个红包：</p><ol><li>红包金额为空、0、0.01、200.00、200.01、199.99、200</li><li>留言输入数字、字母、汉字、特殊字符</li><li>留言长度</li><li>留言复制粘贴</li><li>表情选择收藏表情、其他表情</li><li>删除表情、重新选择表情</li><li>选择支付方式:零钱、银行卡、添加新卡支付。其中钱数&lt;红包钱数、其中钱数&#x3D;红包钱数、其中钱数&gt;红包钱数</li><li>使用指纹确认付款（正确的、错误的指纹）</li><li>使用密码确认付款（正确的、错误的密码）</li><li>红包成功发送后 相应支付方式中钱数减少（减少金额与红包金额一致）</li><li>接受者能看到红包具体信息，红包金额、留言、表情均能正确显示</li><li>红包被拆开后显示已领取，领取者零钱中增加正确金额，再次领取只能查看红包信息</li><li>发红包者自己领红包</li><li>红包24小时未被领取提示红包被退回，相应支付方式中钱数增加（增加金额与红包金额一致），对方不能领红包</li></ol><p>群发红包-普通红包：（只写了与单个红包不同的地方）</p><ol><li>红包个数 为空、0、001、100、99、101</li><li>红包拆开每个金额一样 均为发红包时设置的单个金额对应的钱数</li><li>红包被拆时，有相应提示</li><li>发红包者自己领红包</li><li>红包24小时内未被拆完，剩余钱被退回，相应支付方式中钱数增加</li></ol><p>群发红包-拼手气红包：</p><ol><li>红包总额&#x2F;红包个数&lt;0.01</li><li>红包每个人拆开金额不同，总金额与发红包设置的总额一致</li><li>红包24小时内拆完后显示最佳手气</li><li>红包24小时内未被拆完不显示最佳手气</li></ol><p>兼容性：安卓、苹果 不同型号版本手机</p><p>UI测试：界面无错别字，风格统一</p><p>中断测试：不同应用之间切换、断网、来电、短信、低电量、手机没电</p><p>网络测试：2g&#x2F;3g&#x2F;4g  WiFi 移动联通电信  弱网  无网</p><h3 id="微信朋友圈测试用例"><a href="#微信朋友圈测试用例" class="headerlink" title="微信朋友圈测试用例 *****"></a>微信朋友圈测试用例 *****</h3><p>当给出的功能比较笼统的时候，可以想一想这个大功能有哪些小功能 然后再考虑这些小功能的业务流程或者说使用场景逻辑，从中提取测试点，提取到测试点之后再使用等价类法、边界值法等方法设计具体的设计用例。</p><p>功能测试</p><p>1 朋友圈发送功能</p><p>1）只发送文本</p><p>a、考虑文本长度：1-1500字符（该数据为百度数据）、超出最大字符长度</p><p>b、文本是否支持复制粘贴</p><p>c、为空验证</p><p>2）只发送图片</p><p>a、本地相册选择&#x2F;拍摄</p><p>b、图片数量验证：1-9张图片、超出9张</p><p>c、为空验证</p><p>3）只发送视频</p><p>a、本地相册选择&#x2F;拍摄</p><p>b、视频秒数验证：1-10s，超出10s</p><p>c、视频个数验证：1个，超出1个</p><p>d、视频格式验证：支持的视频格式，例mp4、不支持的视频格式</p><p>e、视频大小验证：苹果400kb以内、Android200-300kb（此为百度数据）、超出规定大小</p><p>f、视频预览增删改操作</p><p>g、为空验证</p><p>4）发送文本+图片：输入满足要求的文本、图片进行一次验证</p><p>5）发送文本+视频：输入满足要求的文本、视频进行一次验证</p><p>6）发送图片+视频：不支持发送</p><p>7）朋友圈发送内容是否有限制，例如涉及黄赌毒等敏感字</p><p>8）所在位置</p><p>a、不显示位置：发送到朋友圈动态不显示位置</p><p>b、选择对应位置：搜索支持、自动定位、手动编辑</p><p>C、点击取消，返回上一级页面</p><p>9）谁可以看</p><p>a、设置公开：所有朋友可见</p><p>b、设置私密（仅自己可见）：自己查看朋友圈-可见、好友查看朋友圈-不可见</p><p>c、设置部分可见（部分朋友可见）：选择的部分好友-可见、不被选择的好友-不可见、是否有人数上限</p><p>d、设置不给谁看（选中的朋友不可见）：不被选中的朋友-可见、被选中的朋友-不可见、是否有人数上限</p><p>e、点击取消，返回发送页面</p><p>10）提醒谁看</p><p>a、提醒单人&#x2F;提醒多人：被提醒的朋友-收到消息提醒、未被提醒-未有消息提醒</p><p>b、是否有人数上限</p><p>c、点击取消，返回发送页面</p><p>11）同步QQ空间：默认不同步、同步到QQ空间</p><p>12）取消发送朋友圈操作</p><p>a、选择相机，点击取消，返回朋友圈页面</p><p>b、进入朋友圈发送页面，选择文本图片，点击取消</p><p>13）朋友圈当天发送次数是否有上限限制</p><p>2、朋友圈浏览功能</p><p>1）文本查看：</p><p>a、过长文本内容是否隐藏，并支持查看全文</p><p>b、右键选择复制、收藏、翻译</p><p>c、url链接是否支持点击跳转网页</p><p>2）图片查看</p><p>a、小图右键支持收藏&#x2F;编辑</p><p>b、点击支持大图浏览</p><p>c、选择发送给朋友、收藏、保存图片、编辑</p><p>d、多张图片支持左右滑动浏览</p><p>3）视频查看</p><p>a、右键视频支持静音播放&#x2F;搜藏</p><p>b、点击视频播放按键支持播放视频</p><p>c、选择发送给朋友、收藏、保存视频、编辑</p><p>4）分享动态浏览：QQ空间&#x2F;公众号文章&#x2F;非腾讯产品分享后朋友圈是否正常显示</p><p>5）赞：点赞、取消点赞</p><p>6）评论</p><p>a、评论长度：评论字数合理长度、评论超过字数上限</p><p>b、评论类型：纯中文、纯数字、纯字母、纯字符、纯表情（微信表情&#x2F;手机自带表情）、混合类型、包含url链接；</p><p>c、评论是否支持复制粘贴</p><p>d、为空验证</p><p>e、发表评论后删除</p><p>f、评论回复操作</p><p>7）删除朋友圈动态</p><p>8）更换相册封面</p><p>9）刷新是否正常获取新动态</p><p>10）上滑是否加载更多</p><p>界面&#x2F;易用性测试</p><p>1、技术人员角度：页面布局设计是否跟产品原型图&#x2F;ui效果图一致</p><p>2、但除了考虑1之外，我们同样要考虑到用户使用：功能操作是否简便，页面布局排版风格是否美观合理，提示语相关信息是否易于理解</p><p>中断测试</p><p>1、主要考虑：a)核心功能  b)当前功能存在实时数据交换，例发朋友圈、浏览朋友圈进行中断，是否容易出现崩溃</p><p>2、中断包括：前后台切换、锁屏解锁、断网重连、app切换、来电话&#x2F;来短信中断、插拔耳机线&#x2F;数据线</p><p>网络测试</p><p>1、三大运营商不同网络制式测试</p><p>2、网络切换测试：WIFI&#x2F;4G&#x2F;3G&#x2F;2G</p><p>3、无网测试：对于缓存在本地的数据，部分朋友圈信息是否支持浏览</p><p>4、弱网测试：</p><p>a、延时：页面响应时间是否可接受、不同网络制式是否区分超时时长、出现请求超时，是否给予相应的提示</p><p>b、丢包：有无超时重连机制、如果未响应，是否给予相应提示</p><p>c、页面呈现的完整性验证</p><p>兼容性测试</p><p>1、Android手机端、苹果手机端、pad版（主流）功能界面显示是否正常</p><p>2、各平台朋友圈展示数据是否一致</p><p>安全测试</p><p>发送朋友圈时，文本输入脚本代码，是否出现异常</p><p>性能测试</p><p>1、服务器性能测试</p><p>可通过loadrunner&#x2F;jmeter工具实现，主要关注TPS、响应时间、吞吐量、CPU、内存等</p><p>2、app客户端性能测试</p><p>可通过GT工具实现，运行时关注cpu、内存、流量、电量等占用率</p><p>3、app压力稳定性测试</p><p>通过monkey工具实现，频繁发送朋友圈，浏览朋友圈请求，是否容易发生崩溃</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;常用自动话测试工具&quot;&gt;&lt;a href=&quot;#常用自动话测试工具&quot; class=&quot;headerlink&quot; title=&quot;常用自动话测试工具&quot;&gt;&lt;/a&gt;常用自动话测试工具&lt;/h2&gt;&lt;h3 id=&quot;Selenium&quot;&gt;&lt;a href=&quot;#Selenium&quot; class=&quot;</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>暑期实习复盘</title>
    <link href="http://www.meprotoss.com/undefined/20a82735.html"/>
    <id>http://www.meprotoss.com/undefined/20a82735.html</id>
    <published>2024-06-23T06:56:33.000Z</published>
    <updated>2024-06-23T08:01:42.314Z</updated>
    
    <content type="html"><![CDATA[<h2 id="网易互娱游戏测试"><a href="#网易互娱游戏测试" class="headerlink" title="网易互娱游戏测试"></a>网易互娱游戏测试</h2><h3 id="一面-1小时"><a href="#一面-1小时" class="headerlink" title="一面(1小时)"></a>一面(1小时)</h3><ul><li><p>自我介绍</p></li><li><p>脑机接口具体研究内容</p></li><li><p>最近有玩过什么游戏吗<br>回答了街头霸王6 哈迪斯</p></li><li><p>格斗游戏小众，你喜欢玩这个游戏原因是什么</p></li><li><p>为什么格斗游戏小众，为什么没有扩展开来</p><ul><li>上手难度高，机制会比较复杂</li><li>挫败感比较强</li><li>设备成本高，缺乏便携性</li><li>兴起于街机厅</li><li>付费购买</li></ul></li><li><p>游戏中设置机器人让玩家获得正反馈，为什么格斗游戏不能这么做</p><ul><li>pve不是游戏的核心</li><li>即使有ai加持，操作模式死板，取巧攻略</li><li>人是各种各样的，随机性更强</li></ul></li><li><p>moba类游戏可以盛行的原因是什么？和格斗游戏的区别在哪里？</p><ul><li>硬件成本比较低</li><li>付费成本低，大部分免费</li><li>新手用户多，不容易被虐</li><li>社群做的很好，社交属性强</li><li>moba类游戏上手简单</li></ul></li><li><p>格斗游戏做成免费，皮肤卖钱 会有什么问题？</p><ul><li>可以尝试</li></ul></li><li><p>没有人这么干的原因</p><ul><li>制作成本比较高，圈子小 不挣钱，所以只要找准用户定位</li></ul></li><li><p>如何向年轻人推广</p><ul><li>加强键盘适配，降低硬件成本</li><li>简易出招模式</li><li>尝试手游格斗，让大家尝试一下</li></ul></li><li><p>手游最近在玩什么？</p><ul><li>穿越火线手游</li><li>爆破模式 互相配合 游戏机制有趣</li></ul></li><li><p>其他类型 和平精英玩过没？现在为什么不玩了</p><ul><li>手游fps手感不好，交互体现很好。</li></ul></li><li><p>和平精英玩的人很多，为什么会有受众群体?</p><ul><li>便携性和社交属性</li></ul></li><li><p>非腾讯系的游戏无法背靠qq 微信通讯软件，如何做社交属性的开发？</p><ul><li>利用第三方社交平台交流互动</li><li>游戏内部搭建工会 社团 世界平台</li><li>接入qq 微信的分享功能</li></ul></li><li><p>游戏内如何做交流平台 实现什么样的功能？</p><ul><li>围绕竞争和合作两个方向来做</li><li>合作方面：按流派玩法门派职业进行分类，让类似玩家进行合作和交流</li><li>竞争： pk关系 排行榜</li><li>其他的：玩家工会等等其他常见方案</li></ul></li><li><p>排行榜用什么数据结构来实现</p><ul><li>考虑到数据唯一 有序 不可重复 可使用有序表 sortedlist</li></ul></li><li><p>玩家数量很多一次性把上千万玩家放到一个list会爆内存怎么办</p><ul><li>加锁 进行并发控制</li></ul></li><li><p>指出我理解错误，意思是把所有玩家数据加载到一个list内存会放不下怎么办？</p><ul><li>内存扩容</li><li>对数据进行过滤</li></ul></li><li><p>如何做过滤</p><ul><li>做排序 然后再选区要的部分</li></ul></li><li><p>做排序还是要把数据一次性读出来，还有没有别的方案？</p><ul><li>使用一个区间进行初次过滤，筛选掉大部分玩家，然后再排序</li></ul></li><li><p>筛选区间如何设置？</p><ul><li>用统计学上的分布进行判断</li></ul></li><li><p>假设排行榜上一开始所有的数据都是0 该怎么办？</p><ul><li>没懂让再解释一下</li></ul></li><li><p>假设一开始全是0 不就没法筛选了吗？这时候怎么办?</p><ul><li>答了不会</li></ul></li><li><p>sortedlist底层实现是什么？如何保证有序的？</p><ul><li>没有深入了解过，但是我觉得应该是数组+链表</li><li>数组用来存，链表保证有序</li></ul></li><li><p>解释一下你的思路</p><ul><li>链表保存前后关系，实现类似于hashtable</li></ul></li><li><p>保证链表插入有序的时间复杂度？</p><ul><li>O(n)</li></ul></li><li><p>对一个链表进行重新排序的思路和时间复杂度</p><ul><li>没想到好方法，回答了暴力思路 😭 O(n^2)</li></ul></li><li><p>你这个时间复杂度超过了大部份常用排序算法，你为什么要用复杂度这么高的链表</p><ul><li>我说确实不太合适，得具体看业务场景，然后回答了使用链表的好处说了插入方便，不用占用连续内存空间，然后面试官就说ok了</li></ul></li><li><p>为一个函数设计测试用例：有序链表再插入一个新的值之后，仍然有序。</p><ul><li>懵逼，回答了不同位置插入；不同数据类型插入；高频词插入(面试的时候组织不起来语言，说一直插有够尴尬)</li></ul></li><li><p>反问</p></li></ul><h2 id="二面-55分钟"><a href="#二面-55分钟" class="headerlink" title="二面(55分钟)"></a>二面(55分钟)</h2><ul><li>自我介绍</li><li>为什么投这个岗位</li><li>除了这个岗位还考虑什么岗位</li><li>简历上的测试项目，项目背景等等拷打</li><li>自动化测试 web场景的思路，具体做了什么？</li><li>错误码有哪些？</li><li>为什么要做这个项目（简历上的</li><li>白盒黑盒测试相关</li><li>你觉得你网上下的项目里的项目质量怎么样，学到了什么</li><li>评价一下自己的编码能力</li><li>有大型项目经历吗？平时代码量怎么样？</li><li>手撕shell脚本 批量文件重命名（简单</li><li>为什么平时开发要用linux 脚本为什么不用python，而用shell和lua</li><li>如何调试你刚刚写的代码</li><li>做过最大型的项目是什么</li><li>论文进度？</li><li>后面就是压力面相关，加班、同事关系等等</li><li>大家对你的评价</li></ul><h2 id="hr面-很快，全程约15分钟"><a href="#hr面-很快，全程约15分钟" class="headerlink" title="hr面(很快，全程约15分钟)"></a>hr面(很快，全程约15分钟)</h2><ul><li>自我介绍</li><li>项目</li><li>项目中担任的角色</li><li>项目中遇到的最大的困难</li><li>三个关键词形容自己</li><li>加班等压力面相关</li><li>为什么选择这个岗位</li><li>了解过别的游戏公司吗</li><li>职业规划</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;网易互娱游戏测试&quot;&gt;&lt;a href=&quot;#网易互娱游戏测试&quot; class=&quot;headerlink&quot; title=&quot;网易互娱游戏测试&quot;&gt;&lt;/a&gt;网易互娱游戏测试&lt;/h2&gt;&lt;h3 id=&quot;一面-1小时&quot;&gt;&lt;a href=&quot;#一面-1小时&quot; class=&quot;headerli</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>八股文骚套路之操作系统</title>
    <link href="http://www.meprotoss.com/undefined/2d72da9e.html"/>
    <id>http://www.meprotoss.com/undefined/2d72da9e.html</id>
    <published>2024-06-09T08:46:47.000Z</published>
    <updated>2024-10-16T02:44:59.460Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://mubu.com/app/edit/home/5Vbsc1GjSNm">八股-操作系统</a></p><h2 id="内核态和用户态和系统调用"><a href="#内核态和用户态和系统调用" class="headerlink" title="内核态和用户态和系统调用"></a>内核态和用户态和系统调用</h2><p>根据进程访问资源的特点，把进程在系统上的运行分为用户态和内核态</p><p>用户态具有较低的数据访问权限，可直接读取用户程序的数据，而内核态拥有较高的权限，几乎可以访问计算机的任何资源，当应用程序需要执行某些特殊权限的操作的时候，会通过系统调用切换到内核态</p><p>把进程分为用户态和内核态是出于安全性和性能上的考虑</p><p>用户态和内核态之间的切换有系统调用、中断、异常三种方式</p><p>系统调用是主动用户态进程主动要求切换的一种方式，通过系统调用，应用程序可以和操作系统之间进行交互，访问操作系统底层资源（文件、设备、网络</p><p>中断是外部设备完成用户操作请求之后，向cpu发出中断信号，这时cpu会暂停执行吓一跳指令先去执行中断信号对应的程序，如果中断之前执行的是用户态程序，那么此时就自然而然的发生了用户态到内核态之间的切换</p><p>异常是cpu在执行用户态程序的时候，发生了不可知的异常，此时进程会切换到异常处理的内核相关程序中，也就切换到了内核态。</p><h2 id="进程和线程（重要）"><a href="#进程和线程（重要）" class="headerlink" title="进程和线程（重要）"></a>进程和线程（重要）</h2><h3 id="进程和线程的基本定义，然后再让你对比一下两者"><a href="#进程和线程的基本定义，然后再让你对比一下两者" class="headerlink" title="进程和线程的基本定义，然后再让你对比一下两者"></a>进程和线程的基本定义，然后再让你对比一下两者</h3><ul><li>进程是计算机上正在运行的一个程序的实例</li><li>线程也被称为轻量级进程,是进程被划分为更小的运行单位。</li><li>一个程序至少有一个进程，一个进程至少有一个线程</li><li>进程和进程之间不共享资源是独立的，线程和线程之间共享同一个进程的资源,且有可能互相影响</li></ul><h3 id="进程和线程的状态"><a href="#进程和线程的状态" class="headerlink" title="进程和线程的状态"></a>进程和线程的状态</h3><p>我们一般把进程大致分为 5 种状态，这一点和线程很像,</p><ol><li>创建状态(new)：进程正在被创建</li><li>就绪状态(ready)：进程已处于准备运行状态，即进程获得了除了处理器之外的一切所需资源，一旦得到处理器资源(处理器分配的时间片)即可运行</li><li>运行状态(running)</li><li>阻塞状态(waiting)：又称为等待状态，进程正在等待某一事件而暂停运行如等待某资源为可用或等待 IO 操作完成。即使处理器空闲，该进程也不能运行。</li><li>结束状态(terminated)</li></ol><h2 id="内存管理（重要）"><a href="#内存管理（重要）" class="headerlink" title="内存管理（重要）"></a>内存管理（重要）</h2><h3 id="内存管理的目的、逻辑和物理地址"><a href="#内存管理的目的、逻辑和物理地址" class="headerlink" title="内存管理的目的、逻辑和物理地址"></a>内存管理的目的、逻辑和物理地址</h3><ul><li>内存的分配与回收：对进程所需的内存进行分配和释放，malloc 函数：申请内存，free 函数：释放内存。</li><li>地址转换：将程序中的虚拟地址转换成内存中的物理地址。</li><li>内存扩充：当系统没有足够的内存时，利用虚拟内存技术或自动覆盖技术，从逻辑上扩充内存。</li><li>内存映射：将一个文件直接映射到进程的进程空间中，这样可以通过内存指针用读写内存的办法直接存取文件内容，速度更快。</li><li>内存优化：通过调整内存分配策略和回收算法来优化内存使用效率。</li><li>内存安全：保证进程之间使用内存互不干扰，避免一些恶意程序通过修改内存来破坏系统的安全性。</li></ul><h3 id="内存管理机制"><a href="#内存管理机制" class="headerlink" title="内存管理机制"></a>内存管理机制</h3><ul><li><p>连续内存管理：为一个用户程序分配一个连续的内存空间，内存利用率一般不高。容易产生内存碎片</p></li><li><p>非连续内存管理：允许一个程序使用的内存分布在离散或者说不相邻的内存中，相对更加灵活一些。</p></li></ul><h3 id="虚拟内存和请求分页"><a href="#虚拟内存和请求分页" class="headerlink" title="虚拟内存和请求分页"></a>虚拟内存和请求分页</h3><p>虚拟内存(Virtual Memory)本质上来说它只是逻辑存在的，是一个假想出来的内存空间<br>它允许程序访问比实际物理内存更大的内存空间。<br>在使用虚拟内存的系统中，每个程序都认为它拥有连续的、私有的内存空间，这被称为虚拟地址空间</p><p>  虚拟内存的主要主要作用：</p><ul><li>隔离进程：物理内存通过虚拟地址空间访问，虚拟地址空间与进程一一对应。每个进程都认为自己拥有了整个物理内存，进程之间彼此隔离，一个进程中的代码无法更改正在由另一进程或操作系统使用的物理内存。</li><li>提升物理内存利用率：有了虚拟地址空间后，操作系统只需要将进程当前正在使用的部分数据或指令加载入物理内存。</li><li>简化内存管理：进程都有一个一致且私有的虚拟地址空间，程序员不用和真正的物理内存打交道，而是借助虚拟地址空间访问物理内存，从而简化了内存管理。</li><li>多个进程共享物理内存：进程在运行过程中，会加载许多操作系统的动态库。这些库对于每个进程而言都是公用的，它们在内存中实际只会加载一份，这部分称为共享内存。</li><li>提高内存使用安全性：控制进程对物理内存的访问，隔离不同进程的访问权限，提高系统的安全性。</li><li>提供更大的可使用内存空间：可以让程序拥有超过系统物理内存大小的可用内存空间。<br>这是因为<strong>当物理内存不够用时，可以利用磁盘充当</strong>，将物理内存页（通常大小为 4 KB）保存到磁盘文件（会影响读写速度），数据或代码页会根据需要在物理内存与磁盘之间移动。</li></ul><p><strong>局部性原理</strong>是指在程序执行过程中，数据和指令的访问存在一定的空间和时间上的局部性特点。其中，时间局部性是指一个数据项或指令在一段时间内被反复使用的特点，空间局部性是指一个数据项或指令在一段时间内与其相邻的数据项或指令被反复使用的特点。</p><ul><li>请求分页 ： 页表机制、缺页中断、页面置换算法</li></ul><h2 id="虚拟地址和物理地址"><a href="#虚拟地址和物理地址" class="headerlink" title="虚拟地址和物理地址"></a>虚拟地址和物理地址</h2><p>虚拟地址是程序开发时程序员与程序员进行交互的地址<br>物理地址就是内存地址寄存器中真正的地址</p><p>MMU(memeory management unit)将虚拟地址转化为物理地址,这个过程称之为<strong>地址转换</strong></p><p>而地址转换有两种方式:</p><p><strong>分段机制</strong>和<strong>分页机制</strong></p><p>分段机制以一段连续的物理内存管理（不同长度的段）和分配物理内存，通过段表来映射虚拟地址和物理地址</p><p>分页机制把物理内存分为<strong>连续等长</strong>的物理页，通过页表来映射地址,虚拟地址空间中的任意虚拟页可以被映射到任意的物理页上，所以可以实现物理内存资源的离散分配</p><h2 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h2><p>多个进程&#x2F;线程同时被阻塞，它们中的一个或者全部都在等待某个资源被释放。由于进程&#x2F;线程被无限期地阻塞，因此程序不可能正常终止。</p><h3 id="死锁的必要条件"><a href="#死锁的必要条件" class="headerlink" title="死锁的必要条件"></a>死锁的必要条件</h3><p>互斥、<strong>占有并等待</strong>、非抢占、<strong>循环等待</strong></p><h3 id="死锁预防、避免、检测与解除"><a href="#死锁预防、避免、检测与解除" class="headerlink" title="死锁预防、避免、检测与解除"></a>死锁预防、避免、检测与解除</h3><h4 id="预防死锁的方法"><a href="#预防死锁的方法" class="headerlink" title="预防死锁的方法"></a>预防死锁的方法</h4><p>是通过考虑破坏第二个条件和第四个条件。</p><ol><li>静态分配策略:静态分配策略破坏死锁产生的第二个条件（占有并等待）。指一个进程必须在执行前就申请到它所需要的全部资源，并且知道它所要的资源都得到满足之后才开始执行。进程要么占有所有的资源然后开始执行，要么不占有资源。这种策略简单但效率低下</li><li>层次分配策略:破坏了产生死锁的第四个条件(循环等待)。所有的资源被分成了多个层次，一个进程得到某一次的一个资源后，它只能再申请较高一层的资源；当一个进程要释放某层的一个资源时，必须先释放所占用的较高层的资源，这样不会发生循环等待。</li></ol><p>常用的解除死锁的方法有以下四种：</p><ol><li>立即结束所有进程的执行，重新启动操作系统</li><li>撤销涉及死锁的所有进程，解除死锁后继续运行</li><li>逐个撤销涉及死锁的进程，回收其资源直至死锁解除。</li><li>抢占资源：从涉及死锁的一个或几个进程中抢占资源，把夺得的资源再分配给涉及死锁的进程直至死锁解除。</li></ol><h2 id="CPU-调度"><a href="#CPU-调度" class="headerlink" title="CPU 调度"></a>CPU 调度</h2><h3 id="几种常见的-CPU-调度算法"><a href="#几种常见的-CPU-调度算法" class="headerlink" title="几种常见的 CPU 调度算法"></a>几种常见的 CPU 调度算法</h3><ul><li>先到先服务调度(First-Come First-Served Scheduling，FCFS)</li><li>最短作业优先调度(Shortest Job First，SJF)</li><li>优先级调度（Priority Scheduling）</li><li>轮转法调度(Round Robin，RR)</li></ul><p>多级队列调度（Multilevel Queue） 就诞生了。简单来说就是把就绪队列（存放有待执行进程）分成多个独立队列，每个队列都有自己的调度算法。</p><h2 id="Linux相关（重要）"><a href="#Linux相关（重要）" class="headerlink" title="Linux相关（重要）"></a>Linux相关（重要）</h2><h3 id="Linux-常用命令"><a href="#Linux-常用命令" class="headerlink" title="Linux 常用命令"></a>Linux 常用命令</h3><p>1.cd 切换目录，2.mkdir创建目录,3.mv移动或重命名 ,4.cp复制, 5.touch 创建文件 7.find查找8.cat&#x2F;tail&#x2F;head&#x2F;less查看  9.ps-ef查看进程 10.ifconfig 查看ip地址 11.rm删除</p><ul><li><p>file:file通过探测文件内容判断文件类型，使用权限是所有用户</p></li><li><p>grep:grep命令可以指定文件中搜索特定内容，并将含有这些内容的行标准输出</p></li><li><p>tar：对文件进行打包，调用gzip或bzip对文件进行压缩或解压</p></li><li><p>查看进程：ps -ef|grep 进程id  【ps:将某个进程显示出来 -A 　显示所有程序。  -e 　此参数的效果和指定”A”参数相同。 -f 　显示UID,PPIP,C与STIME栏位。】</p></li><li><p>杀死叫firefox的进程：ps aux| grep firefox | awk ‘{print $2}’ |xargs kill  *</p></li></ul><p>xargs 命令是用来把前面命令的输出结果(PID)作为“kill -s 9”命令的参数，并执行该命令</p><p>$pkill -９ firefox *说明：pkill＝pgrep+kill，”-9” 即发送的信号是9，</p><p>pkill与kill在这点的差别是：pkill无须 “ｓ”，终止信号等级直接跟在 “-“ 后面</p><p>pgrep的p表明了这个命令是专门用于进程查询的grep</p><p>查看端口号: netstat –tunlp|grep 端口号或lsof -i:端口号</p><h3 id="如何查看Linux系统进程？"><a href="#如何查看Linux系统进程？" class="headerlink" title="如何查看Linux系统进程？"></a>如何查看Linux系统进程？</h3><p>通过ps命令可以查看当前系统运行的进程的列表，包括PID，进程名，CPU占用百分比，内存占用等信息。</p><p>可以使用top命令来查看Linux系统正在运行的进程。</p><h3 id="如何查看a-txt的第7到第9行？"><a href="#如何查看a-txt的第7到第9行？" class="headerlink" title="如何查看a.txt的第7到第9行？"></a>如何查看a.txt的第7到第9行？</h3><ul><li><p>cat a.txt | tail -n +7 | head -n 9</p></li><li><p>sed -n ‘7,9p’ a.txt</p></li></ul><h3 id="查看文件a-txt的前3行"><a href="#查看文件a-txt的前3行" class="headerlink" title="查看文件a.txt的前3行"></a>查看文件a.txt的前3行</h3><p>cat a.txt | head -n 3 或 head a.txt -n 3 (后3行用tail)</p><h3 id="查看文件a-txt，显示第50行到第200行"><a href="#查看文件a-txt，显示第50行到第200行" class="headerlink" title="查看文件a.txt，显示第50行到第200行"></a>查看文件a.txt，显示第50行到第200行</h3><pre><code>cat a.txt | head -n 200 | tail -n +50tail -n +50：从50行开始显示，显示50行以后的head -n 200：显示前面200行</code></pre><h3 id="查看a-txt文件的第5行"><a href="#查看a-txt文件的第5行" class="headerlink" title="查看a.txt文件的第5行"></a>查看a.txt文件的第5行</h3><pre><code>awk &#39;NR==5&#39; a.txthead -n 5 a.txt | tail -n 1sed -n 5p</code></pre><h3 id="一个文件中字段以逗号隔开，如何查看某一列的所有的数据？"><a href="#一个文件中字段以逗号隔开，如何查看某一列的所有的数据？" class="headerlink" title="一个文件中字段以逗号隔开，如何查看某一列的所有的数据？"></a>一个文件中字段以逗号隔开，如何查看某一列的所有的数据？</h3><pre><code>awk -F[,] &#39;&#123;print $10&#125;&#39;</code></pre><h3 id="如何查看程序运行时的某个端口？"><a href="#如何查看程序运行时的某个端口？" class="headerlink" title="如何查看程序运行时的某个端口？"></a>如何查看程序运行时的某个端口？</h3><pre><code>lsof -i :&lt;端口号&gt;</code></pre><h3 id="Linux-文件系统"><a href="#Linux-文件系统" class="headerlink" title="Linux 文件系统"></a>Linux 文件系统</h3><p>常见目录说明：</p><ul><li>&#x2F;bin： 存放二进制可执行文件(ls、cat、mkdir 等)，常用命令一般都在这里；</li><li>&#x2F;etc： 存放系统管理和配置文件；</li><li>&#x2F;home： 存放所有用户文件的根目录，是用户主目录的基点，比如用户 user 的主目录就是&#x2F;home&#x2F;user，可以用~user 表示；</li><li>&#x2F;usr： 用于存放系统应用程序；</li><li>&#x2F;opt： 额外安装的可选应用程序包所放置的位置。一般情况下，我们可以把 tomcat 等都安装到这里；</li><li>&#x2F;proc： 虚拟文件系统目录，是系统内存的映射。可直接访问这个目录来获取系统信息；</li><li>&#x2F;root： 超级用户（系统管理员）的主目录（特权阶级^o^）；</li><li>&#x2F;sbin: 存放二进制可执行文件，只有 root 才能访问。这里存放的是系统管理员使用的系统级别的管理命令和程序。如 ifconfig 等；</li><li>&#x2F;dev： 用于存放设备文件；</li><li>&#x2F;mnt： 系统管理员安装临时文件系统的安装点，系统提供这个目录是让用户临时挂载其他的文件系统；</li><li>&#x2F;boot： 存放用于系统引导时使用的各种文件；</li><li>&#x2F;lib 和&#x2F;lib64： 存放着和系统运行相关的库文件 ；</li><li>&#x2F;tmp： 用于存放各种临时文件，是公用的临时文件存储点；</li><li>&#x2F;var： 用于存放运行时需要改变数据的文件，也是某些大文件的溢出区，比方说各种服务的日志文件（系统启动日志等。）等；</li><li>&#x2F;lost+found： 这个目录平时是空的，系统非正常关机而留下“无家可归”的文件（windows 下叫什么.chk）就在这里。</li></ul><h3 id="僵尸进程和孤儿进程"><a href="#僵尸进程和孤儿进程" class="headerlink" title="僵尸进程和孤儿进程"></a>僵尸进程和孤儿进程</h3><ul><li><p>僵尸进程：子进程已经终止，担父进程仍然在运行，而且父进程没有调用wait或waitpid等系统调用来释放子进程占用的资源。这种情况下的子进程称为僵尸进程</p></li><li><p>孤儿进程：父进程没了，但是子进程仍然在运行</p></li></ul><p>Linux可以通过top指令来查看僵尸进程，zombie的值标识僵尸进程的数量</p><h2 id="如何从亿万个数据中找到前100个数"><a href="#如何从亿万个数据中找到前100个数" class="headerlink" title="如何从亿万个数据中找到前100个数"></a>如何从亿万个数据中找到前100个数</h2><p>采用分治法加堆排序</p><h2 id="什么时候用多线程，什么时候用单线程"><a href="#什么时候用多线程，什么时候用单线程" class="headerlink" title="什么时候用多线程，什么时候用单线程"></a>什么时候用多线程，什么时候用单线程</h2><p>单线程 ：</p><ol><li>程序简单，线性执行</li><li>避免多线程复杂性</li><li>任务不需要并发或并行处理</li><li>系统资源有限</li><li>出于开发成本考虑，单线程更加简单、易维护</li></ol><p>多线程：</p><ol><li>任务可并发</li><li>io密集型任务，因为这些任务往往是阻塞的</li><li>cpu密集型任务</li><li>提升程序响应速度：例如主线程复制用户交互，令一个线程负责处理数据计算</li><li>服务器需要同时处理多个客户端请求</li></ol><h2 id="内存分配方式"><a href="#内存分配方式" class="headerlink" title="内存分配方式"></a>内存分配方式</h2><ul><li>连续内存分配:块状管理</li><li>非连续内存分配：分段、分页、段页式(先分段，再分页)</li></ul><h2 id="分段和分页的区别"><a href="#分段和分页的区别" class="headerlink" title="分段和分页的区别"></a>分段和分页的区别</h2><p>分段：</p><ul><li>用一段段不同长度的连续的物理内存分配物理内存</li><li>通过段表映射虚拟地址和物理地址</li></ul><p>分页：</p><ul><li>把物理内存分为<strong>连续等长</strong>的物理页</li><li>用页表映射虚拟地址和物理地址</li></ul><p>区别：</p><ul><li>页的大小固定、段的大小不固定</li><li>分段容易出现外部内存碎片、分页解决了外部内存碎片</li><li>分页机制采用了页表来完成虚拟地址到物理地址的映射，页表通过一级页表和二级页表来实现多级映射；而分段机制则采用了段表来完成虚拟地址到物理地址的映射，每个段表项中记录了该段的起始地址和长度信息。</li><li>分页机制对程序没有任何要求，分段机制需要程序员将程序分为多个段</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;a href=&quot;https://mubu.com/app/edit/home/5Vbsc1GjSNm&quot;&gt;八股-操作系统&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;内核态和用户态和系统调用&quot;&gt;&lt;a href=&quot;#内核态和用户态和系统调用&quot; class=&quot;headerlink&quot; tit</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>八股文骚套路之数据结构</title>
    <link href="http://www.meprotoss.com/undefined/faaf69f9.html"/>
    <id>http://www.meprotoss.com/undefined/faaf69f9.html</id>
    <published>2024-06-09T08:40:58.000Z</published>
    <updated>2024-10-15T14:12:57.537Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://mubu.com/app/edit/home/1cv82aWbhSC">八股数据结构</a></p><h2 id="b树和b-树的区别"><a href="#b树和b-树的区别" class="headerlink" title="b树和b+树的区别"></a>b树和b+树的区别</h2><ul><li>存储方式: 节点存什么东西？（数据 索引）</li><li>节点指针: B树中的节点包含指向子节点的指针，而B+树中的内部节点只包含键值和指向下一级节点的指针 <strong>不包含指向具体数据的指针</strong>。所有的数据都存储在叶子节点中，通过叶子节点的链表顺序访问数据。</li><li>范围查询: 由于B+树的叶子节点形成了有序链表，所以在B+树上进行范围查询非常高效，只需要遍历叶子节点的链表即可</li><li>使用场景: b树节点包含数据，适用于随机访问；b+树叶子节点形成有序链表，适用于顺序访问和范围查询</li></ul><h2 id="图的遍历方式有哪些，生活中有什么应用？"><a href="#图的遍历方式有哪些，生活中有什么应用？" class="headerlink" title="图的遍历方式有哪些，生活中有什么应用？"></a>图的遍历方式有哪些，生活中有什么应用？</h2><ol><li>深度优先dfs：可以用来寻找所有可能的路径（递归、回溯）</li><li>广度优先bfs:用来寻找最短路径</li></ol><p>图的遍历还可应用与网页之间的跳转，建立网络之间的链接关系</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;a href=&quot;https://mubu.com/app/edit/home/1cv82aWbhSC&quot;&gt;八股数据结构&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;b树和b-树的区别&quot;&gt;&lt;a href=&quot;#b树和b-树的区别&quot; class=&quot;headerlink&quot; title=&quot;b树和</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>八股文骚套路之计算机网络</title>
    <link href="http://www.meprotoss.com/undefined/101a7be.html"/>
    <id>http://www.meprotoss.com/undefined/101a7be.html</id>
    <published>2024-06-09T08:34:15.000Z</published>
    <updated>2024-10-16T03:30:43.887Z</updated>
    
    <content type="html"><![CDATA[<p>面试过程中偏向与应用，所以问的比较多的也就是应用层、运输层、网络层的协议，物理层和数据链路层的东西面试基本不会被问到，所以准备面试过程中这块就不用看了。<br><a href="https://mubu.com/app/edit/home/4IsX074ceSC">八股-网络协议</a></p><h2 id="OSI七层模型"><a href="#OSI七层模型" class="headerlink" title="OSI七层模型"></a>OSI七层模型</h2><p>物理层 数据链路层 网络层 传输层 会话层 表示层 应用层</p><p>物理层 数据链路层 网络层 传输层 应用层</p><h2 id="在搜索框输入www-baidu-com，发生了什么？"><a href="#在搜索框输入www-baidu-com，发生了什么？" class="headerlink" title="在搜索框输入www.baidu.com，发生了什么？"></a>在搜索框输入<a href="http://www.baidu.com，发生了什么？">www.baidu.com，发生了什么？</a></h2><ol><li>在浏览器中输入指定网页的 URL。</li><li>浏览器通过 <strong>DNS</strong>协议，获取域名对应的 IP 地址。</li><li>浏览器根据 IP 地址和端口号，向目标服务器发起一个 TCP 连接请求。</li><li>TCP连接建立之后，浏览器在 TCP 连接上，向服务器发送一个 HTTP 请求报文，请求获取网页的内容。</li><li>服务器收到 HTTP 请求报文后，处理请求，并返回 HTTP 响应报文给浏览器。</li><li>浏览器收到 HTTP 响应报文后，解析响应体中的 HTML 代码，渲染网页的结构和样式，同时根据 HTML 中的其他资源的 URL（如图片、CSS、JS 等），再次发起 HTTP 请求，获取这些资源的内容，直到网页完全加载显示。</li><li>浏览器在不需要和服务器通信时，可以主动关闭 TCP 连接，或者等待服务器的关闭请求。</li></ol><h2 id="http-和-https-的区别"><a href="#http-和-https-的区别" class="headerlink" title="http 和 https 的区别"></a>http 和 https 的区别</h2><h3 id="http"><a href="#http" class="headerlink" title="http"></a>http</h3><ul><li>超文本传输协议</li><li>明文传输</li><li>基于请求和响应</li><li>无状态</li><li>应用层协议</li><li>端口80</li></ul><h3 id="https"><a href="#https" class="headerlink" title="https"></a>https</h3><ul><li>http + ssl&#x2F;tls</li><li>具有加密性质的SSL加密传输协议</li><li>由http通信</li><li>利用ssl&#x2F;tls建立信道</li><li>端口443</li><li>需要证书</li></ul><h2 id="详细介绍一下ssl-TLS"><a href="#详细介绍一下ssl-TLS" class="headerlink" title="详细介绍一下ssl&#x2F;TLS"></a>详细介绍一下ssl&#x2F;TLS</h2><p>运行在TCP上，加密采用对称加密</p><h3 id="什么是对称加密"><a href="#什么是对称加密" class="headerlink" title="什么是对称加密"></a>什么是对称加密</h3><p>通信双方共享唯一密钥K 加解密算法已知 相比非对称加密 代价小 但是安全性较低</p><h2 id="http-请求报文"><a href="#http-请求报文" class="headerlink" title="http 请求报文"></a>http 请求报文</h2><ul><li>请求方法</li><li>GET: 请求<strong>获取</strong>request——URL所标识的资源</li><li>POST：在Request——URL所标识的资源后附加资源(向指定的资源<strong>提交</strong>要被处理的数据)</li><li>HEAD：请求获取由Request——URL所标识的资源的响应消息报头</li><li>PUT：请求服务器存储一个资源，由Request——URL作为其标识  </li><li>DELETE：请求服务器删除由Request——URL所标识的资源</li><li>TRACE：请求服务器回送收到的请求信息（用于测试和诊断）</li><li>CONNECT：保留</li><li>OPTIONS：请求查询服务器性能</li></ul><h2 id="http-状态码"><a href="#http-状态码" class="headerlink" title="http 状态码"></a>http 状态码</h2><p>状态码是用于表示网页服务器HTTP响应状态的3位数字代码</p><p>1xx:请求被成功接收<br>2xx:请求被成功处理<br>3xx:重定向相关<br>4xx:客户端错误<br>5xx:服务器端错误</p><h2 id="TCP-和-UDP-的区别"><a href="#TCP-和-UDP-的区别" class="headerlink" title="TCP 和 UDP 的区别"></a>TCP 和 UDP 的区别</h2><ul><li>面向连接:传输数据之前是否要建立连接</li><li>可靠传输:收到报文之后是否需要确认，是否需要保证数据的不丢失和顺序到达</li><li>是否有状态:是否记录自己发送的消息被接受了等等</li><li>传输效率:</li><li>传输形式:tcp面向<strong>字节流</strong>，udp<strong>面向报文</strong></li><li>首部开销:</li><li>广播或多播:tcp只支持点对点，udp支持一对一、一对多、多对一</li></ul><h2 id="tcp为什么可靠"><a href="#tcp为什么可靠" class="headerlink" title="tcp为什么可靠"></a>tcp为什么可靠</h2><ul><li>确认和重传机制:建立连接时三次握手同步双方的“序列号 + 确认号 + 窗口大小信息”，是确认重传、流控的基础</li><li>数据排序:TCP有专门的序列号SN字段，可提供数据re-order</li><li>流量控制:滑动窗口和计时器的使用。TCP窗口中会指明双方能够发送接收的最大数据量，发送方通过维持一个发送滑动窗口来确保不会发生由于发送方报文发送太快接收方无法及时处理的问题。</li><li>拥塞控制:TCP的拥塞控制由4个核心算法组成:“慢启动” “拥塞避免”  “快速重传 ”  “快速恢复”</li></ul><h2 id="TCP流量控制"><a href="#TCP流量控制" class="headerlink" title="TCP流量控制"></a>TCP流量控制</h2><ul><li>TCP发送方维护一个拥塞窗口，可以随网络动态变化，发送窗口取拥塞窗口和接收方接受窗口中较小的</li></ul><p>采用了4种算法：<br>1.慢开始:设置拥塞窗口一开始为1，每过一个传播轮次，窗口加倍<br>2.拥塞避免:到达阈值之后每次窗口+1<br>3.快重传和快恢复:接收方接受到一个错误的数据段会向发送方发送一个重复确认，收到3个重复确认之后，发送方立即重传丢失的数据段。</p><h2 id="cookie-和-session-的区别"><a href="#cookie-和-session-的区别" class="headerlink" title="cookie 和 session 的区别"></a>cookie 和 session 的区别</h2><ul><li>cookie和session都是会话技术，cookie是运行在客户端，session是运行在服务器端</li><li>cookie有安全隐患，通过拦截或本地文件找得到你的cookie后可以进行攻击</li><li>session是保存在服务器端上会存在一段时间后消失，如果session过多会增加服务器的压力</li></ul><h2 id="IP-地址和-Mac-地址的区别，了解-ARP-地址解析协议并了解其工作原理"><a href="#IP-地址和-Mac-地址的区别，了解-ARP-地址解析协议并了解其工作原理" class="headerlink" title="IP 地址和 Mac 地址的区别，了解 ARP 地址解析协议并了解其工作原理"></a>IP 地址和 Mac 地址的区别，了解 ARP 地址解析协议并了解其工作原理</h2><p>互联网中的每一个资源都有一个ip地址，而一切网络设备都有一个唯一mac地址 ,ip地址是一种不重复的定位方式</p><p>mac地址是永久的，而ip可能会随着网络的更换而变化</p><p>arp(address resolution protocol)地址解析协议。解决了ip地址转mac地址的问题</p><h2 id="建立连接TCP三次握手和断开连接TCP四次挥手"><a href="#建立连接TCP三次握手和断开连接TCP四次挥手" class="headerlink" title="建立连接TCP三次握手和断开连接TCP四次挥手"></a>建立连接TCP三次握手和断开连接TCP四次挥手</h2><h3 id="三次握手"><a href="#三次握手" class="headerlink" title="三次握手"></a>三次握手</h3><p>第一次握手<br>    建立连接时，客户端发送syn包（syn&#x3D;j）到服务器，并进入SYN_SENT状态，等待服务器确认。SYN：同步序列编号(客户端发送同步请求等待服务器确认)<br>第二次握手<br>    服务器收到SYN包，必须确认客户的SYN(ack&#x3D;j+1),同时自己也发送一个SYN包(syn&#x3D;k)，即SYN+ACK包，此时服务器进入SYN_RECV状态(服务器收到请求同意建立连接，告诉客户端自己同意)<br>第三次握手<br>    客户端收到服务器的SYN+ACK包，向服务器发送确认包ACK(ACK&#x3D;K+1)，此包发送完毕，客户端和服务器进入ESTABLISHED（TCP连接成功）状态(客户端告诉服务端自己知道你同意了于是开启了连接，)</p><h3 id="为什么要三次握手"><a href="#为什么要三次握手" class="headerlink" title="为什么要三次握手?"></a>为什么要三次握手?</h3><p>主要就是用来确认自己和对方的接受和发送都正常</p><ol><li>第一次握手：Client 什么都不能确认；Server 确认了对方发送正常，自己接收正常</li><li>第二次握手：Client 确认了：自己发送、接收正常，对方发送、接收正常；Server 确认了：对方发送正常，自己接收正常</li><li>第三次握手：Client 确认了：自己发送、接收正常，对方发送、接收正常；Server 确认了：自己发送、接收正常，对方发送、接收正常</li></ol><h3 id="四次挥手"><a href="#四次挥手" class="headerlink" title="四次挥手"></a>四次挥手</h3><p>断开一个 TCP 连接则需要“四次挥手”，缺一不可：</p><p>第一次挥手：客户端发送一个 FIN（SEQ&#x3D;x） 标志的数据包-&gt;服务端，用来关闭客户端到服务端的<strong>数据传送</strong>。然后客户端进入 FIN-WAIT-1 状态。<br>第二次挥手：服务端收到这个 FIN（SEQ&#x3D;X） 标志的数据包，它发送一个 ACK （ACK&#x3D;x+1）标志的数据包-&gt;客户端 。然后服务端进入 CLOSE-WAIT 状态，客户端进入 FIN-WAIT-2 状态。<br>第三次挥手：服务端发送一个 FIN (SEQ&#x3D;y)标志的数据包-&gt;客户端，请求关闭连接，然后服务端进入 LAST-ACK 状态。<br>第四次挥手：客户端发送 ACK (ACK&#x3D;y+1)标志的数据包-&gt;服务端，然后客户端进入TIME-WAIT状态，服务端在收到 ACK (ACK&#x3D;y+1)标志的数据包后进入 CLOSE 状态。此时如果客户端等待 2MSL 后依然没有收到回复，就证明服务端已正常关闭，随后客户端也可以关闭连接了</p><p>第一次挥手：A 说“我没啥要说的了”<br>第二次挥手：B 回答“我知道了”，但是 B 可能还会有要说的话，A 不能要求 B 跟着自己的节奏结束通话<br>第三次挥手：于是 B 可能又巴拉巴拉说了一通，最后 B 说“我说完了”<br>第四次挥手：A 回答“知道了”，这样通话才算结束。</p><h2 id="DNS域名系统"><a href="#DNS域名系统" class="headerlink" title="DNS域名系统"></a>DNS域名系统</h2><p>DNS 要解决的是域名和 IP 地址的映射问题。</p><p>DNS域名服务器分为四种：本地、权威、顶级、根</p><p>DNS有两种查询解析方法：迭达和递归</p><p>常用的方法是从请求主机到本地 DNS 服务器的查询是递归的，其余的查询时迭代的。</p><h2 id="UDP如何实现可靠传输"><a href="#UDP如何实现可靠传输" class="headerlink" title="UDP如何实现可靠传输"></a>UDP如何实现可靠传输</h2><p>UDP实现可靠传输,其实是借鉴TCP可靠传输的策略</p><h3 id="常见的可靠传输策略"><a href="#常见的可靠传输策略" class="headerlink" title="常见的可靠传输策略"></a>常见的可靠传输策略</h3><ol><li>ACK机制</li><li>重传机制</li><li>序号机制</li><li>重排机制</li><li>窗口机制</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;面试过程中偏向与应用，所以问的比较多的也就是应用层、运输层、网络层的协议，物理层和数据链路层的东西面试基本不会被问到，所以准备面试过程中这块就不用看了。&lt;br&gt;&lt;a href=&quot;https://mubu.com/app/edit/home/4IsX074ceSC&quot;&gt;八股-网</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>八股文骚套路之JVM</title>
    <link href="http://www.meprotoss.com/undefined/3fe50e69.html"/>
    <id>http://www.meprotoss.com/undefined/3fe50e69.html</id>
    <published>2024-06-08T08:17:53.000Z</published>
    <updated>2024-10-15T07:37:32.147Z</updated>
    
    <content type="html"><![CDATA[<h2 id="运行时数据区中包含哪些区域？哪些线程共享？哪些线程独享？【⭐⭐⭐⭐⭐】"><a href="#运行时数据区中包含哪些区域？哪些线程共享？哪些线程独享？【⭐⭐⭐⭐⭐】" class="headerlink" title="运行时数据区中包含哪些区域？哪些线程共享？哪些线程独享？【⭐⭐⭐⭐⭐】"></a>运行时数据区中包含哪些区域？哪些线程共享？哪些线程独享？【⭐⭐⭐⭐⭐】</h2><p>JDK1.7之前的运行时数据区包括 堆、方法区、虚拟机栈、本地方法栈、程序计数器<br>其中堆和方法区是线程共享的；虚拟机栈、本地方法栈和程序计数器是线程私有的。<br>Jdk1.8之后 方法区的实现变成了元空间，和运行时常量池一起被放到了本地内存</p><h3 id="程序计数器"><a href="#程序计数器" class="headerlink" title="程序计数器"></a>程序计数器</h3><p>可以看作当前线程所执行的<strong>字节码文件的行号指示器</strong>，实现代码的流程控制，还需要能让线程切换之后能恢复到正确的执行位置，自然是线程私有的</p><h3 id="虚拟机栈"><a href="#虚拟机栈" class="headerlink" title="虚拟机栈"></a>虚拟机栈</h3><p>除了一些本地方法是在本地方法栈中实现，其他所有java方法的调用都通过虚拟机栈实现的。<br>栈由一个个栈帧组成，每一个方法调用的时候都会有一个栈帧被压入虚拟机栈中，每个栈帧中都保存着局部变量表、操作数栈、动态链接和方法的返回地址。</p><h4 id="局部变量表"><a href="#局部变量表" class="headerlink" title="局部变量表"></a>局部变量表</h4><p>主要存储编译期间的基本数据类型和对象引用(是指向对象起始地址的引用指针)</p><h4 id="操作数栈"><a href="#操作数栈" class="headerlink" title="操作数栈"></a>操作数栈</h4><p>放方法执行过程中产生的<strong>中间计算结果</strong>。</p><h4 id="动态链接"><a href="#动态链接" class="headerlink" title="动态链接"></a>动态链接</h4><p>主要用于<strong>一个方法需要调用其余方法的场景</strong>，当一个方法要去调用其他方法，就需要把常量池里指向方法的符号引用转化为内存地址中的直接引用。</p><h3 id="本地方法栈"><a href="#本地方法栈" class="headerlink" title="本地方法栈"></a>本地方法栈</h3><p>和虚拟机栈类似，只是里面存的是Native方法</p><h3 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h3><p>用来<strong>存放对象实例</strong>，几乎所有的对象实例和数组都在这里分配内存</p><h2 id="说一下方法区和永久代的关系"><a href="#说一下方法区和永久代的关系" class="headerlink" title="说一下方法区和永久代的关系"></a>说一下方法区和永久代的关系</h2><p>方法区是JVM运行时的数据区域的一块逻辑区域，是<strong>各个线程共享的内存区域</strong>，它是一个逻辑概念，定义规则。</p><p>而永久代则是方法区的一个具体实现方式，Jdk1.8之后方法区的实现变成了元空间，被放到了本地内存里</p><h3 id="Java-创建一个对象的过程。【⭐⭐⭐⭐】"><a href="#Java-创建一个对象的过程。【⭐⭐⭐⭐】" class="headerlink" title="Java 创建一个对象的过程。【⭐⭐⭐⭐】"></a>Java 创建一个对象的过程。【⭐⭐⭐⭐】</h3><p>类加载检查：首先，再Java中使用new关键字创建对象的时候，<strong>首先加载对象的类</strong>。如果类未被加载，那么JVM会使用类加载器(这里有一个双亲委派机制)加载并初始化该类</p><ul><li><p>分配内存空间:类加载完成之后，JVM会<strong>在堆中为对象分配内存空间</strong>。分配内存的方式有指针碰撞和空闲列表两种，选择哪种分配方式取决于Java堆内存是否规整。</p></li><li><p>连接：JVM会把对象里的普通成员变量初始化为0值。这一步操作主要是保证对象里面的实例字段不用初始化就可以直接使用。</p></li><li><p>设置对象头：为对象添加首部属性信息，比如对象所属的类元信息、对象的GC分代年龄、hashCode、锁标记等。</p></li><li><p>执行<init>方法：调用对象的构造函数，对对象的属性进行赋值 和 其他初始化操作</p></li><li><p>最后，JVM会返回对象的引用</p></li></ul><h2 id="对象的访问定位的两种方式【⭐⭐⭐⭐⭐】"><a href="#对象的访问定位的两种方式【⭐⭐⭐⭐⭐】" class="headerlink" title="对象的访问定位的两种方式【⭐⭐⭐⭐⭐】"></a>对象的访问定位的两种方式【⭐⭐⭐⭐⭐】</h2><p>一般有两种方式:</p><ol><li>句柄(堆中划分出一个句柄池，栈中的引用指向句柄地址，然后句柄中包含了对象的实例数据和类型数据的地址)</li><li>直接指针(栈中的引用直接指向实例数据的地址，如果访问对象本身的话，就不用多一次访问开销，而对象的类型数据的指针存放在方法区中，如果定位的话，需要多一次直接定位开销)</li></ol><p>使用句柄最大的好处就是引用中存储的是句柄地址，对象移动时只需改变句柄的地址就可以，而无需改变对象本身。</p><p>使用直接指针来访问速度更快，它节省了一次指针定位的时间开销，因为对象访问在 Java 中非常频繁。</p><h2 id="你了解分代理论吗？讲一下-Minor-GC、还有-Full-GC-⭐⭐⭐⭐⭐-讲一下java的垃圾回收机制？"><a href="#你了解分代理论吗？讲一下-Minor-GC、还有-Full-GC-⭐⭐⭐⭐⭐-讲一下java的垃圾回收机制？" class="headerlink" title="你了解分代理论吗？讲一下 Minor GC、还有 Full GC ⭐⭐⭐⭐⭐ &#x2F; 讲一下java的垃圾回收机制？"></a>你了解分代理论吗？讲一下 Minor GC、还有 Full GC ⭐⭐⭐⭐⭐ &#x2F; 讲一下java的垃圾回收机制？</h2><p>垃圾回收机制是Java语言自动内存管理的一个特性，不需要像C++那样手动释放对象占用的内存空间。</p><p>在Jdk1.7之前 堆内存通常分为 新生代 老年代 和永久代，Jdk8之后永久代被元空间取代，元空间使用的是直接内存</p><p>大多数情况下，对象优先在新生代中的eden区中分配(大对象直接进入老年代)，当eden区空间不足的时候，JVM会进行一次minorGC,经过一次minorGC的对象会被分配到survivor区，如果survivor区放不下，那么会通过分配担保机制提前移动到老年代去，如果仍能存活且能被survivor容纳的话，会被移动到survivor空间。且年龄+1<br>当年龄增加到阈值的时候，就会晋升到老年代中。</p><p>minorGC是partialGC 的一种，只对新生代进行垃圾收集</p><h2 id="Java-用什么方法确定哪些对象该被清理-如何判断一个对象已经死亡？-讲一下可达性分析算法的流程。【⭐⭐⭐⭐】"><a href="#Java-用什么方法确定哪些对象该被清理-如何判断一个对象已经死亡？-讲一下可达性分析算法的流程。【⭐⭐⭐⭐】" class="headerlink" title="Java 用什么方法确定哪些对象该被清理&#x2F;如何判断一个对象已经死亡？ 讲一下可达性分析算法的流程。【⭐⭐⭐⭐】"></a>Java 用什么方法确定哪些对象该被清理&#x2F;如何判断一个对象已经死亡？ 讲一下可达性分析算法的流程。【⭐⭐⭐⭐】</h2><p>简单来说就是当对象不再被引用的时候宣判对象已经死亡</p><ul><li>引用计数法<br>给对象添加一个引用计数器，每当有一个地方引用，计数器就+1；当引用失效，计数器就-1；引用计数器为0的对象就是不可能再被使用的</li></ul><p>但是这个方法没法解决对象间的循环引用问题</p><ul><li>可达性分析算法</li></ul><p>通过一系列的称为 “GC Roots” 的对象作为起点，从这些节点开始向下搜索，节点所走过的路径称为引用链，当一个对象到 GC Roots 没有任何引用链相连的话，则证明此对象是不可用的，需要被回收。</p><h2 id="JDK-中有几种引用类型？分别的特点是什么？【⭐⭐】"><a href="#JDK-中有几种引用类型？分别的特点是什么？【⭐⭐】" class="headerlink" title="JDK 中有几种引用类型？分别的特点是什么？【⭐⭐】"></a>JDK 中有几种引用类型？分别的特点是什么？【⭐⭐】</h2><ol><li><p>强引用<br>表示必不可少。垃圾回收器绝不会回收它。当内存空间不足，Java 虚拟机宁愿抛出 OutOfMemoryError 错误，使程序异常终止，也不会靠随意回收具有强引用的对象来解决内存不足问题。</p></li><li><p>软引用（SoftReference）<br>表示可有可无。如果内存空间足够，垃圾回收器就不会回收它，如果内存空间不足了，就会回收这些对象的内存。</p></li><li><p>弱引用（WeakReference）<br>表示可有可无。弱引用与软引用的区别在于：弱引用的生命周期更短，在垃圾回收器线程扫描它所管辖的内存区域的过程中，一旦发现了只具有弱引用的对象，不管当前内存空间足够与否，都会回收它的内存。</p></li><li><p>虚引用<br>表示形同虚设，任何时候都可能被垃圾回收</p></li></ol><h2 id="如何回收方法区？【⭐⭐⭐】"><a href="#如何回收方法区？【⭐⭐⭐】" class="headerlink" title="如何回收方法区？【⭐⭐⭐】"></a>如何回收方法区？【⭐⭐⭐】</h2><p>主要有两种方法：</p><ol><li>类卸载：当一个类不再被引用，即没有任何对象实例引用该类，且该类的类加载器已经被回收时，JVM 可以卸载这个类。类卸载会导致该类在方法区中所占用的内存被释放，从而实现方法区的回收。</li><li>常量池回收：在方法区中的运行时常量池中存储着类信息、常量、静态变量等数据。常量池的大小是有限的，当常量池用尽时，JVM 会对常量池进行回收。常量池回收通常是通过 Full GC（Full Garbage Collection）来实现的。</li></ol><h2 id="标记清除、标记复制、标记整理分别是怎样清理垃圾的？各有什么优缺点？【⭐⭐⭐⭐⭐】"><a href="#标记清除、标记复制、标记整理分别是怎样清理垃圾的？各有什么优缺点？【⭐⭐⭐⭐⭐】" class="headerlink" title="标记清除、标记复制、标记整理分别是怎样清理垃圾的？各有什么优缺点？【⭐⭐⭐⭐⭐】"></a>标记清除、标记复制、标记整理分别是怎样清理垃圾的？各有什么优缺点？【⭐⭐⭐⭐⭐】</h2><ol><li><p>标记清除<br>首先<strong>标记出所有不需要回收</strong>的对象，标记完之后回收所有没有标记的对象<br>优点是简单，缺点是效率不高，容易产生大量不连续的内存碎片</p></li><li><p>标记复制<br><strong>将内存分为大小相同的两块，每次使用其中的一块</strong>，当内存使用完之后，<strong>把还存活的对象复制到另外一块，然后再把前面的空间一次性清理掉</strong><br>优点是解决了内存碎片问题<br>缺点是可用内存变小，而且如果存活的对象表较大，复制的效率也会很低所以不适合老年代</p></li><li><p>标记整理算法<br>标记所有不需要回收的对象，然后<strong>让所有存活的对象向一端移动</strong>，然后直接清理掉端边界外的内存<br>优点是减少了内存碎片，缺点是多了整理的这一步，效率不高</p></li><li><p>分代收集算法<br>根据新生代和老年代的特点，选择上述三个中适合的垃圾收集算法</p></li></ol><blockquote><p>[!TIP]<br>标记都是标记出不需要被回收的对象</p></blockquote><h2 id="JVM-中的安全点和安全区各代表什么？写屏障你了解吗？【⭐⭐⭐⭐】"><a href="#JVM-中的安全点和安全区各代表什么？写屏障你了解吗？【⭐⭐⭐⭐】" class="headerlink" title="JVM 中的安全点和安全区各代表什么？写屏障你了解吗？【⭐⭐⭐⭐】"></a>JVM 中的安全点和安全区各代表什么？写屏障你了解吗？【⭐⭐⭐⭐】</h2><p>在执行GC的时候，所有的工作线程都必须停顿，安全点就代表<strong>在这个时间节点</strong>，所有线程的工作状态是确定的，JVM可以安全的执行GC</p><p>安全点是对正在执行的线程设定的。如果一个线程处于 Sleep 或中断状态，它就不能响应 JVM 的中断请求，再运行到 Safe Point 上。</p><p>安全区是指在一段代码片段中，引用关系不会发生变化。在这个区域内的任意地方开始 GC 都是安全的。</p><h2 id="TODO-并发标记要解决什么问题？并发标记带来了什么问题？如何解决并发扫描时对象消失问题？⭐⭐⭐⭐"><a href="#TODO-并发标记要解决什么问题？并发标记带来了什么问题？如何解决并发扫描时对象消失问题？⭐⭐⭐⭐" class="headerlink" title="TODO:并发标记要解决什么问题？并发标记带来了什么问题？如何解决并发扫描时对象消失问题？⭐⭐⭐⭐"></a>TODO:并发标记要解决什么问题？并发标记带来了什么问题？如何解决并发扫描时对象消失问题？⭐⭐⭐⭐</h2><h2 id="新生代垃圾收集器有哪些？老年代垃圾收集器有哪些？哪些是单线程垃圾收集器，哪些是多线程垃圾收集器？各有什么特点？各基于哪一种垃圾收集算法？【⭐⭐⭐⭐】"><a href="#新生代垃圾收集器有哪些？老年代垃圾收集器有哪些？哪些是单线程垃圾收集器，哪些是多线程垃圾收集器？各有什么特点？各基于哪一种垃圾收集算法？【⭐⭐⭐⭐】" class="headerlink" title="新生代垃圾收集器有哪些？老年代垃圾收集器有哪些？哪些是单线程垃圾收集器，哪些是多线程垃圾收集器？各有什么特点？各基于哪一种垃圾收集算法？【⭐⭐⭐⭐】"></a>新生代垃圾收集器有哪些？老年代垃圾收集器有哪些？哪些是单线程垃圾收集器，哪些是多线程垃圾收集器？各有什么特点？各基于哪一种垃圾收集算法？【⭐⭐⭐⭐】</h2><p>如果说收集算法是内存回收的方法论，那么垃圾收集器就是内存回收的具体实现。</p><ol><li><p>Serial 串行收集器是单线程的垃圾收集器，<strong>新生代采用标记复制算法</strong> <strong>老年代采用标记整理算法</strong> 缺点是执行GC的时候需要stop the world 优点是简单高效</p></li><li><p>ParNew 收集器是<strong>Serial收集器的多线程版本</strong> 新生代采用标记-复制算法，老年代采用标记-整理算法。</p></li><li><p>Parallel Scavenge 收集器也是用标记-复制算法的垃多线程收集器，它更加关注如何提高吞吐量 <strong>新生代采用标记-复制算法</strong>，老年代采用<strong>标记-整理算法</strong>。</p></li><li><p>Serial Old 收集器，是serial收集器的老年版本,是单线程的 与 Parallel Scavenge 收集器搭配使用</p></li><li><p>Parallel Old 收集器 是Parallel Scavenge 收集器的老年代版本，使用多线程和“标记整理”算法，在注重吞吐量以及 CPU 资源的场合，都可以优先考虑 Parallel Scavenge 收集器和 Parallel Old 收集器。</p></li><li><p>CMS(Concurrent Mark Sweep 并发标记清除) 并发收集器，可以让用户进程和垃圾回收同时进行 ，基于标记清除算法</p></li></ol><p>有4个步骤：</p><ul><li>初始标记：暂停所有其他线程，并记录下与root相连的对象</li><li>并发标记：同时开启GC和用户线程，用一个闭包结构去记录可达对象，用这个算法去跟踪记录用户进的执行导致可达对象更新的地方</li><li>重新标记：把并发标记期间用户程序继续运行导致的标记变动的那一部分对象进行标记和记录</li><li>并发清除：开启用户线程，同时 GC 线程开始对未标记的区域做清扫。<br>优点：并发收集，停顿少，用户体验好<br>缺点：对CPU的压力比较大；无法处理浮动垃圾；基于标记清楚算法会产生大量的内存碎片</li></ul><ol start="7"><li><strong>G1 (Garbage-First) 面向服务器的垃圾收集器</strong>，内存得大，cpu性能牛逼 也是默认的垃圾收集器，G1 收集器的运作大致分为以下几个步骤：</li></ol><ul><li>初始标记</li><li>并发标记</li><li>最终标记</li><li>筛选回收<br>特点：</li><li>充分利用并行和并发，既可以使用多个cpu来缩短stop the world 的时间，又可以通过并发使得Java程序在gc期间继续执行</li><li>分代收集</li><li>空间整合 整体上是基于标记整理算法，但是局部上基于标记复制算法</li><li>可以预测停顿的时间</li></ul><h2 id="讲一下内存分配策略？【⭐⭐⭐⭐】"><a href="#讲一下内存分配策略？【⭐⭐⭐⭐】" class="headerlink" title="讲一下内存分配策略？【⭐⭐⭐⭐】"></a>讲一下内存分配策略？【⭐⭐⭐⭐】</h2><p>常见的内存分配策略有两种<br>第一种：对象优先在Eden区进行分配，当Eden区满了之后，进行一次minorGC(新生代垃圾回收)，仍然存活的对象被移动到survivor区或老年代<br>第二种：如果对象大小超过了一定的阈值，那么JVM会自动将其分配到老年代，因为大对象往往拥有较长的生命周期，直接分配到老年代可以减少在新生代的复制操作<br>第三种：长期存活的对象进入老年代，JVM给每个对象一个年龄计数器，在eden区的对象经过一次minorGC之后如果仍然存活会被移动到survivor区，且年龄+1；后续在survivor区每经历一次minorGC，年龄就+1，直到达到阈值默认为15，就会被移动到老年代。<br>第四种：动态对象年龄判定，如果survivor区中相同年龄的对象的总内存超过survivor空间一半，年龄大于等于这个年龄的对象可直接进入老年代。</p><h3 id="空间分配担保机制"><a href="#空间分配担保机制" class="headerlink" title="空间分配担保机制"></a>空间分配担保机制</h3><p>minorGC之前，需要检查老年代可用空间是否足够容纳新生代所有对象。如果够的话说明minorGC是安全的。</p><h2 id="什么是字节码？类文件结构的组成了解吗？【⭐⭐⭐⭐】"><a href="#什么是字节码？类文件结构的组成了解吗？【⭐⭐⭐⭐】" class="headerlink" title="什么是字节码？类文件结构的组成了解吗？【⭐⭐⭐⭐】"></a>什么是字节码？类文件结构的组成了解吗？【⭐⭐⭐⭐】</h2><p>JVM可以理解的代码称为字节码</p><p>类文件结构有魔数、class文件版本号、常量池、访问标识、当前类、父类、字段表、方法表、属性表</p><h2 id="类的生命周期？类加载的过程了解么？加载这一步主要做了什么事情？初始化阶段中哪几种情况必须对类初始化？【⭐⭐⭐⭐⭐】"><a href="#类的生命周期？类加载的过程了解么？加载这一步主要做了什么事情？初始化阶段中哪几种情况必须对类初始化？【⭐⭐⭐⭐⭐】" class="headerlink" title="类的生命周期？类加载的过程了解么？加载这一步主要做了什么事情？初始化阶段中哪几种情况必须对类初始化？【⭐⭐⭐⭐⭐】"></a>类的生命周期？类加载的过程了解么？加载这一步主要做了什么事情？初始化阶段中哪几种情况必须对类初始化？【⭐⭐⭐⭐⭐】</h2><p>类从被加载到JVM内存开始到卸载出内存，生命周期主要有7个阶段：加载、验证、准备、解析、初始化、使用、卸载，其中验证、准备和解析三个阶段统称为连接</p><p>系统加载类文件主要有三步：加载 连接和初始化</p><p>加载这一步首先是通过全类名获取定义此类的二进制字节流；其次将字节流代表的静态存储结构转化为方法区的运行时数据结构;然后在内存中生成一个代表该类的class对象作为数据的访问入口</p><p>初始化阶段有6种情况必须对类进行初始化</p><ol><li>当遇到 new、 getstatic、putstatic 或 invokestatic 这 4 条字节码指令时</li><li>对类进行反射调用时</li><li><strong>初始化一个类，如果其父类还未初始化，则先触发该父类的初始化</strong>。</li><li><strong>当虚拟机启动时，虚拟机需要定义一个主类，这个主类需要被初始化</strong></li><li>MethodHandle 和 VarHandle 可以看作是轻量级的反射调用机制，而要想使用这 2 个调用，就必须先使用 findStaticVarHandle 来初始化要调用的类。</li><li>当一个接口中定义了被default关键字修饰的接口方法的时候，如果有这个接口的实现类发生了初始化，那该接口要在其之前被初始化。</li></ol><h2 id="讲一下双亲委派模型。【⭐⭐⭐⭐⭐】"><a href="#讲一下双亲委派模型。【⭐⭐⭐⭐⭐】" class="headerlink" title="讲一下双亲委派模型。【⭐⭐⭐⭐⭐】"></a>讲一下双亲委派模型。【⭐⭐⭐⭐⭐】</h2><p>类加载器有很多种：启动类加载器，扩展类加载器、应用程序类加载器等等</p><p><strong>双亲委派模型就是用来确定具体用哪一个类加载器加载类</strong>。</p><ol><li>每当一个类加载器接到加载请求的时候，<strong>先判断类是不是被加载过</strong>，如果加载过就直接返回，否则才会尝试加载；</li><li>进行类加载的时候，会先把这个请求委派给父类的加载器，这样依次类推，所有的请求都会最终传送到顶层的启动类加载器；只有当父类加载器没有找到所需要的类的时候，子加载器才会自己尝试加载；(全力倚父)<br>3.如果最终子类加载器也无法加载这个类，会抛出classnotfoundexception异常</li></ol><p>双亲委派模型的好处是可以避免类的重复加载，保证Java的核心API不被修改</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;运行时数据区中包含哪些区域？哪些线程共享？哪些线程独享？【⭐⭐⭐⭐⭐】&quot;&gt;&lt;a href=&quot;#运行时数据区中包含哪些区域？哪些线程共享？哪些线程独享？【⭐⭐⭐⭐⭐】&quot; class=&quot;headerlink&quot; title=&quot;运行时数据区中包含哪些区域？哪些线程共享？哪</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>八股文骚套路之Java集合</title>
    <link href="http://www.meprotoss.com/undefined/2ca694ee.html"/>
    <id>http://www.meprotoss.com/undefined/2ca694ee.html</id>
    <published>2024-06-08T07:04:20.000Z</published>
    <updated>2024-06-14T02:28:33.209Z</updated>
    
    <content type="html"><![CDATA[<h2 id="集合概述"><a href="#集合概述" class="headerlink" title="集合概述"></a>集合概述</h2><p>Java集合，也叫容器主要有两大接口派生而来</p><ul><li>Collection<ul><li>List(列表):有序可重复<ul><li>ArrayList</li><li>Vector</li><li>LinkedList(双向链表)</li></ul></li><li>Set(集合)：不可重复&#x2F;唯一<ul><li>HashSet(无序唯一)<ul><li>LinkedHashSet:底层使用LinkedHashMap实现</li></ul></li><li>TreeSet(有序唯一)：红黑树(自平衡排序二叉树)</li></ul></li><li>Queue(队列)：特定的排序规则，有序可重复</li></ul></li><li>Map(映射 可以多对一，不能一对多)<ul><li>HashMap：JdK1.8之前是数组+链表，JdK1.8之后在链表长度大于阈值8的时候会将链表转化为红黑树以减少搜索时间，但是在转化之前还会判断当前的哈希桶数组(用来存键值对的数组)的长度是不是小于64，如果不是，那么会先对数组进行扩容。<ul><li>LinkedHashMap:在HashMap的基础上增加了一条双向链表，使HashMap的结构可以保持键值对的插入顺序</li></ul></li><li>Hashtable</li><li>SortedMap</li></ul></li></ul><blockquote><p>[!TIP]<br>在 HashMap 中，主要有一个用于存储键值对的数组，这个数组被称为“哈希桶数组”或“Entry 数组”。在 JDK 1.8 之前，HashMap 的底层数据结构由一个数组 + 链表组成。数组的每个元素（称为桶或者 Entry）都是一个链表的头节点，每个节点存储一个键值对。当发生哈希冲突时，具有相同哈希值的键值对会被放置在同一个桶中，通过链表形式串联在一起。</p></blockquote><h3 id="如何选用集合？"><a href="#如何选用集合？" class="headerlink" title="如何选用集合？"></a>如何选用集合？</h3><ul><li><p>需要根据键值获取元素则选Map接口下的集合，需要排序则用TreeMap，不需要排序则选HashMap，需要线程安全就用ConcurrentHashMap,尽量不用HashTable</p></li><li><p>当只需要存放元素值的时候选用Collection接口的集合，需要唯一用Set接口下的集合，比如TreeSet和HashSet，不需要就用List下的接口比如ArrayList和LinkedList。</p></li></ul><h3 id="ArrayList-数组列表-和-Array（数组）的区别？"><a href="#ArrayList-数组列表-和-Array（数组）的区别？" class="headerlink" title="ArrayList(数组列表) 和 Array（数组）的区别？"></a>ArrayList(数组列表) 和 Array（数组）的区别？</h3><p>ArrayList 内部基于动态数组实现，比 Array（静态数组） 使用起来更加灵活</p><ul><li>ArrayList可以动态地扩容或缩容，而 Array 被创建之后就不能改变它的长度了。</li><li>ArrayList 允许你使用泛型来确保类型安全，Array 则不可以。</li><li>ArrayList 中只能存储对象。对于基本类型数据，基本数据类型要使用包装类。Array 可以直接存储基本类型数据，也可以存储对象。</li><li>ArrayList 支持插入、删除、遍历等常见操作，并且提供了丰富的 API 操作方法，比如 add()、remove()等。Array 只是一个固定长度的数组，只能按照下标访问其中的元素，不具备动态添加、删除元素的能力。</li><li>ArrayList创建时不需要指定大小，而Array创建时必须指定大小。</li></ul><h3 id="ArrayList-与-LinkedList-区别"><a href="#ArrayList-与-LinkedList-区别" class="headerlink" title="ArrayList 与 LinkedList 区别?"></a>ArrayList 与 LinkedList 区别?</h3><p>两者都是线程不安全的</p><p>然后记住ArrayList 采用数组存储 LinkedList 采用链表存储,再根据底层数据结构从插入删除元素，随机访问，内存空间占用上展开来将就行</p><h2 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h2><h3 id="Comparable-和-Comparator-的区别"><a href="#Comparable-和-Comparator-的区别" class="headerlink" title="Comparable 和 Comparator 的区别"></a>Comparable 和 Comparator 的区别</h3><p>Comparable 接口和 Comparator 接口都是 Java 中用于排序的接口, 用于在类对象之间比较大小、排序</p><p>一般我们需要对一个集合使用自定义排序时，我们就要重写compareTo()方法或compare()方法</p><h3 id="无序性和不可重复性的含义是什么"><a href="#无序性和不可重复性的含义是什么" class="headerlink" title="无序性和不可重复性的含义是什么"></a>无序性和不可重复性的含义是什么</h3><ul><li><p>无序性指的是存储的数据在底层数组中的顺序不是按照数组索引的顺序添加，而是根据数据的哈希值决定</p></li><li><p>不可重复性指 equals() 判断的时候返回false，所以需要同时重写equals方法和hashcode方法</p></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;集合概述&quot;&gt;&lt;a href=&quot;#集合概述&quot; class=&quot;headerlink&quot; title=&quot;集合概述&quot;&gt;&lt;/a&gt;集合概述&lt;/h2&gt;&lt;p&gt;Java集合，也叫容器主要有两大接口派生而来&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Collection&lt;ul&gt;
&lt;li&gt;List(列表</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>八股文骚套路之Java基础</title>
    <link href="http://www.meprotoss.com/undefined/df1beea2.html"/>
    <id>http://www.meprotoss.com/undefined/df1beea2.html</id>
    <published>2024-06-04T13:30:42.000Z</published>
    <updated>2024-10-15T05:41:49.770Z</updated>
    
    <content type="html"><![CDATA[<p>⭐ ：面试中不常问到，如果面试官问到尽量能答出来，答不出来也没关系。<br>⭐⭐ ：面试中不常问到，但是如果面试官问到的话，答不出来对你的印象会减分。<br>⭐⭐⭐：面试中会问到，答不出来面试有点悬。面试官会惊讶为什么你这也不会。<br>⭐⭐⭐⭐：面试高频考点。<br>⭐⭐⭐⭐⭐：面试超高频考点。四星考点和五星考点是参加十场面试，至少能有五场面试问到这些的。大家在准备面试过程中尽量把这些知识点的回答条理梳理清楚，面试官一问就开背。</p><h2 id="🆗Java-语言的特点⭐️⭐️"><a href="#🆗Java-语言的特点⭐️⭐️" class="headerlink" title="🆗Java 语言的特点⭐️⭐️"></a>🆗Java 语言的特点⭐️⭐️</h2><ul><li>语法简单，上手容易</li><li>面向对象(封装 继承 多态)</li><li>Java 虚拟机实现了 Java 语言的跨平台性</li><li>支持多线程</li><li>可靠(异常处理和自动内存管理机制)、安全(多重安全防护机制如访问权限修饰符、限制程序直接访问操作系统资源)</li><li>高效性(预编译等技术)</li><li>支持网络编程</li><li>编译与解释并存</li></ul><h2 id="🆗比较-JVM-和-JDK-以及-JRE-⭐️⭐️⭐️"><a href="#🆗比较-JVM-和-JDK-以及-JRE-⭐️⭐️⭐️" class="headerlink" title="🆗比较 JVM 和 JDK 以及 JRE ⭐️⭐️⭐️"></a>🆗比较 JVM 和 JDK 以及 JRE ⭐️⭐️⭐️</h2><ul><li>JVM(Java Virtual Machine) Java 虚拟机是运行 Java 字节码的虚拟机</li><li>JDK(Java Development Kit) Java 开发工具包，提供 Java 的开发环境，<strong>包含 JRE</strong></li><li>JRE(Java Runtime Environment)  Java 运行时环境，包含 JVM 和一些核心类库<br>总结： JDK 包含了 JRE 和开发工具， JRE 包含了 JVM 和核心类库</li></ul><h2 id="🆗为什么说-Java-解释与编译并存-⭐️⭐️"><a href="#🆗为什么说-Java-解释与编译并存-⭐️⭐️" class="headerlink" title="🆗为什么说 Java 解释与编译并存 ⭐️⭐️"></a>🆗为什么说 Java 解释与编译并存 ⭐️⭐️</h2><ul><li>高级编程语言按照程序的执行方式分为编译型和解释型</li><li>编译型是通过编译器一次性将源码翻译为机器码，而解释型是通过解释器逐句将代码解释为机器码再执行。</li><li>Java 程序执行需要先由编译器编译为字节码 .class 文件,再由 Java 解释器解释执行。</li></ul><h2 id="🆗Java-基本类型有哪几种，各占多少位？⭐️⭐️"><a href="#🆗Java-基本类型有哪几种，各占多少位？⭐️⭐️" class="headerlink" title="🆗Java 基本类型有哪几种，各占多少位？⭐️⭐️"></a>🆗Java 基本类型有哪几种，各占多少位？⭐️⭐️</h2><p>基本类型有8种</p><p>6种数字类型：</p><ul><li><p>4种整型:byte short int long (分别为8 16 32 64)</p></li><li><p>2种浮点型:float double(分别为32 64)</p></li><li><p>1种字符型：char(16)</p></li><li><p>1种布尔型：boolean(8)</p></li></ul><h2 id="🆗Java中的泛型和类型擦除-⭐️⭐️⭐️"><a href="#🆗Java中的泛型和类型擦除-⭐️⭐️⭐️" class="headerlink" title="🆗Java中的泛型和类型擦除 ⭐️⭐️⭐️"></a>🆗Java中的泛型和类型擦除 ⭐️⭐️⭐️</h2><p>泛型是Java的一个新特性，可以用来增强可读性和稳定性。<br>Java编译器可以对泛型参数进行检测，可以指定传入对象的泛型<br>泛型一般有三种使用方式：泛型类、泛型接口、泛型方法<br>但是泛型是语法糖的一种，Java虚拟机里没有泛型，只有普通类和普通方法，Java虚拟机会在编译阶段通过类型擦除的方式进行解语法糖，类型擦除就是将所有的泛型参数用其最顶级的父类进行替换。</p><h3 id="🆗既然编译器要将泛型擦除，那为什么还要使用泛型，用Object代替不行吗？-使用泛型的好处"><a href="#🆗既然编译器要将泛型擦除，那为什么还要使用泛型，用Object代替不行吗？-使用泛型的好处" class="headerlink" title="🆗既然编译器要将泛型擦除，那为什么还要使用泛型，用Object代替不行吗？(使用泛型的好处)"></a>🆗既然编译器要将泛型擦除，那为什么还要使用泛型，用Object代替不行吗？(使用泛型的好处)</h3><ol><li>使用泛型可在编译期前进行类型检测。</li><li>使用 Object 类型需要手动添加强制类型转换，降低代码可读性，提高出错概率。</li></ol><h2 id="🆗-和-equals-的区别⭐️⭐️⭐️"><a href="#🆗-和-equals-的区别⭐️⭐️⭐️" class="headerlink" title="🆗&#x3D;&#x3D; 和 equals() 的区别⭐️⭐️⭐️"></a>🆗&#x3D;&#x3D; 和 equals() 的区别⭐️⭐️⭐️</h2><p>这两者对于基本类型和引用类型的效果是不同的</p><ul><li>对于基本数据类型，&#x3D;&#x3D; 比较的是值；对于引用数据类型，&#x3D;&#x3D;比较的是内存地址</li></ul><p>因为在Java中只有值传递，所以本质上来说 &#x3D;&#x3D; 比较的就是值。</p><ul><li>equals()不能用来判断<strong>基本数据类</strong>的变量，只能用来判断两个<strong>对象</strong>是否相等，这有两种情况：第一种是没有重写equals方法，那么默认比较的是两个对象的地址，等同于&#x3D;&#x3D;；但是一般会重写equals方法来判断两个对象的属性是否相等,若属性相等则返回true认为两个对象相等</li></ul><h2 id="🆗hashCode-和-equals-⭐⭐⭐⭐"><a href="#🆗hashCode-和-equals-⭐⭐⭐⭐" class="headerlink" title="🆗hashCode() 和 equals() ⭐⭐⭐⭐"></a>🆗hashCode() 和 equals() ⭐⭐⭐⭐</h2><p>hashCode是用来获取散列码，用来确定对象在hash表中的索引位置，帮助快速找到所需要的对象。<br>当把对象加入hashset，hashset会先计算当前对象的哈希值来确定该对象加入的位置，同时也会将这个哈希值和已经加入对象的哈希值作比较，如果没有一样的，hashset会假设这个对象没有重复出现。但是如果发现有相同的哈希值的对象，则更进一步用equals方法来检查两个对象是不是真的相同。如果相同那么就不会让这个对象加入；如果不同，那么会重新将这个对象散列到其他位置。这样可以大大减少equals方法的执行速度。</p><ul><li>重写equals的时候必须重写hashcode()方法，因为hashcode相等是两个对象相等的必要不充分条件。</li></ul><h2 id="🆗重载和重写的区别⭐⭐⭐⭐"><a href="#🆗重载和重写的区别⭐⭐⭐⭐" class="headerlink" title="🆗重载和重写的区别⭐⭐⭐⭐"></a>🆗重载和重写的区别⭐⭐⭐⭐</h2><ul><li>重载是同一个类中多个同名方法，根据输入参数的数据类型或者数量的不同，作出不同的处理</li><li>重写是子类继承父类的相同方法时，输入数据是一样的，但是需要作出不同于父类的处理，比如功能的扩展之类的，需要覆盖父类的方法(重写发生在运行时,可以改变内部逻辑，但是外部的样子不能改变)</li></ul><h2 id="🆗深拷贝和浅拷贝"><a href="#🆗深拷贝和浅拷贝" class="headerlink" title="🆗深拷贝和浅拷贝"></a>🆗深拷贝和浅拷贝</h2><ul><li>深拷贝会完全复制整个对象，包括这个对象的内部对象。</li><li>浅拷贝会在堆上创建一个新的对象，但是如果对象内部是引用类型的话，不会拷贝内部对象，而是拷贝内部对象的地址引用</li><li>引用拷贝则是只拷贝引用地址</li></ul><h2 id="成员变量和局部变量的区别⭐️⭐️⭐️"><a href="#成员变量和局部变量的区别⭐️⭐️⭐️" class="headerlink" title="成员变量和局部变量的区别⭐️⭐️⭐️"></a>成员变量和局部变量的区别⭐️⭐️⭐️</h2><ul><li>成员变量是属于类的，而局部变量是在代码块或方法中定义的变量或是方法的参数；成员变量可以被访问控制修饰符修饰，局部变量不能；但是两者都可以被final修饰。</li><li>生命周期上，成员变量是对象的一部分，生命周期和对象一致，而局部变量是方法的，随着方法的调用和调用结束产生和消亡</li><li>默认值:成员变量如果没被赋值那么会有默认值(final修饰的成员变量必须显示赋值)；而局部变量不会被自动赋值。</li></ul><h2 id="面向对象三大特性是什么。并解释这三大特性。⭐️⭐️⭐️⭐️"><a href="#面向对象三大特性是什么。并解释这三大特性。⭐️⭐️⭐️⭐️" class="headerlink" title="面向对象三大特性是什么。并解释这三大特性。⭐️⭐️⭐️⭐️"></a>面向对象三大特性是什么。并解释这三大特性。⭐️⭐️⭐️⭐️</h2><ul><li>三大特性是封装、继承和多态</li></ul><p>封装是把一个对象的属性隐藏在对象内部，不允许外部对象直接访问对象的内部信息</p><ul><li>继承</li></ul><ol><li>子类继承父类对象所有的属性和方法，但是父类中的私有属性和方法子类只是拥有不能访问。</li><li>子类可以对父类的属性和方法进行扩展(子承父业，发扬广大)</li><li>子类可以重写(overwrite)父类的方法, 在其基础之上实现功能的扩展</li></ol><ul><li>多态</li></ul><p>一个对象拥有多种状态，父类的引用指向子类的实现</p><ol><li>对象类型和引用类型之间存在继承&#x2F;实现接口的关系；</li><li>引用类型变量发出的方法调用的到底是哪个类中的方法，必须到程序运行时才能确定;3. 多态不能调用“只在子类中有，但是父类中没有的”的方法；</li><li>如果子类重写了父类的方法，真正执行的是子类中重写的方法，如果子类没有重写父类的方法，执行的是父类的方法。(就近原则)</li></ol><h2 id="String、StringBuffer-和-StringBuilder-的区别。-⭐⭐⭐⭐"><a href="#String、StringBuffer-和-StringBuilder-的区别。-⭐⭐⭐⭐" class="headerlink" title="String、StringBuffer 和 StringBuilder 的区别。 ⭐⭐⭐⭐"></a>String、StringBuffer 和 StringBuilder 的区别。 ⭐⭐⭐⭐</h2><p>从可变性上来说，String是不可变的。而StringBuffer和StringBuilder是可变的</p><p>从线程安全性上来说，String中的对象是不变的，所以线程安全（可理解为常量<br>而StringBuffer添加了同步锁，线程安全<br>而StringBuilder没有加锁，所以线程不安全</p><p>从性能上讲：</p><h2 id="Java异常⭐️⭐️⭐️"><a href="#Java异常⭐️⭐️⭐️" class="headerlink" title="Java异常⭐️⭐️⭐️"></a>Java异常⭐️⭐️⭐️</h2><p>Java中，所有的异常都有一个共同的祖先Throwable类，这个类主要有两个重要的子类</p><p>Exception 和 Error</p><ul><li>Exception 是程序本身可以处理的异常，可以通过catch来捕获。<ul><li>Exception又可以分为 Checked Exception可检异常(必须要处理)和Unchecked Exception不可检异常(可以不处理)</li><li>可检异常有：ClassNotFoundException(加载不存在的类时抛出的异常)、SQLException(与数据库交互时候的抛出的异常)、IOException(输入输出操作时候的异常)、ParseException(对日期和时间解析时可能抛出的异常)、FileNoteFoundException(尝试打开一个存在的文件时抛出的异常)</li><li>不可检异常：<ul><li>NullPointerException(空指针错误)</li><li>IllegalArgumentException(参数错误比如方法入参类型错误)</li><li>NumberFormatException（字符串转换为数字格式错误，IllegalArgumentException的子类）</li><li>ArrayIndexOutOfBoundsException（数组越界错误）</li><li>ClassCastException（类型转换错误）</li><li>ArithmeticException（算术错误）</li><li>SecurityException （安全错误比如权限不够）</li><li>UnsupportedOperationException(不支持的操作错误比如重复创建同一用户)</li></ul></li></ul></li><li>Error: Error属于程序无法处理的错误，没法通过catch来捕获。异常发生时Java虚拟机一般会选择终止。</li></ul><p>TODO: 异常捕获的代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">catch</span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">finally</span>&#123;</span><br><span class="line"></span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure><h2 id="🆗序列化和反序列化-⭐️⭐️"><a href="#🆗序列化和反序列化-⭐️⭐️" class="headerlink" title="🆗序列化和反序列化 ⭐️⭐️"></a>🆗序列化和反序列化 ⭐️⭐️</h2><p>序列化：将数据结构对象转化为<strong>二进制字节流</strong>的过程<br>反序列化：将在序列化过程中生成的二进制字节流转化成数据结构或者对象的过程</p><p>序列化的主要目的是通过网络对象或者是将对象存储到文件系统、数据库、内存中。</p><h2 id="反射-⭐⭐-面试官可能会问你什么是反射，它的优缺点是什么，有哪些应用场景"><a href="#反射-⭐⭐-面试官可能会问你什么是反射，它的优缺点是什么，有哪些应用场景" class="headerlink" title="反射 ⭐⭐ 面试官可能会问你什么是反射，它的优缺点是什么，有哪些应用场景"></a>反射 ⭐⭐ 面试官可能会问你什么是反射，它的优缺点是什么，有哪些应用场景</h2><p>通过反射可以获取任意一个类的所有属性和方法，并且可以调用这些方法和属性</p><p>优点：</p><ul><li>反射可以让代码更加灵活、为各种框架开发提供了便利</li></ul><p>缺点：</p><ul><li>安全问题，可以无视泛型参数的安全检查(泛型参数的安全检查发生在编译时)</li><li>性能稍微差点</li></ul><p>反射的应用场景：</p><ul><li>框架中大量使用了动态代理，而动态代理的实现依赖反射</li><li>注解的实现也用到了反射</li></ul><h2 id="List、Set、Map、Queue的区别-⭐⭐"><a href="#List、Set、Map、Queue的区别-⭐⭐" class="headerlink" title="List、Set、Map、Queue的区别 ⭐⭐"></a>List、Set、Map、Queue的区别 ⭐⭐</h2><ul><li>List: 存储的元素是有序的、可重复的。</li><li>Set: 存储的元素不可重复的。</li><li>Queue: 按特定的排队规则来确定先后顺序，存储的元素是有序的、可重复的。</li><li>Map: 使用键值对（key-value）存储，类似于数学上的函数 y&#x3D;f(x)，”x” 代表 key，”y” 代表 value，key 是无序的、不可重复的，value 是无序的、可重复的，每个键最多映射到一个值</li></ul><h2 id="ArrayList-和-LinkedList-的区别。⭐⭐⭐⭐"><a href="#ArrayList-和-LinkedList-的区别。⭐⭐⭐⭐" class="headerlink" title="ArrayList 和 LinkedList 的区别。⭐⭐⭐⭐"></a>ArrayList 和 LinkedList 的区别。⭐⭐⭐⭐</h2><p>线程安全性：ArrayList 和 LinkedList 都是线程不安全的。</p><p>底层数据结构：ArrayList底层采用object数组存储，LinkedList底层采用的是双向链表</p><p>插入和删除元素：</p><ul><li>ArrayList采用数组存储，所以插入和删除元素的复杂度受到元素位置的影响</li><li>而LinkedList 采用双向链表 所以再头尾插入元素不受元素位置的影响。而在其他位置插入元素的话需要先遍历到那个位置。</li></ul><p>随机访问：ArrayList支持随机访问，而LinkedList不支持随机访问。</p><p>内存占用：ArrayList占用连续的内存空间，且在list列表的表尾会预留一部分空间导致内存的浪费；而LinkedList中的每一个元素都会占据比ArrayList更多的空间，因为要存放前驱+后继+元素</p><blockquote><p>我们在项目中一般是不会使用到 LinkedList 的，需要用到 LinkedList 的场景几乎都可以使用 ArrayList 来代替，并且，性能通常会更好！</p></blockquote><h2 id="比较HashSet、LinkedHashSet-和-TreeSet-三者的异同。【⭐⭐⭐】"><a href="#比较HashSet、LinkedHashSet-和-TreeSet-三者的异同。【⭐⭐⭐】" class="headerlink" title="比较HashSet、LinkedHashSet 和 TreeSet 三者的异同。【⭐⭐⭐】"></a>比较HashSet、LinkedHashSet 和 TreeSet 三者的异同。【⭐⭐⭐】</h2><ul><li>HashSet、LinkedHashSet 和 TreeSet 都是 Set 接口的实现类，都能保证元素唯一，并且都不是线程安全的。</li><li>HashSet、LinkedHashSet 和 TreeSet 的主要区别在于底层数据结构不同。<br>HashSet 的底层数据结构是哈希表（基于 HashMap 实现）。<br>LinkedHashSet 的底层数据结构是链表和哈希表，元素的插入和取出顺序满足 FIFO。<br>TreeSet 底层数据结构是红黑树，元素是有序的，排序的方式有自然排序和定制排序。</li><li>底层数据结构不同又导致这三者的应用场景不同。<br>HashSet 用于不需要保证元素插入和取出顺序的场景<br>LinkedHashSet 用于保证元素的插入和取出顺序满足 FIFO 的场景<br>TreeSet 用于支持对元素自定义排序规则的场景</li></ul><h2 id="HashMap-多线程操作导致死循环问题。【⭐⭐⭐】"><a href="#HashMap-多线程操作导致死循环问题。【⭐⭐⭐】" class="headerlink" title="HashMap 多线程操作导致死循环问题。【⭐⭐⭐】"></a>HashMap 多线程操作导致死循环问题。【⭐⭐⭐】</h2><p>Java1.7之前 HashMap在多线程的环境下扩容操作可能存在死循环的问题，因为当有多个元素需要扩容的时候，多个线程同时对链表进行操作，头插法可能会导致链表中的节点指向错误的位置，形成环形链表。Java1.8之后改为尾插法解决了这个问题。<br>但是多线程使用HashMap还容易导致数据覆盖的问题，并发环境下可以使用<code>ConcurrentHashMap</code></p><h2 id="HashMap-的长度为什么是-2-的幂次方。【⭐⭐⭐】"><a href="#HashMap-的长度为什么是-2-的幂次方。【⭐⭐⭐】" class="headerlink" title="HashMap 的长度为什么是 2 的幂次方。【⭐⭐⭐】"></a>HashMap 的长度为什么是 2 的幂次方。【⭐⭐⭐】</h2><p>为了尽量减少hash冲突，hash值的范围很大，但是这么大的映射空间的数组内存是放不下的，所以用之前会对数组进行取模运算，得到的余数才是对应的最终的数组下标，所以这样操作主要是考虑到了对运算效率的提升。<br>在设计算法的时候取余操作只有当除数是 2 的幂次才等价于与其除数减一的与(&amp;)操作<br>（也就是说 hash%length&#x3D;&#x3D;hash&amp;(length-1)的前提是 length 是 2 的 n 次方；）</p><h2 id="HashMap、HashTable、以及-ConcurrentHashMap-的区别⭐⭐⭐⭐⭐"><a href="#HashMap、HashTable、以及-ConcurrentHashMap-的区别⭐⭐⭐⭐⭐" class="headerlink" title="HashMap、HashTable、以及 ConcurrentHashMap 的区别⭐⭐⭐⭐⭐"></a>HashMap、HashTable、以及 ConcurrentHashMap 的区别⭐⭐⭐⭐⭐</h2><ol><li>首先HashMap和HashTable</li></ol><p>从线程安全性上来说：<br>HashMap是非线程安全的，HashTable是线程安全的，因为Hash的大部分方法都使用了synchronized修饰(但是如果想保证线程安全 还是要用ConcurrentHashMap)</p><p>从效率上来说：<br>因为线程安全问题，hashMap比HashTable效率高，而且hashtable有上位替代ConcurrentHashMap</p><p>从null key 和 null value 的支持上来说：HashMap可以存储null的key和value，但是null作为key只能有一个，作为值可以有多个；HashTable不允许有NUll键和Null值，否则会抛<code>NullPointerException</code></p><p>从初始容量大小和每次扩充的的容量大小上来说：</p><ol><li>如果不指定容量的初始，Hashtable默认为11 ，之后每次扩充扩充为原来容量的2N+1；HashMap默认大小为16,之后每次扩充为原来两倍。</li><li>如果指定容量的初始值，hashtable会直接用你指定的大小，而hashmap会将其扩充为2的幂次方大小。</li></ol><p>从底层数据结构上来说：<br>Java1.8之后的HashMap在解决哈希冲突时有了很大变化，当链表长度大于阈值的时候，将链表转化为红黑树以减少搜索的时间(在转化成红黑树之前会先判断当前数组的长度是否小于64，如果小于则先进行扩容,而不是转化成红黑树),而HashTable没有这样的机制。</p><ol start="2"><li>ConcurrentHashMap 和 Hashtable 的区别</li></ol><p>两者主要的区别是实现线程安全的方式不同</p><p>从底层数据结构上来说： JDK1.7 的ConcurrentHashMap采用<code>分段数组+链表</code>实现，JDK1.8采用的数据结构和HashMap1.8一样，采用数组+链表&#x2F;红黑二叉树。Hashtable 和 JDK1.8 之前的 HashMap 的底层数据结构类似,都是采用 数组+链表 的形式，<strong>数组是 HashMap 的主体，链表则是主要为了解决哈希冲突而存在的</strong></p><p>从实现线程安全的方式上来说：并发HashMap有多把锁，而Hashtable共用一把锁<br>在 JDK1.7 的时候，ConcurrentHashMap 对整个桶数组进行了分割(segment)，每一把锁只锁容器其中一部分数据，多线程访问容器里不同数据段的数据，就不会存在锁竞争，提高并发访问率。<br>到了 JDK1.8 的时候，ConcurrentHashMap不用segment了，而是直接用 Node 数组+链表+红黑树的数据结构来实现，并发控制使用 synchronized 和 CAS 来操作</p><p>Hashtable(同一把锁) :使用 synchronized 来保证线程安全，效率非常低下。当一个线程访问同步方法时，其他线程也访问同步方法，可能会进入阻塞或轮询状态，效率十分低下</p><blockquote><p>什么是 CAS? CAS 即比较并替换（Compare And Swap)，是实现并发算法时常用到的一种技术。CAS 操作包含三个操作数——内存位置、预期原值及新值。执行 CAS 操作的时候，将内存位置的值与预期原值比较，如果相匹配，那么处理器会自动将该位置值更新为新值，否则，处理器不做任何操作。我们都知道，CAS 是一条 CPU 的原子指令（cmpxchg 指令），不会造成所谓的数据不一致问题，Unsafe 提供的 CAS 方法（如 compareAndSwapXXX）底层实现即为 CPU 指令 cmpxchg 。</p></blockquote><h3 id="JDK-1-7-和-JDK-1-8-的-ConcurrentHashMap-实现有什么不同？"><a href="#JDK-1-7-和-JDK-1-8-的-ConcurrentHashMap-实现有什么不同？" class="headerlink" title="JDK 1.7 和 JDK 1.8 的 ConcurrentHashMap 实现有什么不同？"></a>JDK 1.7 和 JDK 1.8 的 ConcurrentHashMap 实现有什么不同？</h3><ul><li>线程安全实现方式：JDK 1.7 采用 Segment 分段锁来保证安全， Segment 是继承自 ReentrantLock。JDK1.8 放弃了 Segment 分段锁的设计，采用 Node + CAS + synchronized 保证线程安全，锁粒度更细，synchronized 只锁定当前链表或红黑二叉树的首节点。</li><li>Hash 碰撞解决方法 : JDK 1.7 采用拉链法，JDK1.8 采用拉链法结合红黑树（链表长度超过一定阈值时，将链表转换为红黑树）。</li><li>并发度：JDK 1.7 最大并发度是 Segment 的个数，默认是 16。JDK 1.8 最大并发度是 Node 数组的大小，并发度更大。</li></ul><h3 id="为什么要用红黑树"><a href="#为什么要用红黑树" class="headerlink" title="为什么要用红黑树"></a>为什么要用红黑树</h3><p>主要目的是解决哈希冲突<br>当哈希冲突发生时，通常会使用链表将具有相同哈希值的键值对存储在同一个桶中。<br>然而，当链表中的元素达到一定的阈值的时候，Java1.8会将链表转化为红黑树，红黑树是一种平衡二叉搜索树，具有更快的查找效率，可以解决链表过长的时候查找效率低下的问题</p><h2 id="static-和-final-一起使用的效果"><a href="#static-和-final-一起使用的效果" class="headerlink" title="static 和 final 一起使用的效果"></a>static 和 final 一起使用的效果</h2><p>需要看修饰的是变量还使类</p><ul><li>static final 变量:static代表变量属于类，final代表不可变，因此加在一起的话这个变量就是常量</li><li>static final 方法:static代表该方法属于当前类，不属于实例，不能被重写</li><li>final 类：不能被继承。</li><li>static 类：只能用于内部类，表示该类可以独立于外部类的实例存在。</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;⭐ ：面试中不常问到，如果面试官问到尽量能答出来，答不出来也没关系。&lt;br&gt;⭐⭐ ：面试中不常问到，但是如果面试官问到的话，答不出来对你的印象会减分。&lt;br&gt;⭐⭐⭐：面试中会问到，答不出来面试有点悬。面试官会惊讶为什么你这也不会。&lt;br&gt;⭐⭐⭐⭐：面试高频考点。&lt;br&gt;⭐⭐</summary>
      
    
    
    
    
  </entry>
  
</feed>
