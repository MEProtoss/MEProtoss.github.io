<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Protoss想要平静生活</title>
  
  <subtitle>神圣的卡拉连接着我们每一个人</subtitle>
  <link href="http://www.meprotoss.com/atom.xml" rel="self"/>
  
  <link href="http://www.meprotoss.com/"/>
  <updated>2024-09-23T09:16:04.385Z</updated>
  <id>http://www.meprotoss.com/</id>
  
  <author>
    <name>Mr.Chen</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>八股文骚套路之项目拷打</title>
    <link href="http://www.meprotoss.com/undefined/824f9b28.html"/>
    <id>http://www.meprotoss.com/undefined/824f9b28.html</id>
    <published>2024-09-22T01:53:54.000Z</published>
    <updated>2024-09-23T09:16:04.385Z</updated>
    
    <content type="html"><![CDATA[<h2 id="介绍一下项目"><a href="#介绍一下项目" class="headerlink" title="介绍一下项目"></a>介绍一下项目</h2><ul><li><p>功能：这是一个本地校园生活服务平台，为学校学生提供线上论坛、线上商城的功能。</p></li><li><p>项目框架：由springboot开发的前后端分类项目，使用了redis集群、tomcat集群、<br>mysql集群来提高服务器的性能</p></li><li><p>项目的技术栈: springboot+nginx+mysql+lombok+mybatis+hutool+redis</p></li></ul><h2 id="短信登录功能"><a href="#短信登录功能" class="headerlink" title="短信登录功能"></a>短信登录功能</h2><h3 id="初次登录"><a href="#初次登录" class="headerlink" title="初次登录"></a>初次登录</h3><p>注册之后，校验用户登陆的手机号和验证码，然后根据手机号查询用户信息，不存在则创建，然后将用户信息保存到redis，以生成的token作为redis的key。</p><h3 id="校验登录状态"><a href="#校验登录状态" class="headerlink" title="校验登录状态"></a>校验登录状态</h3><p>用户携带token进行访问，从redis中取出token对应的value，判断是否存在这个数据，如果没有则拦截，如果存在则将其保存到<strong>threadLocal</strong>中，并且放行。</p><blockquote><p>[!TIP]<br>因为不同服务器之间的session无法共享，使用redis可以实现数据共享<br>将部分可展示属性封装成dto单独传递是为了实现数据的脱敏处理</p></blockquote><h3 id="双重拦截器干什么用的？"><a href="#双重拦截器干什么用的？" class="headerlink" title="双重拦截器干什么用的？"></a>双重拦截器干什么用的？</h3><p>浏览需要验证身份的模块时，在这些模块的共同的拦截器中拦截请求，刷新token。</p><p>但是有些页面不需要验证登录状态，但是也要刷新token，所以新添加一层拦截器专门用来刷新token有效期，避免出现token过期用户需要重新登录</p><h3 id="threadLocal是干什么用的？"><a href="#threadLocal是干什么用的？" class="headerlink" title="threadLocal是干什么用的？"></a>threadLocal是干什么用的？</h3><p>服务器从session中获取用户信息 获取到之后将用户缓存到<code>ThreadLocal</code>中,方便后续的使用。<br>因为在业务中，每一个请求都是一个独立的线程，所以不能将用户信息保存到本地变量中，这样会导致多线程并发修改的安全问题，使用threadLocal就是在拦截器拦截到用户请求传递给控制器的时候，让每一个请求都开启一个独立的线程，避免出现线程安全问题</p><h2 id="使用延迟双删方案解决缓存与数据的数据一致性问题？"><a href="#使用延迟双删方案解决缓存与数据的数据一致性问题？" class="headerlink" title="使用延迟双删方案解决缓存与数据的数据一致性问题？"></a>使用延迟双删方案解决缓存与数据的数据一致性问题？</h2><p>首先为什么会出现数据一致性问题？</p><p>数据一致性问题值的是数据库和缓存中保存的数据不一致。</p><p>使用redis来缓存商户商品信息，提升访问速度</p><p>查询数据库之前先查询缓存，如果缓存数据存在，则直接从缓存中返回</p><p>如果缓存数据不存在，再查询数据库，然后将数据存入redis。</p><h3 id="缓存与数据库的数据一致性问题及其解决方案"><a href="#缓存与数据库的数据一致性问题及其解决方案" class="headerlink" title="缓存与数据库的数据一致性问题及其解决方案"></a>缓存与数据库的数据一致性问题及其解决方案</h3><p>**<br>  什么是延迟双删方案?<br>**</p><ul><li><p><strong>双删</strong>指的是更新数据库的时候一并删除缓存</p></li><li><p><strong>延迟</strong>指的是延迟更新缓存，当查询的时候再去更新缓存</p></li><li><p>解决数据一致性问题有几种常见的缓存更新策略：</p><ul><li>内存淘汰: 内存不足的时候自动淘汰部分数据，下次查询的时候更新缓存</li><li>超时删除: 给数据添加ttl，到期自动删除</li><li>主动更新<ul><li>双写方案（也叫旁路缓存读写策略）：<ol><li>先更新数据库，再更新缓存</li><li>更新数据库的时候一并删除缓存(双删)，查询的时候再更新缓存</li></ol></li></ul></li></ul></li><li><p>查询时:如果缓存中没找到，则查询数据库，将数据库结果写入缓存，并设置超时时间</p></li><li><p>修改时:<strong>先修改数据库，再删除缓存</strong>。等再查询数据时，再从数据库中加载到缓存中</p></li><li><p>并采用超时删除和内存淘汰机制作为兜底方案</p></li></ul><h3 id="为什么要使用延迟双删方案"><a href="#为什么要使用延迟双删方案" class="headerlink" title="为什么要使用延迟双删方案?"></a>为什么要使用延迟双删方案?</h3><ul><li>因为数据库操作太慢，为了防止删除缓存到更新数据库的时候有其他线程过来查询数据出现缓存击穿问题，因此必须先操作数据库,只要将缓存和数据库的操作放到同一个事务中就可以保证缓存与数据库操作的原子性</li></ul><h2 id="使用缓存空值和布隆过滤器缓存穿透问题"><a href="#使用缓存空值和布隆过滤器缓存穿透问题" class="headerlink" title="使用缓存空值和布隆过滤器缓存穿透问题"></a>使用缓存空值和布隆过滤器缓存穿透问题</h2><ul><li><p>缓存穿透：客户端请求的数据在数据库和缓存中都不存在</p></li><li><p>缓存空值：如果查询的数据数据库中没有，那么就在缓存中缓存一个空对象，下次再来查的时候就不会找到数据库了，在缓存中发现是空值则直接结束查询</p></li><li><p>自定义布隆过滤器：在缓存之前添加一个布隆过滤器，提前将用户可能查询的数据放在过滤器里，用hash思想判断数据是否存在，但是布隆过滤器会有误判可能（存在的不一定存在，不存在的一定不存在）</p></li></ul><h3 id="使用缓存预热解决缓存雪崩问题"><a href="#使用缓存预热解决缓存雪崩问题" class="headerlink" title="使用缓存预热解决缓存雪崩问题"></a>使用缓存预热解决缓存雪崩问题</h3><ul><li><p><strong>同一时间大量缓存key同时失效</strong> 或者 <strong>redis服务器宕机</strong>导致大量请求同时到达数据库</p></li><li><p>针对redis宕机:可以使用reids集群和多级缓存</p></li><li><p>针对大量key同时失效:可以采用缓存预热：提前将热点key存入缓存中并设置合理的过期时间,这个过滤实践可以手动设置逻辑过期</p><ul><li>缓存预热方法：这里可使用<strong>消息队列kafka</strong>，异步地进行缓存预热。将数据库中的热点数据的主键或者 ID 发送到消息队列中，然后由缓存服务 消费 消息队列中的数据，根据主键或者 ID 查询数据库并更新缓存）</li></ul></li></ul> <!-- TODO: 什么是kafka？ --><h3 id="使用互斥锁解决缓存击穿问题"><a href="#使用互斥锁解决缓存击穿问题" class="headerlink" title="使用互斥锁解决缓存击穿问题"></a>使用互斥锁解决缓存击穿问题</h3><ul><li><p>缓存击穿也叫热点key问题，指的是一个高并发访问且缓存重建比较复杂的key突然失效</p></li><li><p>热点key过期之后，使用一把互斥锁，让失效key排队依次重建。查询缓存之后之后如果没查到，会先去获取互斥锁，获取到互斥锁才能进行查询数据库;还可以设置逻辑过期来解决缓存过期问题</p></li></ul><h2 id="使用rabbitmq消息队列实现优惠券秒杀功能，并通过乐观锁解决超卖问题，使用分布式锁解决一人一单问题"><a href="#使用rabbitmq消息队列实现优惠券秒杀功能，并通过乐观锁解决超卖问题，使用分布式锁解决一人一单问题" class="headerlink" title="使用rabbitmq消息队列实现优惠券秒杀功能，并通过乐观锁解决超卖问题，使用分布式锁解决一人一单问题"></a>使用rabbitmq消息队列实现优惠券秒杀功能，并通过乐观锁解决超卖问题，使用分布式锁解决一人一单问题</h2><h3 id="rabbitmq消息队列实现优惠券秒杀问题"><a href="#rabbitmq消息队列实现优惠券秒杀问题" class="headerlink" title="rabbitmq消息队列实现优惠券秒杀问题"></a>rabbitmq消息队列实现优惠券秒杀问题</h3><p>因为为秒杀设计到很多步骤，查询用户是否持有优惠券，判断库存是否充足，查询用户是否下单，校验是否一人一单，扣减库存，创建订单这些步骤，很多操作是要操作数据库的，这样如果是一个线程串行执行就会很慢,而我们只需要确认用户有下单资格（持有优惠券、库存充足）就可以了。因此将将耗时比较短的逻辑判断放入到redis中,确认能下单之后在后台再开一个线程执行后续步骤，实现异步下单。</p><h3 id="乐观锁解决超卖问题"><a href="#乐观锁解决超卖问题" class="headerlink" title="乐观锁解决超卖问题"></a>乐观锁解决超卖问题</h3><p>首先什么是超卖问题：线程a来查库存，此时大于1，要去扣库存但还没来得及扣，此时线程b来查库存，发现也大于1，那么两个线程都去扣减库存，导致超卖</p><p>乐观锁：只在<strong>数据更新时</strong>判断有没有其他线程对数据进行了修改</p><blockquote><p>[!TIP]<br>悲观锁：认为线程安全问题一定会发生，因此每次执行数据库操作的时候都需要加锁<br>常见的悲观锁有：synchronized、lock</p></blockquote><ul><li>操作数据库的时候对数据的版本号进行+1 <strong>只有当版本号不变的时候才能操作</strong> ，假设线程a操作之后，version号从1变成了2，那么线程2操作的时候发现version !&#x3D; 1 因此不能操作</li></ul><h3 id="使用分布式锁解决一人一单问题"><a href="#使用分布式锁解决一人一单问题" class="headerlink" title="使用分布式锁解决一人一单问题"></a>使用分布式锁解决一人一单问题</h3><ul><li><p>一人一单问题是指，同一个优惠券，一个用户只能下一单</p></li><li><p>分布式锁：满足分布式系统或者集群模式下多线程可见并且互斥的锁。</p></li></ul><ol><li><p>分布式系统 集群模式</p></li><li><p>多线程可见 互斥</p></li></ol><p>使用<strong>redis的setNx方法</strong>，当多个线程过来抢优惠券，第一个线程抢到锁之后，去执行业务，然后删除释放锁，其他线程等待并重试</p><blockquote><p>[!TIP]<br>利用setnx的方法加锁，同时设置过期时间，防止死锁</p></blockquote><ul><li>误删别人的锁的问题： 如果持有锁的线程在锁的内部出现了阻塞，导致他的锁自动释放，这时其他线程，线程2来尝试获得锁，就拿到了这把锁，然后线程2在持有锁执行过程中，线程1反应过来，继续执行，而线程1执行过程中，走到了删除锁逻辑，此时就会把本应该属于线程2的锁进行删除，这就是误删别人锁，<strong>因此在删除锁之前要判断这把锁是不是自己的</strong></li></ul><p>综上：使用redisson分布式锁替代setnx解决这些问题</p><h2 id="压测的时候主要关注的指标"><a href="#压测的时候主要关注的指标" class="headerlink" title="压测的时候主要关注的指标"></a>压测的时候主要关注的指标</h2><ul><li>并发量</li><li>响应时间</li><li>错误率</li><li>吞吐量<ul><li>QPS：每秒能够处理的查询数量</li><li>TPS：每秒能够处理的事务数量</li></ul></li><li>资源使用率</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;介绍一下项目&quot;&gt;&lt;a href=&quot;#介绍一下项目&quot; class=&quot;headerlink&quot; title=&quot;介绍一下项目&quot;&gt;&lt;/a&gt;介绍一下项目&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;功能：这是一个本地校园生活服务平台，为学校学生提供线上论坛、线上商城的功能。&lt;/p&gt;
&lt;/</summary>
      
    
    
    
    
    <category term="八股" scheme="http://www.meprotoss.com/tags/%E5%85%AB%E8%82%A1/"/>
    
  </entry>
  
  <entry>
    <title>八股文骚套路之设计模式</title>
    <link href="http://www.meprotoss.com/undefined/cb77a7ee.html"/>
    <id>http://www.meprotoss.com/undefined/cb77a7ee.html</id>
    <published>2024-09-21T08:06:20.000Z</published>
    <updated>2024-09-23T09:07:44.319Z</updated>
    
    <content type="html"><![CDATA[<h2 id="jdk中常见的设计模式"><a href="#jdk中常见的设计模式" class="headerlink" title="jdk中常见的设计模式"></a>jdk中常见的设计模式</h2><ul><li>单例</li><li>工厂模式（简单工厂、抽象工厂）</li><li>装饰器模式</li></ul><h2 id="你是否在你的代码里使用过设计模式？"><a href="#你是否在你的代码里使用过设计模式？" class="headerlink" title="你是否在你的代码里使用过设计模式？"></a>你是否在你的代码里使用过设计模式？</h2><ul><li>面向对象编程中，使用工厂模式来创建对象<!-- TODO: 举一个黑马点评中的例子 --></li></ul><h2 id="Java中什么叫单例设计模式？请写出Java中线程安全的单例模式"><a href="#Java中什么叫单例设计模式？请写出Java中线程安全的单例模式" class="headerlink" title="Java中什么叫单例设计模式？请写出Java中线程安全的单例模式"></a>Java中什么叫单例设计模式？请写出Java中线程安全的单例模式</h2><ul><li>一个类只有一个实例,主要有懒汉式和饿汉式两种创建方式，懒汉式仅初始化类，但是仅在调用getInstance方法时才创建对象；<br>饿汉式则在初始化类的时候一并创建对象</li><li>懒汉式，线程不安全</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance;</span><br><span class="line">  <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(instance == <span class="literal">null</span>)&#123;</span><br><span class="line">      instance = <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> instance;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>懒汉式，线程安全(使用synchronized来保证线程安全)</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(instance == <span class="literal">null</span>)&#123;</span><br><span class="line">      instance = <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> instance;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>饿汉式</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">Singleton</span> <span class="variable">instance</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span> &#123;&#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="为什么说枚举是实现单例的最好方式"><a href="#为什么说枚举是实现单例的最好方式" class="headerlink" title="为什么说枚举是实现单例的最好方式"></a>为什么说枚举是实现单例的最好方式</h2><ul><li>线程安全</li><li>简洁性和可读性</li><li>序列化安全性</li><li>反射安全性</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;jdk中常见的设计模式&quot;&gt;&lt;a href=&quot;#jdk中常见的设计模式&quot; class=&quot;headerlink&quot; title=&quot;jdk中常见的设计模式&quot;&gt;&lt;/a&gt;jdk中常见的设计模式&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;单例&lt;/li&gt;
&lt;li&gt;工厂模式（简单工厂、抽象工厂）&lt;</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>八股文骚套路之Redis</title>
    <link href="http://www.meprotoss.com/undefined/eaffd6f8.html"/>
    <id>http://www.meprotoss.com/undefined/eaffd6f8.html</id>
    <published>2024-09-21T02:55:09.000Z</published>
    <updated>2024-09-23T09:14:48.812Z</updated>
    
    <content type="html"><![CDATA[<h2 id="缓存雪崩的解决方案"><a href="#缓存雪崩的解决方案" class="headerlink" title="缓存雪崩的解决方案"></a>缓存雪崩的解决方案</h2><p><strong>缓存在同一时间大面积的失效</strong>，导致大量的请求都直接落到了数据库上，对数据库造成了巨大的压力</p><p><strong>缓存服务宕机</strong>也会导致缓存雪崩现象</p><h3 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h3><h4 id="针对redis服务不可用的情况"><a href="#针对redis服务不可用的情况" class="headerlink" title="针对redis服务不可用的情况"></a>针对redis服务不可用的情况</h4><ul><li>Redis 集群:采用 Redis 集群，避免单机出现问题整个缓存服务都没办法使用</li><li>多级缓存</li></ul><h4 id="针对大量缓存同时失效的情况"><a href="#针对大量缓存同时失效的情况" class="headerlink" title="针对大量缓存同时失效的情况"></a>针对大量缓存同时失效的情况</h4><ul><li>设置随机失效时间：避免大量缓存同时到期</li><li>提前预热：针对热点数据提前预热，将其存入缓存中并设置合理的过期时间 （比如秒杀场景下的数据在秒杀结束之前不过期(逻辑过期))。<ul><li>缓存预热的常见实现方式：<strong>定时任务</strong>和<strong>消息队列</strong>，<strong>Kafka</strong>可以异步的进行缓存预热</li></ul></li></ul><h2 id="如何保证缓存和数据库中数据的一致性"><a href="#如何保证缓存和数据库中数据的一致性" class="headerlink" title="如何保证缓存和数据库中数据的一致性"></a>如何保证缓存和数据库中数据的一致性</h2><ul><li>让缓存失效的时间变短,这样缓存就会很快从数据库从加载数据。(不推荐)</li><li>增加缓存更新重试机制：针对缓存不可用导致的缓存删除失败，可以引入消息队列实现<strong>异步</strong>重试，将删除缓存重试的消息投递到消息队列，然后由专门的消费者来重试，直到成功。</li></ul><h2 id="缓存击穿-热点key问题"><a href="#缓存击穿-热点key问题" class="headerlink" title="缓存击穿(热点key问题)"></a>缓存击穿(热点key问题)</h2><p>请求的 key 对应的是<strong>热点数据 ，该数据存在于数据库中，但不存在于缓存中</strong>,瞬时大量的请求直接打到了数据库上</p><p>举个例子：秒杀进行过程中，缓存中的某个秒杀商品的数据突然过期，这就导致瞬时大量对该商品的请求直接落到数据库上，对数据库造成了巨大的压力</p><h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><ul><li>提前预热：提前将热点key存入缓存</li><li>加锁：在缓存失效之后，通过设置互斥锁确保只有一个请求取查询数据库更新缓存。</li><li>永不过期（不推荐）</li></ul><h2 id="缓存穿透"><a href="#缓存穿透" class="headerlink" title="缓存穿透"></a>缓存穿透</h2><p><strong>大量请求的key 不存在于缓存中，也不存在于数据库中</strong></p><h3 id="解决方法-1"><a href="#解决方法-1" class="headerlink" title="解决方法"></a>解决方法</h3><ul><li>缓存空值</li><li>设置布隆过滤器：布隆过滤器可以很方便的判断一个给定数据是否存在于海量数据中。相当于在用户请求和缓存之间添加了一层过滤，将所有可能存在的请求值都存放在布隆过滤器中，当用户请求过来，先判断在不在过滤器中，如果不存在，则直接返回请求参数错误给客户端。</li></ul><h2 id="缓存穿透vs缓存击穿"><a href="#缓存穿透vs缓存击穿" class="headerlink" title="缓存穿透vs缓存击穿"></a>缓存穿透vs缓存击穿</h2><p>缓存穿透: 请求的key在缓存中不存在，也不存在在数据库中<br>缓存击穿：请求的key是热点数据，不在缓存中，在数据库中</p><h2 id="缓存雪崩vs缓存击穿"><a href="#缓存雪崩vs缓存击穿" class="headerlink" title="缓存雪崩vs缓存击穿"></a>缓存雪崩vs缓存击穿</h2><p>缓存雪崩： 缓存中的大量或所有数据失效<br>缓存击穿： 热点数据不在缓存中（通常是由于缓存中的那份数据已经过期）</p><h2 id="解决数据一致性问题常用的缓存读写策略"><a href="#解决数据一致性问题常用的缓存读写策略" class="headerlink" title="解决数据一致性问题常用的缓存读写策略"></a>解决数据一致性问题常用的缓存读写策略</h2><ul><li>旁路缓存：<ul><li>写：先更新数据库，然后直接删除缓存（数据库优先）</li><li>读：先读缓存；读不到就读db返回；然后把数据写入缓存</li><li>适用于读请求较多的场景</li></ul></li><li>读写穿透<ul><li>写：先查缓存，缓存中没有直接更新数据库；缓存中存在则先更新缓存，然后缓存同步更新数据库（缓存优先）</li><li>读：先读缓存；读不到就读db，写入缓存再返回</li></ul></li><li>异步缓存写入：<ul><li>类似读写穿透，<strong>两者都是由 cache 服务来负责 cache 和 db 的读写。</strong></li><li>两者区别在于：读写穿透<strong>同步更新数据库和缓存</strong>；异步缓存写入<strong>只更新缓存，异步批量更新数据库</strong></li></ul></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;缓存雪崩的解决方案&quot;&gt;&lt;a href=&quot;#缓存雪崩的解决方案&quot; class=&quot;headerlink&quot; title=&quot;缓存雪崩的解决方案&quot;&gt;&lt;/a&gt;缓存雪崩的解决方案&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;缓存在同一时间大面积的失效&lt;/strong&gt;，导致大量的请求都直接落</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>八股文骚套路之mysql</title>
    <link href="http://www.meprotoss.com/undefined/c53b31d1.html"/>
    <id>http://www.meprotoss.com/undefined/c53b31d1.html</id>
    <published>2024-09-20T09:05:20.000Z</published>
    <updated>2024-09-23T09:36:57.422Z</updated>
    
    <content type="html"><![CDATA[<h2 id="ORDER-BY、LIMIT、GROUP-BY、HAVING-这些关键字的作用"><a href="#ORDER-BY、LIMIT、GROUP-BY、HAVING-这些关键字的作用" class="headerlink" title="ORDER BY、LIMIT、GROUP BY、HAVING 这些关键字的作用"></a>ORDER BY、LIMIT、GROUP BY、HAVING 这些关键字的作用</h2><ul><li>order by：排序</li><li>limit: 限制查询返回的行数</li><li>group by：根据一个或多个列对查询结果分组</li><li>having: 用于过滤分组后的数据<ul><li>相比较where:HAVING 在分组后应用条件，而 WHERE 在分组前应用条件</li></ul></li></ul><h2 id="左链接和右链接的区别"><a href="#左链接和右链接的区别" class="headerlink" title="左链接和右链接的区别"></a>左链接和右链接的区别</h2><p>一个以左边的表为基础，确保左表中的行都出现在结果中,反之亦然</p><h2 id="InnoDB-mysql数据库管理系统的一个存储引擎-相关"><a href="#InnoDB-mysql数据库管理系统的一个存储引擎-相关" class="headerlink" title="InnoDB(mysql数据库管理系统的一个存储引擎)相关"></a>InnoDB(mysql数据库管理系统的一个存储引擎)相关</h2><p>索引的本质是一种排序好的数据结构</p><h3 id="InnoDB-和-MyISAM-的区别是什么"><a href="#InnoDB-和-MyISAM-的区别是什么" class="headerlink" title="InnoDB 和 MyISAM 的区别是什么"></a>InnoDB 和 MyISAM 的区别是什么</h3><ul><li>InnoDB 支持行级锁，MyISAM只有表级锁</li><li>MyISAM 不提供事务支持。</li><li>InnoDB 提供事务支持，MyISAM不支持。</li><li>MyISAM 不支持外键，而 InnoDB 支持。</li><li>MyISAM 不支持 MVCC，而 InnoDB 支持。</li><li>虽然 MyISAM 引擎和 InnoDB 引擎都是使用 B+Tree 作为索引结构，但是两者的实现方式不太一样。</li><li>MyISAM 不支持数据库异常崩溃后的安全恢复，而 InnoDB 支持。</li><li>InnoDB 的性能比 MyISAM 更强大</li></ul><h2 id="索引相关"><a href="#索引相关" class="headerlink" title="索引相关"></a>索引相关</h2><h3 id="索引所采用的数据结构，以及为什么要这样设计"><a href="#索引所采用的数据结构，以及为什么要这样设计" class="headerlink" title="索引所采用的数据结构，以及为什么要这样设计"></a>索引所采用的数据结构，以及为什么要这样设计</h3><p>常见的索引结构有:</p><ul><li><strong>hash表</strong> 不支持顺序和范围查询</li><li>红黑树</li><li><strong>B树</strong></li><li><strong>B+树</strong><ul><li>节点存放key，叶子存放key和data</li><li>叶子节点有一条引用鲢指向与他相邻的叶子节点</li><li>任何查找都是从根节点到叶子节点的过程，检索效率稳定</li><li>B+树的范围查找只需要对叶子节点作范围查询</li></ul></li><li>二叉查找树(左小右大)</li><li>平衡二叉树(优化的二叉查找树 左右子树高度之差不超过 1)</li></ul><h3 id="BTree-索引和-Hash-索引的适用范围"><a href="#BTree-索引和-Hash-索引的适用范围" class="headerlink" title="BTree 索引和 Hash 索引的适用范围"></a>BTree 索引和 Hash 索引的适用范围</h3><p>InnoDB数据库和MyISM数据库默认使用BTree索引</p><ul><li>hash索引适用于<strong>等值查询</strong>，尤其是在<strong>内存密集</strong>的环境中；</li><li>不适用于范围查询、排序和处理大量哈希冲突的情况</li></ul><h2 id="SQL优化问题"><a href="#SQL优化问题" class="headerlink" title="SQL优化问题"></a>SQL优化问题</h2><h3 id="哪些场景可以使用索引"><a href="#哪些场景可以使用索引" class="headerlink" title="哪些场景可以使用索引"></a>哪些场景可以使用索引</h3><ul><li>排序</li><li>连接操作</li><li>唯一性约束</li><li>聚集函数</li><li>范围查询</li><li>避免全表查询</li></ul><h3 id="索引在哪些情况会失效"><a href="#索引在哪些情况会失效" class="headerlink" title="索引在哪些情况会失效"></a>索引在哪些情况会失效</h3><ul><li>不能对索引列进行查询和函数操作</li><li>数据分布不均匀</li><li>数据量很大</li><li>频繁更新的列</li><li>索引列参与复杂的表达式或者条件</li></ul><h2 id="事务四大特性，并解释这四大特性的含义"><a href="#事务四大特性，并解释这四大特性的含义" class="headerlink" title="事务四大特性，并解释这四大特性的含义"></a>事务四大特性，并解释这四大特性的含义</h2><p>ACID</p><ul><li>原子性 事务是最小执行单位，不允许分割</li><li>一致性 执行事务前后 数据保持一致</li><li>隔离性 并发访问数据库时，一个用户的事务不被其他事务所干扰</li><li>持久性 事务提交之后对数据库的影响是永久的</li></ul><p>只有保证了事务的持久性、原子性、隔离性之后，一致性才能得到保障。也就是说 A、I、D 是手段，C 是目的！</p><h2 id="并发事务处理会带来哪些问题？"><a href="#并发事务处理会带来哪些问题？" class="headerlink" title="并发事务处理会带来哪些问题？"></a>并发事务处理会带来哪些问题？</h2><ul><li>脏读 a读到了b修改未提交的数据</li><li>幻读 a多次读同一个数据，但是期间其他事务对数据进行了修改</li><li>丢失修改 a读一个数据，b也访问该数据，第一个事务修改数据之后，b也修改了这个数据，导致a的修改结果丢失</li></ul><h2 id="事务隔离级别"><a href="#事务隔离级别" class="headerlink" title="事务隔离级别"></a>事务隔离级别</h2><ul><li>读未提交 读取尚未提交的数据变更 会导致<strong>脏读 不可重读 幻读</strong></li><li>读已提交 允许读取并发事务已经提交的数据 会导致<strong>不可重读 幻读</strong></li><li>可重读 对同一字段的多次读取结果是一致的 会导致<strong>幻读</strong></li><li>可串行化 满足acid</li></ul><h2 id="InnoDB-行锁实现方式"><a href="#InnoDB-行锁实现方式" class="headerlink" title="InnoDB 行锁实现方式"></a>InnoDB 行锁实现方式</h2><ul><li><p>共享锁(s)（读锁）和排它锁(x)（写锁）</p></li><li><p>MVCC（多版本并发控制）MVCC可以在<strong>读取数据时不加锁</strong>，同时保证事务的一致性。每个事务在开始时都会生成一个唯一的事务ID，每行数据也会保存这个事务ID的版本信息。这样，即使其他事务在修改数据，当前事务也可以读取到之前版本的数据。</p></li><li><p>MVCC（多版本并发控制） 是一种<strong>并发控制机制</strong>，通过<strong>在每个数据行上维护多个版本的数据</strong>，当一个事务要对数据库中的数据进行修改的时候，MVCC会为该事务创建一个数据快照，而不是直接修改实际的数据行，用于在多个并发事务同时读写数据库时保持数据的一致性和隔离性</p></li></ul><p><strong>读操作使用旧版本数据的快照，写操作创建新版本，并确保原始版本仍然可用</strong></p><h2 id="你了解-Next-key-锁吗？"><a href="#你了解-Next-key-锁吗？" class="headerlink" title="你了解 Next-key 锁吗？"></a>你了解 Next-key 锁吗？</h2><p>Next-Key锁是一种特殊类型的锁，通常在实现范围查询时用于避免幻读（Phantom Read）问题。</p><p>Next-Key锁结合了行锁（Row Lock）和间隙锁（Gap Lock）的特性，用于确保范围查询的一致性。</p><ul><li>普通select读取的时候读取mvcc的快照</li><li>使用当前读的时候读取最新数据，并且防止其他事务在查询范围内插入数据</li></ul><h2 id="如何避免-InnoDB-中的死锁"><a href="#如何避免-InnoDB-中的死锁" class="headerlink" title="如何避免 InnoDB 中的死锁"></a>如何避免 InnoDB 中的死锁</h2><ul><li><strong>尽量使用索引</strong></li><li><strong>使用事务的隔离级别</strong></li><li>减少并发</li><li>合理设计事务</li></ul><h2 id="死锁的类型"><a href="#死锁的类型" class="headerlink" title="死锁的类型"></a>死锁的类型</h2><p>死锁是指多个事务在相互持有资源的情况下，同时等待对方释放资源</p><ul><li><p>简单死锁<br>涉及两个事务，互相等待</p></li><li><p>递归死锁<br>多个事务，循环等待</p></li><li><p>资源不足死锁<br>资源紧张的情况下，多个事务由于资源不足进入等待</p></li></ul><h2 id="如何优化数据库？"><a href="#如何优化数据库？" class="headerlink" title="如何优化数据库？"></a>如何优化数据库？</h2><ul><li>索引</li><li>分库分表: 就是将数据库中的数据分散到不同的数据库上,是对单表的数据进行拆分。</li><li>读写分离：将对数据库的读写操作分散到不同的数据库节点</li><li>数据冷热分离:根据数据的访问频率和业务重要性，将数据分为冷数据和热数据，冷数据一般存储在存储在低成本、低性能的介质中，热数据存放在高性能存储介质中。</li></ul><h2 id="数据库中的乐观锁和悲观锁，以及适用场景？"><a href="#数据库中的乐观锁和悲观锁，以及适用场景？" class="headerlink" title="数据库中的乐观锁和悲观锁，以及适用场景？"></a>数据库中的乐观锁和悲观锁，以及适用场景？</h2><ul><li><p>悲观锁：假设并发访问会导致冲突，因此在<strong>访问数据之前获取锁</strong>，以防止别的事务对数据进行修改,<strong>适用于频繁写的场景</strong>。（例如数据库中的行级锁和表级锁）</p></li><li><p>乐观锁：假设并发访问不会导致冲突，因此在访问数据时不会立即获取锁，<strong>在更新数据时检查数据是否被其他事务修改过</strong>，如果没有则进行更新，否则会进行回滚或者重试。<strong>适用于读操作多，写操作少的场景</strong></p></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;ORDER-BY、LIMIT、GROUP-BY、HAVING-这些关键字的作用&quot;&gt;&lt;a href=&quot;#ORDER-BY、LIMIT、GROUP-BY、HAVING-这些关键字的作用&quot; class=&quot;headerlink&quot; title=&quot;ORDER BY、LIMIT</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>八股文骚套路之Linux</title>
    <link href="http://www.meprotoss.com/undefined/f7999b22.html"/>
    <id>http://www.meprotoss.com/undefined/f7999b22.html</id>
    <published>2024-09-20T07:33:09.000Z</published>
    <updated>2024-09-23T09:54:13.185Z</updated>
    
    <content type="html"><![CDATA[<h2 id="inode（索引节点）"><a href="#inode（索引节点）" class="headerlink" title="inode（索引节点）"></a>inode（索引节点）</h2><p>unix系统中用于存储文件元数据的数据结构</p><p>index + node</p><p>inode就是用来维护某个文件被分成几块、每一块在的地址、文件拥有者，创建时间，权限，大小等信息。</p><h2 id="Linux常用指令"><a href="#Linux常用指令" class="headerlink" title="Linux常用指令"></a>Linux常用指令</h2><table><thead><tr><th>指令</th><th>作用</th></tr></thead><tbody><tr><td>stat</td><td>查看文件的 inode 信息</td></tr><tr><td>ln</td><td>创建硬链接</td></tr><tr><td>file</td><td>查看文件类型信息</td></tr><tr><td>tar</td><td>压缩和解压缩</td></tr><tr><td>ls -l</td><td>查看某个目录下的文件或目录的权限</td></tr><tr><td>top</td><td>查看系统的 CPU 使用率、内存使用率、进程信息等</td></tr><tr><td>systemctl</td><td>查看系统服务的状态、启动、停止、重启等</td></tr></tbody></table><h2 id="Linux获取实时刷新的日志"><a href="#Linux获取实时刷新的日志" class="headerlink" title="Linux获取实时刷新的日志"></a>Linux获取实时刷新的日志</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 实时刷新</span></span><br><span class="line"><span class="built_in">tail</span> -f logfile.log</span><br><span class="line"><span class="comment"># 每5分钟执行一次查询(watch -n 300 表示每300s执行一次后面的命令)</span></span><br><span class="line">watch -n 300 <span class="string">&#x27;tail logfile.log&#x27;</span></span><br><span class="line"></span><br><span class="line">journalctl -f</span><br></pre></td></tr></table></figure><h2 id="进程相关"><a href="#进程相关" class="headerlink" title="进程相关"></a>进程相关</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看进程</span></span><br><span class="line">ps -ef | grep xxx</span><br><span class="line"></span><br><span class="line"><span class="comment"># 杀死进程</span></span><br><span class="line"><span class="built_in">kill</span> -9 PID</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看端口号</span></span><br><span class="line">lsof -i:PORT</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看系统进程</span></span><br><span class="line">top</span><br><span class="line">ps</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看文件a的第7到9行 (head表示展示前几行，tail表示展示后几行)</span></span><br><span class="line"><span class="built_in">cat</span> a.txt | <span class="built_in">tail</span> -n +7 | <span class="built_in">head</span> -n 9</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看a.txt的第5行</span></span><br><span class="line"><span class="built_in">head</span> a.txt -n 5 | <span class="built_in">tail</span> -n 1</span><br></pre></td></tr></table></figure><h2 id="给文件夹或者文件增加权限"><a href="#给文件夹或者文件增加权限" class="headerlink" title="给文件夹或者文件增加权限"></a>给文件夹或者文件增加权限</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">chmod</span> +777</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;inode（索引节点）&quot;&gt;&lt;a href=&quot;#inode（索引节点）&quot; class=&quot;headerlink&quot; title=&quot;inode（索引节点）&quot;&gt;&lt;/a&gt;inode（索引节点）&lt;/h2&gt;&lt;p&gt;unix系统中用于存储文件元数据的数据结构&lt;/p&gt;
&lt;p&gt;index</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>八股文骚套路之测开</title>
    <link href="http://www.meprotoss.com/undefined/aec9bf64.html"/>
    <id>http://www.meprotoss.com/undefined/aec9bf64.html</id>
    <published>2024-06-23T12:07:23.000Z</published>
    <updated>2024-09-23T10:00:17.579Z</updated>
    
    <content type="html"><![CDATA[<h2 id="常用自动话测试工具"><a href="#常用自动话测试工具" class="headerlink" title="常用自动话测试工具"></a>常用自动话测试工具</h2><h3 id="Selenium"><a href="#Selenium" class="headerlink" title="Selenium"></a>Selenium</h3><p>Web自动化测试</p><h3 id="Postman"><a href="#Postman" class="headerlink" title="Postman"></a>Postman</h3><p>接口测试</p><h3 id="Jmeter"><a href="#Jmeter" class="headerlink" title="Jmeter"></a>Jmeter</h3><h3 id="Jenkins"><a href="#Jenkins" class="headerlink" title="Jenkins"></a>Jenkins</h3><h2 id="手机兼容性测试"><a href="#手机兼容性测试" class="headerlink" title="手机兼容性测试"></a>手机兼容性测试</h2><ul><li>系统兼容性</li><li>屏幕兼容性</li><li>型号兼容性</li><li>数据来源</li></ul><h2 id="软件开发流程"><a href="#软件开发流程" class="headerlink" title="软件开发流程"></a>软件开发流程</h2><ul><li>需求分析</li><li>指定测试计划</li><li>用例设计</li><li>用例执行</li><li>缺陷管理</li><li>测试报告</li></ul><h2 id="软件测试方法"><a href="#软件测试方法" class="headerlink" title="软件测试方法 *****"></a>软件测试方法 *****</h2><ol><li>软件测试方法：白盒、黑盒(功能测试)、灰盒、 静态测试、动态测试</li></ol><p>白盒测试一般可被分为<strong>静态分析</strong>和<strong>动态分析</strong>两类技术：</p><ul><li>静态分析主要有：控制流分析技术、数据流分析技术、信息流分析技术。</li><li>动态分析主要有：逻辑覆盖率测试(分支测试、路径测试等)，程序插装等。</li><li>白盒测试优点：迫使测试人员去仔细的思考软件的实现；可以检测代码中的每条分支和路径；揭示隐藏在代码中的错误；对代码的测试比较彻底</li><li>白盒测试缺点：昂贵；无法检测代码中遗漏的路径和数据敏感性错误；不验证规格的正确性。</li></ul><p>静态测试：是一种不通过执行程序而进行测试的技术。它的关键功能是检查软件的表示和描述是否一致，没有冲突或者没有歧义</p><p>动态测试：包含了程序在受控的环境下使用特定的期望结果进行正式的运行。它显示了一个系统在检查状态下是正确还是不正确。<br> 单元测试属于白盒测试范畴；集成测试属于灰盒测试范畴；系统测试属于黑盒测试范畴。</p><h2 id="CI-CD理解"><a href="#CI-CD理解" class="headerlink" title="CI&#x2F;CD理解"></a>CI&#x2F;CD理解</h2><ul><li>CI(Continuous Integration)持续集成</li></ul><p>持续集成强调开发人员提交了新代码之后，立刻进行构建、（单元）测试。根据测试结果，我们可以确定新代码和原有代码能否正确地集成在一起。<br><strong>集成</strong>是指软件个人研发的部分向软件整体部分交付，以便尽早发现个人开发部分的问题；</p><ul><li><p>CD(Continuous Delivery)持续交付<br>持续交付在持续集成的基础上，将集成后的代码部署到更贴近真实运行环境的「类生产环境」（production-like environments）中。比如，我们完成单元测试后，可以把代码部署到连接数据库的 Staging 环境中更多的测试。如果代码没有问题，可以继续手动部署到生产环境中。<br><strong>交付</strong>是指研发尽快向客户交付，以便尽早发现生产环境中存在的问题。</p></li><li><p>CD(Continuous Deployment)持续部署<br>持续部署则是在持续交付的基础上，把部署到生产环境的过程自动化。<br><strong>部署</strong>是代码尽快向可运行的开发&#x2F;测试节交付，以便尽早测试；</p></li></ul><p>所谓的<strong>持续</strong>，就是说每完成一个完整的部分，就向下个环节交付，发现问题可以马上调整。是的问题不会放大到其他部分和后面的环节。</p><h2 id="单元测试"><a href="#单元测试" class="headerlink" title="单元测试 ***"></a>单元测试 ***</h2><p>单元测试是指，对软件中的<strong>最小可测试单元</strong>在与程序其他部分相隔离的情况下进行检查和验证的工作，这里的最小可测试单元通常是指<strong>函数或者类</strong>。</p><h2 id="时间紧任务重不能加人的情况怎么尽最大努力测试"><a href="#时间紧任务重不能加人的情况怎么尽最大努力测试" class="headerlink" title="时间紧任务重不能加人的情况怎么尽最大努力测试?"></a>时间紧任务重不能加人的情况怎么尽最大努力测试?</h2><p>答：1. 不写测试用例，先和产品人员沟通覆盖主要业务，选出重要的模块先正向后逆向2. 可以使用错误推荐法<strong>根据经验复测</strong>。</p><h2 id="任何测试都应该先走业务"><a href="#任何测试都应该先走业务" class="headerlink" title="任何测试都应该先走业务"></a>任何测试都应该先走<strong>业务</strong></h2><p>而测业务需要使用场景法</p><h2 id="针对某一个产品写测试用例-性-功能-兼-用-安-稳"><a href="#针对某一个产品写测试用例-性-功能-兼-用-安-稳" class="headerlink" title="针对某一个产品写测试用例(性 功能 兼 用 安 稳)"></a>针对某一个产品写测试用例(性 功能 兼 用 安 稳)</h2><p>基本思路：可以从功能测试，UI测试，稳定性测试，压力测试（边界极限），安全测试，本地化测试等角度去考虑</p><p><strong>首先应从正向和逆向考虑功能</strong></p><h3 id="测试水杯"><a href="#测试水杯" class="headerlink" title="测试水杯 *"></a>测试水杯 *</h3><ol><li>基本功能<br>硬度、装载能力、装载种类、漏水、冷水&#x2F;热水&#x2F;冰水、保温</li><li>界面测试(UI)<br>看其形状、大小设计是否符合需求规格说明书的定义，适合人方便拿起喝水；<br>外观是否吸引人，赏心悦目；<br>广告图案沾水后是否掉色、模糊；<br>广告图案是否使用环保材料、不影响使用者健康和回收再利用；<br>广告图案是否和当地政治、宗教符合，没有冲突；<br>广告图案是否做到了本地化和国际化。</li><li>易用性测试</li><li>稳定性测试</li><li>安全性</li><li>本地化测试<br>为国际化和本地化的需要，广告图案和文字是否在政治、宗教和文化方面具有广泛的适用性；</li><li>性能测试</li></ol><h3 id="测试一个输入框-计数"><a href="#测试一个输入框-计数" class="headerlink" title="测试一个输入框(计数) **"></a>测试一个输入框(计数) **</h3><p>通常是一个登陆页面，上面有用户名，密码的输入框，再多一点的有个验证码。</p><h3 id="针对“用户登录”设计测试用例"><a href="#针对“用户登录”设计测试用例" class="headerlink" title="针对“用户登录”设计测试用例 ***"></a>针对“用户登录”设计测试用例 ***</h3><h4 id="功能测试"><a href="#功能测试" class="headerlink" title="功能测试"></a>功能测试</h4><ul><li><p>正向用例:</p><ol><li>输入已注册的用户名和正确的密码，验证是否登录成功；</li></ol></li><li><p>逆向用例：</p><ol start="2"><li>输入已注册的用户名和不正确的密码，验证是否登录失败，并且提示信息正确；</li><li>输入未注册的用户名和任意密码，验证是否登录失败，并且提示信息正确；</li><li>用户名和密码两者都为空，验证是否登录失败，并且提示信息正确；</li><li>用户名和密码两者之一为空，验证是否登录失败，并且提示信息正确；</li><li>如果登录功能启用了验证码功能，在用户名和密码正确的前提下，输入正确的验证码，验证是否登录成功；</li><li>如果登录功能启用了验证码功能，在用户名和密码正确的前提下，输入错误的验证码，验证是否登录失败，并且提示信息正确。</li></ol></li></ul><p>以上是基本的</p><ul><li><p>有经验的测试测试工程师还会增加:</p><ol><li>用户名和密码是否大小写敏感；</li><li>页面上的密码框是否加密显示；</li><li>后台系统创建的用户第一次登录成功时，是否提示修改密码；</li><li>忘记用户名和忘记密码的功能是否可用；</li><li>前端页面是否根据设计要求限制用户名和密码长度；</li><li>如果登录功能需要验证码，点击验证码图片是否可以更换验证码，更换后的验证码是否可用；</li><li>刷新页面是否会刷新验证码；</li><li>如果验证码具有时效性，需要分别验证时效内和时效外验证码的有效性；</li><li>用户登录成功但是会话超时后，继续操作是否会重定向到用户登录界面；</li><li>不同级别的用户，比如管理员用户和普通用户，登录系统后的权限是否正确；</li><li>页面默认焦点是否定位在用户名的输入框中；</li><li>快捷键Tab 和Enter等，是否可以正常使用。</li></ol></li></ul><h4 id="性能"><a href="#性能" class="headerlink" title="性能"></a>性能</h4><ol><li>单用户登录的响应时间是否小于3秒；</li><li>单用户登录时，后台请求数量是否过多；</li><li>高并发场景下用户登录的响应时间是否小于5秒；</li><li>高并发场景下服务端的监控指标是否符合预期；</li><li>高集合点并发场景下，是否存在资源死锁和不合理的资源等待；</li><li>长时间大量用户连续登录和登出，服务器端是否存在内存泄漏。</li></ol><h4 id="安全性"><a href="#安全性" class="headerlink" title="安全性"></a>安全性</h4><ol><li>用户密码后台存储是否加密；</li><li>用户密码在网络传输过程中是否加密；</li><li>密码是否具有有效期，密码有效期到期后，是否提示需要修改密码；</li><li>不登录的情况下，在浏览器中直接输入登录后的URL地址，验证是否会重新定向到用户登录界面；</li><li>密码输入框是否不支持复制和粘贴；</li><li>密码输入框内输入的密码是否都可以在页面源码模式下被查看；</li><li>用户名和密码的输入框中分别输入典型的“SQL注入攻击”字符串，验证系统的返回页面；</li><li>用户名和密码的输入框中分别输入典型的“XSS跨站脚本攻击”字符串，验证系统行为是否被篡改；</li><li>连续多次登录失败情况下，系统是否会阻止后续的尝试以应对暴力破解；</li><li>同一用户在同一终端的多种浏览器上登录，验证登录功能的互斥性是否符合设计预期；</li><li>同一用户先后在多台终端的浏览器上登录，验证登录是否具有互斥性。</li></ol><h4 id="兼容性"><a href="#兼容性" class="headerlink" title="兼容性"></a>兼容性</h4><ol><li>不同浏览器下，验证登录页面的显示以及功能正确性；</li><li>相同浏览器的不同版本下，验证登录页面的显示以及功能正确性；</li><li>不同移动设备终端的不同浏览器下，验证登录页面的显示以及功能正确性；</li><li>不同分辨率的界面下，验证登录页面的显示以及功能正确性。</li></ol><h3 id="微信红包测试用例"><a href="#微信红包测试用例" class="headerlink" title="微信红包测试用例 *****"></a>微信红包测试用例 *****</h3><p>从业务流程考虑:</p><p>单个红包：</p><ol><li>红包金额为空、0、0.01、200.00、200.01、199.99、200</li><li>留言输入数字、字母、汉字、特殊字符</li><li>留言长度</li><li>留言复制粘贴</li><li>表情选择收藏表情、其他表情</li><li>删除表情、重新选择表情</li><li>选择支付方式:零钱、银行卡、添加新卡支付。其中钱数&lt;红包钱数、其中钱数&#x3D;红包钱数、其中钱数&gt;红包钱数</li><li>使用指纹确认付款（正确的、错误的指纹）</li><li>使用密码确认付款（正确的、错误的密码）</li><li>红包成功发送后 相应支付方式中钱数减少（减少金额与红包金额一致）</li><li>接受者能看到红包具体信息，红包金额、留言、表情均能正确显示</li><li>红包被拆开后显示已领取，领取者零钱中增加正确金额，再次领取只能查看红包信息</li><li>发红包者自己领红包</li><li>红包24小时未被领取提示红包被退回，相应支付方式中钱数增加（增加金额与红包金额一致），对方不能领红包</li></ol><p>群发红包-普通红包：（只写了与单个红包不同的地方）</p><ol><li>红包个数 为空、0、001、100、99、101</li><li>红包拆开每个金额一样 均为发红包时设置的单个金额对应的钱数</li><li>红包被拆时，有相应提示</li><li>发红包者自己领红包</li><li>红包24小时内未被拆完，剩余钱被退回，相应支付方式中钱数增加</li></ol><p>群发红包-拼手气红包：</p><ol><li>红包总额&#x2F;红包个数&lt;0.01</li><li>红包每个人拆开金额不同，总金额与发红包设置的总额一致</li><li>红包24小时内拆完后显示最佳手气</li><li>红包24小时内未被拆完不显示最佳手气</li></ol><p>兼容性：安卓、苹果 不同型号版本手机</p><p>UI测试：界面无错别字，风格统一</p><p>中断测试：不同应用之间切换、断网、来电、短信、低电量、手机没电</p><p>网络测试：2g&#x2F;3g&#x2F;4g  WiFi 移动联通电信  弱网  无网</p><h3 id="微信朋友圈测试用例"><a href="#微信朋友圈测试用例" class="headerlink" title="微信朋友圈测试用例 *****"></a>微信朋友圈测试用例 *****</h3><p>当给出的功能比较笼统的时候，可以想一想这个大功能有哪些小功能 然后再考虑这些小功能的业务流程或者说使用场景逻辑，从中提取测试点，提取到测试点之后再使用等价类法、边界值法等方法设计具体的设计用例。</p><p>功能测试</p><p>1 朋友圈发送功能</p><p>1）只发送文本</p><p>a、考虑文本长度：1-1500字符（该数据为百度数据）、超出最大字符长度</p><p>b、文本是否支持复制粘贴</p><p>c、为空验证</p><p>2）只发送图片</p><p>a、本地相册选择&#x2F;拍摄</p><p>b、图片数量验证：1-9张图片、超出9张</p><p>c、为空验证</p><p>3）只发送视频</p><p>a、本地相册选择&#x2F;拍摄</p><p>b、视频秒数验证：1-10s，超出10s</p><p>c、视频个数验证：1个，超出1个</p><p>d、视频格式验证：支持的视频格式，例mp4、不支持的视频格式</p><p>e、视频大小验证：苹果400kb以内、Android200-300kb（此为百度数据）、超出规定大小</p><p>f、视频预览增删改操作</p><p>g、为空验证</p><p>4）发送文本+图片：输入满足要求的文本、图片进行一次验证</p><p>5）发送文本+视频：输入满足要求的文本、视频进行一次验证</p><p>6）发送图片+视频：不支持发送</p><p>7）朋友圈发送内容是否有限制，例如涉及黄赌毒等敏感字</p><p>8）所在位置</p><p>a、不显示位置：发送到朋友圈动态不显示位置</p><p>b、选择对应位置：搜索支持、自动定位、手动编辑</p><p>C、点击取消，返回上一级页面</p><p>9）谁可以看</p><p>a、设置公开：所有朋友可见</p><p>b、设置私密（仅自己可见）：自己查看朋友圈-可见、好友查看朋友圈-不可见</p><p>c、设置部分可见（部分朋友可见）：选择的部分好友-可见、不被选择的好友-不可见、是否有人数上限</p><p>d、设置不给谁看（选中的朋友不可见）：不被选中的朋友-可见、被选中的朋友-不可见、是否有人数上限</p><p>e、点击取消，返回发送页面</p><p>10）提醒谁看</p><p>a、提醒单人&#x2F;提醒多人：被提醒的朋友-收到消息提醒、未被提醒-未有消息提醒</p><p>b、是否有人数上限</p><p>c、点击取消，返回发送页面</p><p>11）同步QQ空间：默认不同步、同步到QQ空间</p><p>12）取消发送朋友圈操作</p><p>a、选择相机，点击取消，返回朋友圈页面</p><p>b、进入朋友圈发送页面，选择文本图片，点击取消</p><p>13）朋友圈当天发送次数是否有上限限制</p><p>2、朋友圈浏览功能</p><p>1）文本查看：</p><p>a、过长文本内容是否隐藏，并支持查看全文</p><p>b、右键选择复制、收藏、翻译</p><p>c、url链接是否支持点击跳转网页</p><p>2）图片查看</p><p>a、小图右键支持收藏&#x2F;编辑</p><p>b、点击支持大图浏览</p><p>c、选择发送给朋友、收藏、保存图片、编辑</p><p>d、多张图片支持左右滑动浏览</p><p>3）视频查看</p><p>a、右键视频支持静音播放&#x2F;搜藏</p><p>b、点击视频播放按键支持播放视频</p><p>c、选择发送给朋友、收藏、保存视频、编辑</p><p>4）分享动态浏览：QQ空间&#x2F;公众号文章&#x2F;非腾讯产品分享后朋友圈是否正常显示</p><p>5）赞：点赞、取消点赞</p><p>6）评论</p><p>a、评论长度：评论字数合理长度、评论超过字数上限</p><p>b、评论类型：纯中文、纯数字、纯字母、纯字符、纯表情（微信表情&#x2F;手机自带表情）、混合类型、包含url链接；</p><p>c、评论是否支持复制粘贴</p><p>d、为空验证</p><p>e、发表评论后删除</p><p>f、评论回复操作</p><p>7）删除朋友圈动态</p><p>8）更换相册封面</p><p>9）刷新是否正常获取新动态</p><p>10）上滑是否加载更多</p><p>界面&#x2F;易用性测试</p><p>1、技术人员角度：页面布局设计是否跟产品原型图&#x2F;ui效果图一致</p><p>2、但除了考虑1之外，我们同样要考虑到用户使用：功能操作是否简便，页面布局排版风格是否美观合理，提示语相关信息是否易于理解</p><p>中断测试</p><p>1、主要考虑：a)核心功能  b)当前功能存在实时数据交换，例发朋友圈、浏览朋友圈进行中断，是否容易出现崩溃</p><p>2、中断包括：前后台切换、锁屏解锁、断网重连、app切换、来电话&#x2F;来短信中断、插拔耳机线&#x2F;数据线</p><p>网络测试</p><p>1、三大运营商不同网络制式测试</p><p>2、网络切换测试：WIFI&#x2F;4G&#x2F;3G&#x2F;2G</p><p>3、无网测试：对于缓存在本地的数据，部分朋友圈信息是否支持浏览</p><p>4、弱网测试：</p><p>a、延时：页面响应时间是否可接受、不同网络制式是否区分超时时长、出现请求超时，是否给予相应的提示</p><p>b、丢包：有无超时重连机制、如果未响应，是否给予相应提示</p><p>c、页面呈现的完整性验证</p><p>兼容性测试</p><p>1、Android手机端、苹果手机端、pad版（主流）功能界面显示是否正常</p><p>2、各平台朋友圈展示数据是否一致</p><p>安全测试</p><p>发送朋友圈时，文本输入脚本代码，是否出现异常</p><p>性能测试</p><p>1、服务器性能测试</p><p>可通过loadrunner&#x2F;jmeter工具实现，主要关注TPS、响应时间、吞吐量、CPU、内存等</p><p>2、app客户端性能测试</p><p>可通过GT工具实现，运行时关注cpu、内存、流量、电量等占用率</p><p>3、app压力稳定性测试</p><p>通过monkey工具实现，频繁发送朋友圈，浏览朋友圈请求，是否容易发生崩溃</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;常用自动话测试工具&quot;&gt;&lt;a href=&quot;#常用自动话测试工具&quot; class=&quot;headerlink&quot; title=&quot;常用自动话测试工具&quot;&gt;&lt;/a&gt;常用自动话测试工具&lt;/h2&gt;&lt;h3 id=&quot;Selenium&quot;&gt;&lt;a href=&quot;#Selenium&quot; class=&quot;</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>暑期实习复盘</title>
    <link href="http://www.meprotoss.com/undefined/20a82735.html"/>
    <id>http://www.meprotoss.com/undefined/20a82735.html</id>
    <published>2024-06-23T06:56:33.000Z</published>
    <updated>2024-06-23T08:01:42.314Z</updated>
    
    <content type="html"><![CDATA[<h2 id="网易互娱游戏测试"><a href="#网易互娱游戏测试" class="headerlink" title="网易互娱游戏测试"></a>网易互娱游戏测试</h2><h3 id="一面-1小时"><a href="#一面-1小时" class="headerlink" title="一面(1小时)"></a>一面(1小时)</h3><ul><li><p>自我介绍</p></li><li><p>脑机接口具体研究内容</p></li><li><p>最近有玩过什么游戏吗<br>回答了街头霸王6 哈迪斯</p></li><li><p>格斗游戏小众，你喜欢玩这个游戏原因是什么</p></li><li><p>为什么格斗游戏小众，为什么没有扩展开来</p><ul><li>上手难度高，机制会比较复杂</li><li>挫败感比较强</li><li>设备成本高，缺乏便携性</li><li>兴起于街机厅</li><li>付费购买</li></ul></li><li><p>游戏中设置机器人让玩家获得正反馈，为什么格斗游戏不能这么做</p><ul><li>pve不是游戏的核心</li><li>即使有ai加持，操作模式死板，取巧攻略</li><li>人是各种各样的，随机性更强</li></ul></li><li><p>moba类游戏可以盛行的原因是什么？和格斗游戏的区别在哪里？</p><ul><li>硬件成本比较低</li><li>付费成本低，大部分免费</li><li>新手用户多，不容易被虐</li><li>社群做的很好，社交属性强</li><li>moba类游戏上手简单</li></ul></li><li><p>格斗游戏做成免费，皮肤卖钱 会有什么问题？</p><ul><li>可以尝试</li></ul></li><li><p>没有人这么干的原因</p><ul><li>制作成本比较高，圈子小 不挣钱，所以只要找准用户定位</li></ul></li><li><p>如何向年轻人推广</p><ul><li>加强键盘适配，降低硬件成本</li><li>简易出招模式</li><li>尝试手游格斗，让大家尝试一下</li></ul></li><li><p>手游最近在玩什么？</p><ul><li>穿越火线手游</li><li>爆破模式 互相配合 游戏机制有趣</li></ul></li><li><p>其他类型 和平精英玩过没？现在为什么不玩了</p><ul><li>手游fps手感不好，交互体现很好。</li></ul></li><li><p>和平精英玩的人很多，为什么会有受众群体?</p><ul><li>便携性和社交属性</li></ul></li><li><p>非腾讯系的游戏无法背靠qq 微信通讯软件，如何做社交属性的开发？</p><ul><li>利用第三方社交平台交流互动</li><li>游戏内部搭建工会 社团 世界平台</li><li>接入qq 微信的分享功能</li></ul></li><li><p>游戏内如何做交流平台 实现什么样的功能？</p><ul><li>围绕竞争和合作两个方向来做</li><li>合作方面：按流派玩法门派职业进行分类，让类似玩家进行合作和交流</li><li>竞争： pk关系 排行榜</li><li>其他的：玩家工会等等其他常见方案</li></ul></li><li><p>排行榜用什么数据结构来实现</p><ul><li>考虑到数据唯一 有序 不可重复 可使用有序表 sortedlist</li></ul></li><li><p>玩家数量很多一次性把上千万玩家放到一个list会爆内存怎么办</p><ul><li>加锁 进行并发控制</li></ul></li><li><p>指出我理解错误，意思是把所有玩家数据加载到一个list内存会放不下怎么办？</p><ul><li>内存扩容</li><li>对数据进行过滤</li></ul></li><li><p>如何做过滤</p><ul><li>做排序 然后再选区要的部分</li></ul></li><li><p>做排序还是要把数据一次性读出来，还有没有别的方案？</p><ul><li>使用一个区间进行初次过滤，筛选掉大部分玩家，然后再排序</li></ul></li><li><p>筛选区间如何设置？</p><ul><li>用统计学上的分布进行判断</li></ul></li><li><p>假设排行榜上一开始所有的数据都是0 该怎么办？</p><ul><li>没懂让再解释一下</li></ul></li><li><p>假设一开始全是0 不就没法筛选了吗？这时候怎么办?</p><ul><li>答了不会</li></ul></li><li><p>sortedlist底层实现是什么？如何保证有序的？</p><ul><li>没有深入了解过，但是我觉得应该是数组+链表</li><li>数组用来存，链表保证有序</li></ul></li><li><p>解释一下你的思路</p><ul><li>链表保存前后关系，实现类似于hashtable</li></ul></li><li><p>保证链表插入有序的时间复杂度？</p><ul><li>O(n)</li></ul></li><li><p>对一个链表进行重新排序的思路和时间复杂度</p><ul><li>没想到好方法，回答了暴力思路 😭 O(n^2)</li></ul></li><li><p>你这个时间复杂度超过了大部份常用排序算法，你为什么要用复杂度这么高的链表</p><ul><li>我说确实不太合适，得具体看业务场景，然后回答了使用链表的好处说了插入方便，不用占用连续内存空间，然后面试官就说ok了</li></ul></li><li><p>为一个函数设计测试用例：有序链表再插入一个新的值之后，仍然有序。</p><ul><li>懵逼，回答了不同位置插入；不同数据类型插入；高频词插入(面试的时候组织不起来语言，说一直插有够尴尬)</li></ul></li><li><p>反问</p></li></ul><h2 id="二面-55分钟"><a href="#二面-55分钟" class="headerlink" title="二面(55分钟)"></a>二面(55分钟)</h2><ul><li>自我介绍</li><li>为什么投这个岗位</li><li>除了这个岗位还考虑什么岗位</li><li>简历上的测试项目，项目背景等等拷打</li><li>自动化测试 web场景的思路，具体做了什么？</li><li>错误码有哪些？</li><li>为什么要做这个项目（简历上的</li><li>白盒黑盒测试相关</li><li>你觉得你网上下的项目里的项目质量怎么样，学到了什么</li><li>评价一下自己的编码能力</li><li>有大型项目经历吗？平时代码量怎么样？</li><li>手撕shell脚本 批量文件重命名（简单</li><li>为什么平时开发要用linux 脚本为什么不用python，而用shell和lua</li><li>如何调试你刚刚写的代码</li><li>做过最大型的项目是什么</li><li>论文进度？</li><li>后面就是压力面相关，加班、同事关系等等</li><li>大家对你的评价</li></ul><h2 id="hr面-很快，全程约15分钟"><a href="#hr面-很快，全程约15分钟" class="headerlink" title="hr面(很快，全程约15分钟)"></a>hr面(很快，全程约15分钟)</h2><ul><li>自我介绍</li><li>项目</li><li>项目中担任的角色</li><li>项目中遇到的最大的困难</li><li>三个关键词形容自己</li><li>加班等压力面相关</li><li>为什么选择这个岗位</li><li>了解过别的游戏公司吗</li><li>职业规划</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;网易互娱游戏测试&quot;&gt;&lt;a href=&quot;#网易互娱游戏测试&quot; class=&quot;headerlink&quot; title=&quot;网易互娱游戏测试&quot;&gt;&lt;/a&gt;网易互娱游戏测试&lt;/h2&gt;&lt;h3 id=&quot;一面-1小时&quot;&gt;&lt;a href=&quot;#一面-1小时&quot; class=&quot;headerli</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>八股文骚套路之操作系统</title>
    <link href="http://www.meprotoss.com/undefined/2d72da9e.html"/>
    <id>http://www.meprotoss.com/undefined/2d72da9e.html</id>
    <published>2024-06-09T08:46:47.000Z</published>
    <updated>2024-06-14T02:01:36.432Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://mubu.com/app/edit/home/5Vbsc1GjSNm">八股-操作系统</a></p><h2 id="内核态和用户态和系统调用"><a href="#内核态和用户态和系统调用" class="headerlink" title="内核态和用户态和系统调用"></a>内核态和用户态和系统调用</h2><p>根据进程访问资源的特点，把进程在系统上的运行分为用户态和内核态</p><p>用户态具有较低的数据访问权限，可直接读取用户程序的数据，而内核态拥有较高的权限，几乎可以访问计算机的任何资源，当应用程序需要执行某些特殊权限的操作的时候，会通过系统调用切换到内核态</p><p>把进程分为用户态和内核态是出于安全性和性能上的考虑</p><p>用户态和内核态之间的切换有系统调用、中断、异常三种方式</p><p>系统调用是主动用户态进程主动要求切换的一种方式，通过系统调用，应用程序可以和操作系统之间进行交互，访问操作系统底层资源（文件、设备、网络</p><p>中断是外部设备完成用户操作请求之后，向cpu发出中断信号，这时cpu会暂停执行吓一跳指令先去执行中断信号对应的程序，如果中断之前执行的是用户态程序，那么此时就自然而然的发生了用户态到内核态之间的切换</p><p>异常是cpu在执行用户态程序的时候，发生了不可知的异常，此时进程会切换到异常处理的内核相关程序中，也就切换到了内核态。</p><h2 id="进程和线程（重要）"><a href="#进程和线程（重要）" class="headerlink" title="进程和线程（重要）"></a>进程和线程（重要）</h2><h3 id="进程和线程的基本定义，然后再让你对比一下两者"><a href="#进程和线程的基本定义，然后再让你对比一下两者" class="headerlink" title="进程和线程的基本定义，然后再让你对比一下两者"></a>进程和线程的基本定义，然后再让你对比一下两者</h3><ul><li>进程是计算机上正在运行的一个程序的实例</li><li>线程也被称为轻量级进程,是进程被划分为更小的运行单位。</li><li>一个程序至少有一个进程，一个进程至少有一个线程</li><li>进程和进程之间不共享资源是独立的，线程和线程之间共享同一个进程的资源,且有可能互相影响</li></ul><h3 id="进程和线程的状态"><a href="#进程和线程的状态" class="headerlink" title="进程和线程的状态"></a>进程和线程的状态</h3><p>我们一般把进程大致分为 5 种状态，这一点和线程很像,</p><ol><li>创建状态(new)：进程正在被创建</li><li>就绪状态(ready)：进程已处于准备运行状态，即进程获得了除了处理器之外的一切所需资源，一旦得到处理器资源(处理器分配的时间片)即可运行</li><li>运行状态(running)</li><li>阻塞状态(waiting)：又称为等待状态，进程正在等待某一事件而暂停运行如等待某资源为可用或等待 IO 操作完成。即使处理器空闲，该进程也不能运行。</li><li>结束状态(terminated)</li></ol><h2 id="内存管理（重要）"><a href="#内存管理（重要）" class="headerlink" title="内存管理（重要）"></a>内存管理（重要）</h2><h3 id="内存管理的目的、逻辑和物理地址"><a href="#内存管理的目的、逻辑和物理地址" class="headerlink" title="内存管理的目的、逻辑和物理地址"></a>内存管理的目的、逻辑和物理地址</h3><ul><li>内存的分配与回收：对进程所需的内存进行分配和释放，malloc 函数：申请内存，free 函数：释放内存。</li><li>地址转换：将程序中的虚拟地址转换成内存中的物理地址。</li><li>内存扩充：当系统没有足够的内存时，利用虚拟内存技术或自动覆盖技术，从逻辑上扩充内存。</li><li>内存映射：将一个文件直接映射到进程的进程空间中，这样可以通过内存指针用读写内存的办法直接存取文件内容，速度更快。</li><li>内存优化：通过调整内存分配策略和回收算法来优化内存使用效率。</li><li>内存安全：保证进程之间使用内存互不干扰，避免一些恶意程序通过修改内存来破坏系统的安全性。</li></ul><h3 id="内存管理机制"><a href="#内存管理机制" class="headerlink" title="内存管理机制"></a>内存管理机制</h3><ul><li><p>连续内存管理：为一个用户程序分配一个连续的内存空间，内存利用率一般不高。容易产生内存碎片</p></li><li><p>非连续内存管理：允许一个程序使用的内存分布在离散或者说不相邻的内存中，相对更加灵活一些。</p></li></ul><h3 id="虚拟内存和请求分页"><a href="#虚拟内存和请求分页" class="headerlink" title="虚拟内存和请求分页"></a>虚拟内存和请求分页</h3><p>虚拟内存(Virtual Memory)本质上来说它只是逻辑存在的，是一个假想出来的内存空间<br>它允许程序访问比实际物理内存更大的内存空间。<br>在使用虚拟内存的系统中，每个程序都认为它拥有连续的、私有的内存空间，这被称为虚拟地址空间</p><p>**<br>  虚拟内存的主要主要作用：<br>**</p><ul><li>隔离进程：物理内存通过虚拟地址空间访问，虚拟地址空间与进程一一对应。每个进程都认为自己拥有了整个物理内存，进程之间彼此隔离，一个进程中的代码无法更改正在由另一进程或操作系统使用的物理内存。</li><li>提升物理内存利用率：有了虚拟地址空间后，操作系统只需要将进程当前正在使用的部分数据或指令加载入物理内存。</li><li>简化内存管理：进程都有一个一致且私有的虚拟地址空间，程序员不用和真正的物理内存打交道，而是借助虚拟地址空间访问物理内存，从而简化了内存管理。</li><li>多个进程共享物理内存：进程在运行过程中，会加载许多操作系统的动态库。这些库对于每个进程而言都是公用的，它们在内存中实际只会加载一份，这部分称为共享内存。</li><li>提高内存使用安全性：控制进程对物理内存的访问，隔离不同进程的访问权限，提高系统的安全性。</li><li>提供更大的可使用内存空间：可以让程序拥有超过系统物理内存大小的可用内存空间。<br>这是因为<strong>当物理内存不够用时，可以利用磁盘充当</strong>，将物理内存页（通常大小为 4 KB）保存到磁盘文件（会影响读写速度），数据或代码页会根据需要在物理内存与磁盘之间移动。</li></ul><p><strong>局部性原理</strong>是指在程序执行过程中，数据和指令的访问存在一定的空间和时间上的局部性特点。其中，时间局部性是指一个数据项或指令在一段时间内被反复使用的特点，空间局部性是指一个数据项或指令在一段时间内与其相邻的数据项或指令被反复使用的特点。</p><ul><li>请求分页 ： 页表机制、缺页中断、页面置换算法</li></ul><h2 id="虚拟地址和物理地址"><a href="#虚拟地址和物理地址" class="headerlink" title="虚拟地址和物理地址"></a>虚拟地址和物理地址</h2><p>虚拟地址是程序开发时程序员与程序员进行交互的地址<br>物理地址就是内存地址寄存器中真正的地址</p><p>MMU(memeory management unit)将虚拟地址转化为物理地址,这个过程称之为<strong>地址转换</strong></p><p>而地址转换有两种方式:</p><p><strong>分段机制</strong>和<strong>分页机制</strong></p><p>分段机制以一段连续的物理内存管理（不同长度的段）和分配物理内存，通过段表来映射虚拟地址和物理地址</p><p>分页机制把物理内存分为<strong>连续等长</strong>的物理页，通过页表来映射地址,虚拟地址空间中的任意虚拟页可以被映射到任意的物理页上，所以可以实现物理内存资源的离散分配</p><h2 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h2><p>多个进程&#x2F;线程同时被阻塞，它们中的一个或者全部都在等待某个资源被释放。由于进程&#x2F;线程被无限期地阻塞，因此程序不可能正常终止。</p><h3 id="死锁的必要条件"><a href="#死锁的必要条件" class="headerlink" title="死锁的必要条件"></a>死锁的必要条件</h3><p>互斥、占有并等待、非抢占（资源不能被抢占，只能完成任务之后主动释放、循环等待</p><h3 id="死锁预防、避免、检测与解除"><a href="#死锁预防、避免、检测与解除" class="headerlink" title="死锁预防、避免、检测与解除"></a>死锁预防、避免、检测与解除</h3><p>预防死锁的方法，是通过考虑破坏第二个条件和第四个条件。</p><ol><li>静态分配策略静态分配策略破坏死锁产生的第二个条件（占有并等待）。<br>静态分配策略，指一个进程必须在执行前就申请到它所需要的全部资源，并且知道它所要的资源都得到满足之后才开始执行。进程要么占有所有的资源然后开始执行，要么不占有资源。静态分配策略逻辑简单，实现也很容易，但这种策略 严重地降低了资源利用率，</li><li>层次分配策略破坏了产生死锁的第四个条件(循环等待)。所有的资源被分成了多个层次，一个进程得到某一次的一个资源后，它只能再申请较高一层的资源；当一个进程要释放某层的一个资源时，必须先释放所占用的较高层的资源，这样不会发生循环等待。</li></ol><p>常用的解除死锁的方法有以下四种：</p><ol><li>立即结束所有进程的执行，重新启动操作系统</li><li>撤销涉及死锁的所有进程，解除死锁后继续运行</li><li>逐个撤销涉及死锁的进程，回收其资源直至死锁解除。</li><li>抢占资源：从涉及死锁的一个或几个进程中抢占资源，把夺得的资源再分配给涉及死锁的进程直至死锁解除。</li></ol><h2 id="CPU-调度"><a href="#CPU-调度" class="headerlink" title="CPU 调度"></a>CPU 调度</h2><h3 id="几种常见的-CPU-调度算法"><a href="#几种常见的-CPU-调度算法" class="headerlink" title="几种常见的 CPU 调度算法"></a>几种常见的 CPU 调度算法</h3><ul><li>先到先服务调度(First-Come First-Served Scheduling，FCFS)</li><li>最短作业优先调度(Shortest Job First，SJF)</li><li>优先级调度（Priority Scheduling）</li><li>轮转法调度(Round Robin，RR)</li></ul><p>多级队列调度（Multilevel Queue） 就诞生了。简单来说就是把就绪队列（存放有待执行进程）分成多个独立队列，每个队列都有自己的调度算法。</p><h2 id="Linux相关（重要）"><a href="#Linux相关（重要）" class="headerlink" title="Linux相关（重要）"></a>Linux相关（重要）</h2><h3 id="Linux-常用命令"><a href="#Linux-常用命令" class="headerlink" title="Linux 常用命令"></a>Linux 常用命令</h3><p>1.cd 切换目录，2.mkdir创建目录,3.mv移动或重命名 ,4.cp复制, 5.touch 创建文件 7.find查找8.cat&#x2F;tail&#x2F;head&#x2F;less查看  9.ps-ef查看进程 10.ifconfig 查看ip地址 11.rm删除</p><ul><li><p>file:file通过探测文件内容判断文件类型，使用权限是所有用户</p></li><li><p>grep:grep命令可以指定文件中搜索特定内容，并将含有这些内容的行标准输出</p></li><li><p>tar：对文件进行打包，调用gzip或bzip对文件进行压缩或解压</p></li><li><p>查看进程：ps -ef|grep 进程id  【ps:将某个进程显示出来 -A 　显示所有程序。  -e 　此参数的效果和指定”A”参数相同。 -f 　显示UID,PPIP,C与STIME栏位。】</p></li><li><p>杀死叫firefox的进程：ps aux| grep firefox | awk ‘{print $2}’ |xargs kill  *</p></li></ul><p>xargs 命令是用来把前面命令的输出结果(PID)作为“kill -s 9”命令的参数，并执行该命令</p><p>$pkill -９ firefox *说明：pkill＝pgrep+kill，”-9” 即发送的信号是9，</p><p>pkill与kill在这点的差别是：pkill无须 “ｓ”，终止信号等级直接跟在 “-“ 后面</p><p>pgrep的p表明了这个命令是专门用于进程查询的grep</p><p>查看端口号: netstat –tunlp|grep 端口号或lsof -i:端口号</p><h3 id="如何查看Linux系统进程？"><a href="#如何查看Linux系统进程？" class="headerlink" title="如何查看Linux系统进程？"></a>如何查看Linux系统进程？</h3><p>通过ps命令可以查看当前系统运行的进程的列表，包括PID，进程名，CPU占用百分比，内存占用等信息。</p><p>可以使用top命令来查看Linux系统正在运行的进程。</p><h3 id="如何查看a-txt的第7到第9行？"><a href="#如何查看a-txt的第7到第9行？" class="headerlink" title="如何查看a.txt的第7到第9行？"></a>如何查看a.txt的第7到第9行？</h3><ul><li><p>cat a.txt | tail -n +7 | head -n 9</p></li><li><p>sed -n ‘7,9p’ a.txt</p></li></ul><h3 id="查看文件a-txt的前3行"><a href="#查看文件a-txt的前3行" class="headerlink" title="查看文件a.txt的前3行"></a>查看文件a.txt的前3行</h3><p>cat a.txt | head -n 3 或 head a.txt -n 3 (后3行用tail)</p><h3 id="查看文件a-txt，显示第50行到第200行"><a href="#查看文件a-txt，显示第50行到第200行" class="headerlink" title="查看文件a.txt，显示第50行到第200行"></a>查看文件a.txt，显示第50行到第200行</h3><pre><code>cat a.txt | head -n 200 | tail -n +50tail -n +50：从50行开始显示，显示50行以后的head -n 200：显示前面200行</code></pre><h3 id="查看a-txt文件的第5行"><a href="#查看a-txt文件的第5行" class="headerlink" title="查看a.txt文件的第5行"></a>查看a.txt文件的第5行</h3><pre><code>awk &#39;NR==5&#39; a.txthead -n 5 a.txt | tail -n 1sed -n 5p</code></pre><h3 id="一个文件中字段以逗号隔开，如何查看某一列的所有的数据？"><a href="#一个文件中字段以逗号隔开，如何查看某一列的所有的数据？" class="headerlink" title="一个文件中字段以逗号隔开，如何查看某一列的所有的数据？"></a>一个文件中字段以逗号隔开，如何查看某一列的所有的数据？</h3><pre><code>awk -F[,] &#39;&#123;print $10&#125;&#39;</code></pre><h3 id="如何查看程序运行时的某个端口？"><a href="#如何查看程序运行时的某个端口？" class="headerlink" title="如何查看程序运行时的某个端口？"></a>如何查看程序运行时的某个端口？</h3><pre><code>lsof -i :&lt;端口号&gt;</code></pre><h3 id="Linux-文件系统"><a href="#Linux-文件系统" class="headerlink" title="Linux 文件系统"></a>Linux 文件系统</h3><p>常见目录说明：</p><ul><li>&#x2F;bin： 存放二进制可执行文件(ls、cat、mkdir 等)，常用命令一般都在这里；</li><li>&#x2F;etc： 存放系统管理和配置文件；</li><li>&#x2F;home： 存放所有用户文件的根目录，是用户主目录的基点，比如用户 user 的主目录就是&#x2F;home&#x2F;user，可以用~user 表示；</li><li>&#x2F;usr： 用于存放系统应用程序；</li><li>&#x2F;opt： 额外安装的可选应用程序包所放置的位置。一般情况下，我们可以把 tomcat 等都安装到这里；</li><li>&#x2F;proc： 虚拟文件系统目录，是系统内存的映射。可直接访问这个目录来获取系统信息；</li><li>&#x2F;root： 超级用户（系统管理员）的主目录（特权阶级^o^）；</li><li>&#x2F;sbin: 存放二进制可执行文件，只有 root 才能访问。这里存放的是系统管理员使用的系统级别的管理命令和程序。如 ifconfig 等；</li><li>&#x2F;dev： 用于存放设备文件；</li><li>&#x2F;mnt： 系统管理员安装临时文件系统的安装点，系统提供这个目录是让用户临时挂载其他的文件系统；</li><li>&#x2F;boot： 存放用于系统引导时使用的各种文件；</li><li>&#x2F;lib 和&#x2F;lib64： 存放着和系统运行相关的库文件 ；</li><li>&#x2F;tmp： 用于存放各种临时文件，是公用的临时文件存储点；</li><li>&#x2F;var： 用于存放运行时需要改变数据的文件，也是某些大文件的溢出区，比方说各种服务的日志文件（系统启动日志等。）等；</li><li>&#x2F;lost+found： 这个目录平时是空的，系统非正常关机而留下“无家可归”的文件（windows 下叫什么.chk）就在这里。</li></ul><h3 id="僵尸进程和孤儿进程"><a href="#僵尸进程和孤儿进程" class="headerlink" title="僵尸进程和孤儿进程"></a>僵尸进程和孤儿进程</h3><ul><li><p>僵尸进程：子进程已经终止，担父进程仍然在运行，而且父进程没有调用wait或waitpid等系统调用来释放子进程占用的资源。这种情况下的子进程称为僵尸进程</p></li><li><p>孤儿进程：父进程没了，但是子进程仍然在运行</p></li></ul><p>Linux可以通过top指令来查看僵尸进程，zombie的值标识僵尸进程的数量</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;a href=&quot;https://mubu.com/app/edit/home/5Vbsc1GjSNm&quot;&gt;八股-操作系统&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;内核态和用户态和系统调用&quot;&gt;&lt;a href=&quot;#内核态和用户态和系统调用&quot; class=&quot;headerlink&quot; tit</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>八股文骚套路之数据结构</title>
    <link href="http://www.meprotoss.com/undefined/faaf69f9.html"/>
    <id>http://www.meprotoss.com/undefined/faaf69f9.html</id>
    <published>2024-06-09T08:40:58.000Z</published>
    <updated>2024-09-21T02:43:27.150Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://mubu.com/app/edit/home/1cv82aWbhSC">八股数据结构</a></p><h2 id="b树和b-树的区别"><a href="#b树和b-树的区别" class="headerlink" title="b树和b+树的区别"></a>b树和b+树的区别</h2><ul><li>存储方式: 节点存什么东西？（数据 索引）</li><li>节点指针: B树中的节点包含指向子节点的指针，而B+树中的内部节点只包含键值和指向下一级节点的指针 <strong>不包含指向具体数据的指针</strong>。所有的数据都存储在叶子节点中，通过叶子节点的链表顺序访问数据。</li><li>范围查询: 由于B+树的叶子节点形成了有序链表，所以在B+树上进行范围查询非常高效，只需要遍历叶子节点的链表即可</li><li>使用场景: b树节点包含数据，适用于随机访问；b+树叶子节点形成有序链表，适用于顺序访问和范围查询</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;a href=&quot;https://mubu.com/app/edit/home/1cv82aWbhSC&quot;&gt;八股数据结构&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;b树和b-树的区别&quot;&gt;&lt;a href=&quot;#b树和b-树的区别&quot; class=&quot;headerlink&quot; title=&quot;b树和</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>八股文骚套路之计算机网络</title>
    <link href="http://www.meprotoss.com/undefined/101a7be.html"/>
    <id>http://www.meprotoss.com/undefined/101a7be.html</id>
    <published>2024-06-09T08:34:15.000Z</published>
    <updated>2024-09-20T09:03:09.470Z</updated>
    
    <content type="html"><![CDATA[<p>面试过程中偏向与应用，所以问的比较多的也就是应用层、运输层、网络层的协议，物理层和数据链路层的东西面试基本不会被问到，所以准备面试过程中这块就不用看了。<br><a href="https://mubu.com/app/edit/home/4IsX074ceSC">八股-网络协议</a></p><h2 id="OSI七层模型"><a href="#OSI七层模型" class="headerlink" title="OSI七层模型"></a>OSI七层模型</h2><p>物理层 数据链路层 网络层 传输层 会话层 表示层 应用层</p><p>物理层 数据链路层 网络层 传输层 应用层</p><h2 id="在搜索框输入www-baidu-com，发生了什么？"><a href="#在搜索框输入www-baidu-com，发生了什么？" class="headerlink" title="在搜索框输入www.baidu.com，发生了什么？"></a>在搜索框输入<a href="http://www.baidu.com，发生了什么？">www.baidu.com，发生了什么？</a></h2><ol><li>在浏览器中输入指定网页的 URL。</li><li>浏览器通过 DNS 协议，获取域名对应的 IP 地址。</li><li>浏览器根据 IP 地址和端口号，向目标服务器发起一个 TCP 连接请求。</li><li>TCP连接建立之后，浏览器在 TCP 连接上，向服务器发送一个 HTTP 请求报文，请求获取网页的内容。</li><li>服务器收到 HTTP 请求报文后，处理请求，并返回 HTTP 响应报文给浏览器。</li><li>浏览器收到 HTTP 响应报文后，解析响应体中的 HTML 代码，渲染网页的结构和样式，同时根据 HTML 中的其他资源的 URL（如图片、CSS、JS 等），再次发起 HTTP 请求，获取这些资源的内容，直到网页完全加载显示。</li><li>浏览器在不需要和服务器通信时，可以主动关闭 TCP 连接，或者等待服务器的关闭请求。</li></ol><h2 id="http-和-https-的区别"><a href="#http-和-https-的区别" class="headerlink" title="http 和 https 的区别"></a>http 和 https 的区别</h2><h3 id="http"><a href="#http" class="headerlink" title="http"></a>http</h3><ul><li>超文本传输协议</li><li>明文传输</li><li>基于请求和响应</li><li>无状态</li><li>应用层协议</li><li>端口80</li></ul><h3 id="https"><a href="#https" class="headerlink" title="https"></a>https</h3><ul><li>http + ssl&#x2F;tls</li><li>具有加密性质的SSL加密传输协议</li><li>由http通信</li><li>利用ssl&#x2F;tls建立信道</li><li>端口443</li><li>需要证书</li></ul><h2 id="详细介绍一下ssl-TLS"><a href="#详细介绍一下ssl-TLS" class="headerlink" title="详细介绍一下ssl&#x2F;TLS"></a>详细介绍一下ssl&#x2F;TLS</h2><p>运行在TCP上，加密采用对称加密</p><h3 id="什么是对称加密"><a href="#什么是对称加密" class="headerlink" title="什么是对称加密"></a>什么是对称加密</h3><p>通信双方共享唯一密钥K 加解密算法已知 相比非对称加密 代价小 但是安全性较低</p><h2 id="http-请求报文"><a href="#http-请求报文" class="headerlink" title="http 请求报文"></a>http 请求报文</h2><ul><li>请求方法</li><li>GET: 请求<strong>获取</strong>request——URL所标识的资源</li><li>POST：在Request——URL所标识的资源后附加资源(向指定的资源<strong>提交</strong>要被处理的数据)</li><li>HEAD：请求获取由Request——URL所标识的资源的响应消息报头</li><li>PUT：请求服务器存储一个资源，由Request——URL作为其标识  </li><li>DELETE：请求服务器删除由Request——URL所标识的资源</li><li>TRACE：请求服务器回送收到的请求信息（用于测试和诊断）</li><li>CONNECT：保留</li><li>OPTIONS：请求查询服务器性能</li></ul><h2 id="http-状态码"><a href="#http-状态码" class="headerlink" title="http 状态码"></a>http 状态码</h2><p>状态码是用于表示网页服务器HTTP响应状态的3位数字代码</p><p>1xx:请求被成功接收<br>2xx:请求被成功处理<br>3xx:重定向相关<br>4xx:客户端错误<br>5xx:服务器端错误</p><h2 id="TCP-和-UDP-的区别"><a href="#TCP-和-UDP-的区别" class="headerlink" title="TCP 和 UDP 的区别"></a>TCP 和 UDP 的区别</h2><ul><li>面向连接:传输数据之前是否要建立连接</li><li>可靠传输:收到报文之后是否需要确认，是否需要保证数据的不丢失和顺序到达</li><li>是否有状态:是否记录自己发送的消息被接受了等等</li><li>传输效率:</li><li>传输形式:tcp面向字节流，udp面向报文</li><li>首部开销:</li><li>广播或多播:tcp只支持点对点，udp支持一对一一对多多对一</li></ul><h2 id="tcp为什么可靠"><a href="#tcp为什么可靠" class="headerlink" title="tcp为什么可靠"></a>tcp为什么可靠</h2><ul><li>确认和重传机制:建立连接时三次握手同步双方的“序列号 + 确认号 + 窗口大小信息”，是确认重传、流控的基础</li><li>数据排序:TCP有专门的序列号SN字段，可提供数据re-order</li><li>流量控制:滑动窗口和计时器的使用。TCP窗口中会指明双方能够发送接收的最大数据量，发送方通过维持一个发送滑动窗口来确保不会发生由于发送方报文发送太快接收方无法及时处理的问题。</li><li>拥塞控制:TCP的拥塞控制由4个核心算法组成:“慢启动” “拥塞避免”  “快速重传 ”  “快速恢复”</li></ul><h2 id="cookie-和-session-的区别"><a href="#cookie-和-session-的区别" class="headerlink" title="cookie 和 session 的区别"></a>cookie 和 session 的区别</h2><pre><code>cookie和session都是会话技术，cookie是运行在客户端，session是运行在服务器端cookie有安全隐患，通过拦截或本地文件找得到你的cookie后可以进行攻击session是保存在服务器端上会存在一段时间后消失，如果session过多会增加服务器的压力</code></pre><h2 id="IP-地址和-Mac-地址的区别，了解-ARP-地址解析协议并了解其工作原理"><a href="#IP-地址和-Mac-地址的区别，了解-ARP-地址解析协议并了解其工作原理" class="headerlink" title="IP 地址和 Mac 地址的区别，了解 ARP 地址解析协议并了解其工作原理"></a>IP 地址和 Mac 地址的区别，了解 ARP 地址解析协议并了解其工作原理</h2><p>互联网中的每一个资源都有一个ip地址，而一切网络设备都有一个唯一mac地址 ,ip地址是一种不重复的定位方式</p><p>mac地址是永久的，而ip可能会随着网络的更换而变化</p><p>arp(address resolution protocol)地址解析协议。解决了ip地址转mac地址的问题</p><h2 id="建立连接TCP三次握手和断开连接TCP四次挥手"><a href="#建立连接TCP三次握手和断开连接TCP四次挥手" class="headerlink" title="建立连接TCP三次握手和断开连接TCP四次挥手"></a>建立连接TCP三次握手和断开连接TCP四次挥手</h2><h3 id="三次握手"><a href="#三次握手" class="headerlink" title="三次握手"></a>三次握手</h3><p>第一次握手<br>    建立连接时，客户端发送syn包（syn&#x3D;j）到服务器，并进入SYN_SENT状态，等待服务器确认。SYN：同步序列编号(客户端发送同步请求等待服务器确认)<br>第二次握手<br>    服务器收到SYN包，必须确认客户的SYN(ack&#x3D;j+1),同时自己也发送一个SYN包(syn&#x3D;k)，即SYN+ACK包，此时服务器进入SYN_RECV状态(服务器收到请求同意建立连接，告诉客户端自己同意)<br>第三次握手<br>    客户端收到服务器的SYN+ACK包，向服务器发送确认包ACK(ACK&#x3D;K+1)，此包发送完毕，客户端和服务器进入ESTABLISHED（TCP连接成功）状态(客户端告诉服务端自己知道你同意了于是开启了连接，)</p><h3 id="为什么要三次握手"><a href="#为什么要三次握手" class="headerlink" title="为什么要三次握手?"></a>为什么要三次握手?</h3><p>主要就是用来确认自己和对方的接受和发送都正常</p><ol><li>第一次握手：Client 什么都不能确认；Server 确认了对方发送正常，自己接收正常</li><li>第二次握手：Client 确认了：自己发送、接收正常，对方发送、接收正常；Server 确认了：对方发送正常，自己接收正常</li><li>第三次握手：Client 确认了：自己发送、接收正常，对方发送、接收正常；Server 确认了：自己发送、接收正常，对方发送、接收正常</li></ol><h3 id="四次挥手"><a href="#四次挥手" class="headerlink" title="四次挥手"></a>四次挥手</h3><p>断开一个 TCP 连接则需要“四次挥手”，缺一不可：</p><p>第一次挥手：客户端发送一个 FIN（SEQ&#x3D;x） 标志的数据包-&gt;服务端，用来关闭客户端到服务端的<strong>数据传送</strong>。然后客户端进入 FIN-WAIT-1 状态。<br>第二次挥手：服务端收到这个 FIN（SEQ&#x3D;X） 标志的数据包，它发送一个 ACK （ACK&#x3D;x+1）标志的数据包-&gt;客户端 。然后服务端进入 CLOSE-WAIT 状态，客户端进入 FIN-WAIT-2 状态。<br>第三次挥手：服务端发送一个 FIN (SEQ&#x3D;y)标志的数据包-&gt;客户端，请求关闭连接，然后服务端进入 LAST-ACK 状态。<br>第四次挥手：客户端发送 ACK (ACK&#x3D;y+1)标志的数据包-&gt;服务端，然后客户端进入TIME-WAIT状态，服务端在收到 ACK (ACK&#x3D;y+1)标志的数据包后进入 CLOSE 状态。此时如果客户端等待 2MSL 后依然没有收到回复，就证明服务端已正常关闭，随后客户端也可以关闭连接了</p><p>第一次挥手：A 说“我没啥要说的了”<br>第二次挥手：B 回答“我知道了”，但是 B 可能还会有要说的话，A 不能要求 B 跟着自己的节奏结束通话<br>第三次挥手：于是 B 可能又巴拉巴拉说了一通，最后 B 说“我说完了”<br>第四次挥手：A 回答“知道了”，这样通话才算结束。</p><h2 id="DNS域名系统"><a href="#DNS域名系统" class="headerlink" title="DNS域名系统"></a>DNS域名系统</h2><p>DNS 要解决的是域名和 IP 地址的映射问题。</p><p>DNS域名服务器分为四种：本地、权威、顶级、根</p><p>DNS有两种查询解析方法：迭达和递归</p><p>常用的方法是从请求主机到本地 DNS 服务器的查询是递归的，其余的查询时迭代的。</p><h2 id="UDP如何实现可靠传输"><a href="#UDP如何实现可靠传输" class="headerlink" title="UDP如何实现可靠传输"></a>UDP如何实现可靠传输</h2><p>UDP实现可靠传输,其实是借鉴TCP可靠传输的策略</p><h3 id="常见的可靠传输策略"><a href="#常见的可靠传输策略" class="headerlink" title="常见的可靠传输策略"></a>常见的可靠传输策略</h3><ol><li>ACK机制</li><li>重传机制</li><li>序号机制</li><li>重排机制</li><li>窗口机制</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;面试过程中偏向与应用，所以问的比较多的也就是应用层、运输层、网络层的协议，物理层和数据链路层的东西面试基本不会被问到，所以准备面试过程中这块就不用看了。&lt;br&gt;&lt;a href=&quot;https://mubu.com/app/edit/home/4IsX074ceSC&quot;&gt;八股-网</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>八股文骚套路之JVM</title>
    <link href="http://www.meprotoss.com/undefined/3fe50e69.html"/>
    <id>http://www.meprotoss.com/undefined/3fe50e69.html</id>
    <published>2024-06-08T08:17:53.000Z</published>
    <updated>2024-08-21T13:38:03.053Z</updated>
    
    <content type="html"><![CDATA[<h2 id="运行时数据区中包含哪些区域？哪些线程共享？哪些线程独享？【⭐⭐⭐⭐⭐】"><a href="#运行时数据区中包含哪些区域？哪些线程共享？哪些线程独享？【⭐⭐⭐⭐⭐】" class="headerlink" title="运行时数据区中包含哪些区域？哪些线程共享？哪些线程独享？【⭐⭐⭐⭐⭐】"></a>运行时数据区中包含哪些区域？哪些线程共享？哪些线程独享？【⭐⭐⭐⭐⭐】</h2><p>JDK1.7之前的运行时数据区包括 堆、方法区、虚拟机栈、本地方法栈、程序计数器<br>其中堆和方法区是线程共享的；虚拟机栈、本地方法栈和程序计数器是线程私有的。<br>Jdk1.8之后 方法区的实现变成了元空间，和运行时常量池一起被放到了本地内存</p><h3 id="程序计数器"><a href="#程序计数器" class="headerlink" title="程序计数器"></a>程序计数器</h3><p>可以看作当前线程所执行的字节码文件的行号指示器，实现代码的流程控制，还需要能让线程切换之后能恢复到正确的执行位置，自然是线程私有的</p><h3 id="虚拟机栈"><a href="#虚拟机栈" class="headerlink" title="虚拟机栈"></a>虚拟机栈</h3><p>除了一些本地方法是在本地方法栈中实现，其他所有java方法的调用都通过虚拟机栈实现的。<br>栈由一个个栈帧组成，每一个方法调用的时候都会有一个栈帧被压入虚拟机栈中，每个栈帧中都保存着局部变量表、操作数栈、动态链接和方法的返回地址。</p><h4 id="局部变量表"><a href="#局部变量表" class="headerlink" title="局部变量表"></a>局部变量表</h4><p>主要存储编译期间的基本数据类型和对象引用(是指向对象起始地址的引用指针)</p><h4 id="操作数栈"><a href="#操作数栈" class="headerlink" title="操作数栈"></a>操作数栈</h4><p>用于存放方法执行过程中产生的中间计算结果。</p><h4 id="动态链接"><a href="#动态链接" class="headerlink" title="动态链接"></a>动态链接</h4><p>主要用于一个方法需要调用其余方法的场景，当一个方法要去调用其他方法，就需要把常量池里指向方法的符号引用转化为内存地址中的直接引用。</p><h3 id="本地方法栈"><a href="#本地方法栈" class="headerlink" title="本地方法栈"></a>本地方法栈</h3><p>和虚拟机栈类似，只是里面存的是Native方法</p><h3 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h3><p>用来存放对象实例，几乎所有的对象实例和数组都在这里分配内存</p><h2 id="说一下方法区和永久代的关系"><a href="#说一下方法区和永久代的关系" class="headerlink" title="说一下方法区和永久代的关系"></a>说一下方法区和永久代的关系</h2><p>方法区是JVM运行时的数据区域的一块逻辑区域，是各个线程共享的内存区域，它是一个逻辑概念，定义规则。</p><p>而永久代则是方法区的一个具体实现方式，Jdk1.8之后方法区的实现变成了元空间，被放到了本地内存里</p><h3 id="Java-创建一个对象的过程。【⭐⭐⭐⭐】"><a href="#Java-创建一个对象的过程。【⭐⭐⭐⭐】" class="headerlink" title="Java 创建一个对象的过程。【⭐⭐⭐⭐】"></a>Java 创建一个对象的过程。【⭐⭐⭐⭐】</h3><p>类加载检查：首先，再Java中使用new关键字创建对象的时候，首先要加载对象的类。如果类未被加载，那么JVM会使用类加载器(这里有一个双亲委派机制)加载并初始化该类</p><p>分配内存空间:类加载完成之后，JVM会在堆中为对象分配内存空间。分配内存的方式有指针碰撞和空闲列表两种，选择哪种分配方式取决于Java堆内存是否规整。</p><p>连接：接下来，JVM会把对象里的普通成员变量初始化为0值。这一步操作主要是保证对象里面的实例字段不用初始化就可以直接使用。</p><p>设置对象头： 然后，JVM还需要对对象的对象头做一些设置，比如对象所属的类元信息、对象的GC分代年龄、hashCode、锁标记等。</p><p>执行<init>方法：JVM调用对象的构造函数，对对象的属性进行赋值和其他初始化操作</p><p>最后，JVM会返回对象的引用</p><h2 id="对象的访问定位的两种方式【⭐⭐⭐⭐⭐】"><a href="#对象的访问定位的两种方式【⭐⭐⭐⭐⭐】" class="headerlink" title="对象的访问定位的两种方式【⭐⭐⭐⭐⭐】"></a>对象的访问定位的两种方式【⭐⭐⭐⭐⭐】</h2><p>一般有两种方式:</p><ol><li>句柄(堆中划分出一个句柄池，栈中的引用指向句柄地址，然后句柄中包含了对象的实例数据和类型数据的地址)</li><li>直接指针(栈中的引用直接指向实例数据的地址，如果访问对象本身的话，就不用多一次访问开销，而对象的类型数据的指针存放在方法区中，如果定位的话，需要多一次直接定位开销)</li></ol><p>使用句柄最大的好处就是引用中存储的是句柄地址，对象移动时只需改变句柄的地址就可以，而无需改变对象本身。</p><p>使用直接指针来访问速度更快，它节省了一次指针定位的时间开销，因为对象访问在 Java 中非常频繁。</p><h2 id="你了解分代理论吗？讲一下-Minor-GC、还有-Full-GC-⭐⭐⭐⭐⭐"><a href="#你了解分代理论吗？讲一下-Minor-GC、还有-Full-GC-⭐⭐⭐⭐⭐" class="headerlink" title="你了解分代理论吗？讲一下 Minor GC、还有 Full GC ⭐⭐⭐⭐⭐"></a>你了解分代理论吗？讲一下 Minor GC、还有 Full GC ⭐⭐⭐⭐⭐</h2><p>Java中的自动内存隔离主要是针对的堆内存中对象的分配和回收。</p><p>在Jdk1.7之前 堆内存通常分为 新生代 老年代 和永久代，Jdk8之后永久代被元空间取代，元空间使用的是直接内存</p><p>大多数情况下，对象优先在新生代中的eden区中分配(大对象直接进入老年代)，当eden区空间不足的时候，JVM会进行一次minorGC,经过一次minorGC的对象会被分配到survivor区，如果survivor区放不下，那么会通过分配担保机制提前移动到老年代去，如果仍能存活且能被survivor容纳的话，会被移动到survivor空间。且年龄+1<br>当年龄增加到阈值的时候，就会晋升到老年代中。</p><p>minorGC是partial GC 的一种，只对新生代进行垃圾收集</p><h2 id="Java-用什么方法确定哪些对象该被清理？-讲一下可达性分析算法的流程。【⭐⭐⭐⭐】"><a href="#Java-用什么方法确定哪些对象该被清理？-讲一下可达性分析算法的流程。【⭐⭐⭐⭐】" class="headerlink" title="Java 用什么方法确定哪些对象该被清理？ 讲一下可达性分析算法的流程。【⭐⭐⭐⭐】"></a>Java 用什么方法确定哪些对象该被清理？ 讲一下可达性分析算法的流程。【⭐⭐⭐⭐】</h2><ul><li>引用计数法<br>给对象添加一个引用计数器，每当有一个地方引用，计数器就+1；当引用失效，计数器就-1；引用计数器为0的对象就是不可能再被使用的</li></ul><p>但是这个方法没法解决对象间的循环引用问题</p><ul><li>可达性分析算法</li></ul><p>通过一系列的称为 “GC Roots” 的对象作为起点，从这些节点开始向下搜索，节点所走过的路径称为引用链，当一个对象到 GC Roots 没有任何引用链相连的话，则证明此对象是不可用的，需要被回收。</p><h2 id="JDK-中有几种引用类型？分别的特点是什么？【⭐⭐】"><a href="#JDK-中有几种引用类型？分别的特点是什么？【⭐⭐】" class="headerlink" title="JDK 中有几种引用类型？分别的特点是什么？【⭐⭐】"></a>JDK 中有几种引用类型？分别的特点是什么？【⭐⭐】</h2><ol><li><p>强引用<br>表示必不可少。垃圾回收器绝不会回收它。当内存空间不足，Java 虚拟机宁愿抛出 OutOfMemoryError 错误，使程序异常终止，也不会靠随意回收具有强引用的对象来解决内存不足问题。</p></li><li><p>软引用（SoftReference）<br>表示可有可无。如果内存空间足够，垃圾回收器就不会回收它，如果内存空间不足了，就会回收这些对象的内存。</p></li><li><p>弱引用（WeakReference）<br>表示可有可无。弱引用与软引用的区别在于：弱引用的生命周期更短，在垃圾回收器线程扫描它所管辖的内存区域的过程中，一旦发现了只具有弱引用的对象，不管当前内存空间足够与否，都会回收它的内存。</p></li><li><p>虚引用<br>表示形同虚设，任何时候都可能被垃圾回收</p></li></ol><h2 id="如何回收方法区？【⭐⭐⭐】"><a href="#如何回收方法区？【⭐⭐⭐】" class="headerlink" title="如何回收方法区？【⭐⭐⭐】"></a>如何回收方法区？【⭐⭐⭐】</h2><p>主要有两种方法：</p><ol><li>类卸载：当一个类不再被引用，即没有任何对象实例引用该类，且该类的类加载器已经被回收时，JVM 可以卸载这个类。类卸载会导致该类在方法区中所占用的内存被释放，从而实现方法区的回收。</li><li>常量池回收：在方法区中的运行时常量池中存储着类信息、常量、静态变量等数据。常量池的大小是有限的，当常量池用尽时，JVM 会对常量池进行回收。常量池回收通常是通过 Full GC（Full Garbage Collection）来实现的。</li></ol><h2 id="标记清除、标记复制、标记整理分别是怎样清理垃圾的？各有什么优缺点？【⭐⭐⭐⭐⭐】"><a href="#标记清除、标记复制、标记整理分别是怎样清理垃圾的？各有什么优缺点？【⭐⭐⭐⭐⭐】" class="headerlink" title="标记清除、标记复制、标记整理分别是怎样清理垃圾的？各有什么优缺点？【⭐⭐⭐⭐⭐】"></a>标记清除、标记复制、标记整理分别是怎样清理垃圾的？各有什么优缺点？【⭐⭐⭐⭐⭐】</h2><ol><li><p>标记清除<br>首先<strong>标记出所有不需要回收</strong>的对象，标记完之后回收所有没有标记的对象<br>优点是简单，缺点是效率不高，容易产生大量不连续的内存碎片</p></li><li><p>标记复制<br><strong>将内存分为大小相同的两块，每次使用其中的一块</strong>，当内存使用完之后，<strong>把还存活的对象复制到另外一块，然后再把前面的空间一次性清理掉</strong><br>优点是解决了内存碎片问题<br>缺点是可用内存变小，而且如果存活的对象表较大，复制的效率也会很低所以不适合老年代</p></li><li><p>标记整理算法<br>标记所有不需要回收的对象，然后<strong>让所有存活的对象向一端移动</strong>，然后直接清理掉端边界外的内存<br>优点是减少了内存碎片，缺点是多了整理的这一步，效率不高</p></li><li><p>分代收集算法<br>根据新生代和老年代的特点，选择上述三个中适合的垃圾收集算法</p></li></ol><h2 id="JVM-中的安全点和安全区各代表什么？写屏障你了解吗？【⭐⭐⭐⭐】"><a href="#JVM-中的安全点和安全区各代表什么？写屏障你了解吗？【⭐⭐⭐⭐】" class="headerlink" title="JVM 中的安全点和安全区各代表什么？写屏障你了解吗？【⭐⭐⭐⭐】"></a>JVM 中的安全点和安全区各代表什么？写屏障你了解吗？【⭐⭐⭐⭐】</h2><p>在执行GC的时候，所有的工作线程都必须停顿，安全点就代表在这个点的时候，所有线程的工作状态是确定的，JVM可以安全的执行GC</p><p>安全点是对正在执行的线程设定的。如果一个线程处于 Sleep 或中断状态，它就不能响应 JVM 的中断请求，再运行到 Safe Point 上。</p><p>安全区是指在一段代码片段中，引用关系不会发生变化。在这个区域内的任意地方开始 GC 都是安全的。</p><h2 id="TODO-并发标记要解决什么问题？并发标记带来了什么问题？如何解决并发扫描时对象消失问题？⭐⭐⭐⭐"><a href="#TODO-并发标记要解决什么问题？并发标记带来了什么问题？如何解决并发扫描时对象消失问题？⭐⭐⭐⭐" class="headerlink" title="TODO:并发标记要解决什么问题？并发标记带来了什么问题？如何解决并发扫描时对象消失问题？⭐⭐⭐⭐"></a>TODO:并发标记要解决什么问题？并发标记带来了什么问题？如何解决并发扫描时对象消失问题？⭐⭐⭐⭐</h2><h2 id="新生代垃圾收集器有哪些？老年代垃圾收集器有哪些？哪些是单线程垃圾收集器，哪些是多线程垃圾收集器？各有什么特点？各基于哪一种垃圾收集算法？【⭐⭐⭐⭐】"><a href="#新生代垃圾收集器有哪些？老年代垃圾收集器有哪些？哪些是单线程垃圾收集器，哪些是多线程垃圾收集器？各有什么特点？各基于哪一种垃圾收集算法？【⭐⭐⭐⭐】" class="headerlink" title="新生代垃圾收集器有哪些？老年代垃圾收集器有哪些？哪些是单线程垃圾收集器，哪些是多线程垃圾收集器？各有什么特点？各基于哪一种垃圾收集算法？【⭐⭐⭐⭐】"></a>新生代垃圾收集器有哪些？老年代垃圾收集器有哪些？哪些是单线程垃圾收集器，哪些是多线程垃圾收集器？各有什么特点？各基于哪一种垃圾收集算法？【⭐⭐⭐⭐】</h2><p>如果说收集算法是内存回收的方法论，那么垃圾收集器就是内存回收的具体实现。</p><ol><li><p>Serial 串行收集器是单线程的垃圾收集器，新生代采用标记复制算法 老年代采用标记整理算法 缺点是执行GC的时候需要stop the world 优点是简单高效</p></li><li><p>ParNew 收集器是Serial收集器的多线程版本 新生代采用标记-复制算法，老年代采用标记-整理算法。</p></li><li><p>Parallel Scavenge 收集器也是用标记-复制算法的垃多线程收集器，它更加关注如何提高吞吐量 新生代采用标记-复制算法，老年代采用标记-整理算法。</p></li><li><p>Serial Old 收集器，是serial收集器的老年版本,是单线程的 与 Parallel Scavenge 收集器搭配使用</p></li><li><p>Parallel Old 收集器 是Parallel Scavenge 收集器的老年代版本，使用多线程和“标记整理”算法，在注重吞吐量以及 CPU 资源的场合，都可以优先考虑 Parallel Scavenge 收集器和 Parallel Old 收集器。</p></li><li><p>CMS(Concurrent Mark Sweep 并发标记清除) 并发收集器，可以让用户进程和垃圾回收同时进行 ，基于标记清除算法</p></li></ol><p>有4个步骤：</p><ul><li>初始标记：暂停所有其他线程，并记录下与root相连的对象</li><li>并发标记：同时开启GC和用户线程，用一个闭包结构去记录可达对象，用这个算法去跟踪记录用户进的执行导致可达对象更新的地方</li><li>重新标记：把并发标记期间用户程序继续运行导致的标记变动的那一部分对象进行标记和记录</li><li>并发清除：开启用户线程，同时 GC 线程开始对未标记的区域做清扫。<br>优点：并发收集，停顿少，用户体验好<br>缺点：对CPU的压力比较大；无法处理浮动垃圾；基于标记清楚算法会产生大量的内存碎片</li></ul><ol start="7"><li>G1 (Garbage-First) 面向服务器的垃圾收集器，内存得大，cpu性能得牛逼 也是默认的垃圾收集器，G1 收集器的运作大致分为以下几个步骤：</li></ol><ul><li>初始标记</li><li>并发标记</li><li>最终标记</li><li>筛选回收<br>特点：</li><li>充分利用并行和并发，既可以使用多个cpu来缩短stop the world 的时间，又可以通过并发使得Java程序在gc期间继续执行</li><li>分代收集</li><li>空间整合 整体上是基于标记整理算法，但是局部上基于标记复制算法</li><li>可以预测停顿的时间</li></ul><h2 id="讲一下内存分配策略？【⭐⭐⭐⭐】"><a href="#讲一下内存分配策略？【⭐⭐⭐⭐】" class="headerlink" title="讲一下内存分配策略？【⭐⭐⭐⭐】"></a>讲一下内存分配策略？【⭐⭐⭐⭐】</h2><p>常见的内存分配策略有两种<br>第一种：对象优先在Eden区进行分配，当Eden区满了之后，进行一次minorGC(新生代垃圾回收)，仍然存活的对象被移动到survivor区或老年代<br>第二种：如果对象大小超过了一定的阈值，那么JVM会自动将其分配到老年代，因为大对象往往拥有较长的生命周期，直接分配到老年代可以减少在新生代的复制操作<br>第三种：长期存活的对象今日老年代，JVM给每个对象一个年龄计数器，在eden区的对象经过一次minorGC之后如果仍然存活会被移动到survivor区，且年龄+1；后续在survivor区每经历一次minorGC，年龄就+1，直到达到阈值默认为15，就会被移动到老年代。<br>第四种：动态对象年龄判定，如果survivor区中相同年龄的对象的总内存超过survivor空间一半，年龄大于等于这个年龄的对象可直接进入老年代。</p><h3 id="空间分配担保机制"><a href="#空间分配担保机制" class="headerlink" title="空间分配担保机制"></a>空间分配担保机制</h3><p>minorGC之前，需要检查老年代可用空间是否足够容纳新生代所有对象。如果够的话说明minorGC是安全的。</p><h2 id="虚拟机基础故障处理工具有哪些？【⭐⭐⭐】"><a href="#虚拟机基础故障处理工具有哪些？【⭐⭐⭐】" class="headerlink" title="虚拟机基础故障处理工具有哪些？【⭐⭐⭐】"></a>虚拟机基础故障处理工具有哪些？【⭐⭐⭐】</h2><p>jstat: 监视虚拟机各种运行状态信息</p><p>jinfo: 实时地查看和调整虚拟机各项参数</p><p>jmap:生成堆转储快照</p><p>jhat: 分析 heapdump 文件</p><p>jstack :生成虚拟机当前时刻的线程快照</p><h2 id="什么是字节码？类文件结构的组成了解吗？【⭐⭐⭐⭐】"><a href="#什么是字节码？类文件结构的组成了解吗？【⭐⭐⭐⭐】" class="headerlink" title="什么是字节码？类文件结构的组成了解吗？【⭐⭐⭐⭐】"></a>什么是字节码？类文件结构的组成了解吗？【⭐⭐⭐⭐】</h2><p>JVM可以理解的代码称为字节码</p><p>类文件结构有魔数、class文件版本号、常量池、访问标识、当前类、父类、字段表、方法表、属性表</p><h2 id="类的生命周期？类加载的过程了解么？加载这一步主要做了什么事情？初始化阶段中哪几种情况必须对类初始化？【⭐⭐⭐⭐⭐】"><a href="#类的生命周期？类加载的过程了解么？加载这一步主要做了什么事情？初始化阶段中哪几种情况必须对类初始化？【⭐⭐⭐⭐⭐】" class="headerlink" title="类的生命周期？类加载的过程了解么？加载这一步主要做了什么事情？初始化阶段中哪几种情况必须对类初始化？【⭐⭐⭐⭐⭐】"></a>类的生命周期？类加载的过程了解么？加载这一步主要做了什么事情？初始化阶段中哪几种情况必须对类初始化？【⭐⭐⭐⭐⭐】</h2><p>类从被加载到JVM内存开始到卸载出内存，生命周期主要有7个阶段：加载、验证、准备、解析、初始化、使用、卸载，其中验证、准备和解析三个阶段统称为连接</p><p>系统加载类文件主要有三步：加载 连接和初始化</p><p>加载这一步首先是通过全类名获取定义此类的二进制字节流；其次将字节流代表的静态存储结构转化为方法区的运行时数据结构;然后在内存中生成一个代表该类的class对象作为数据的访问入口</p><p>初始化阶段有6种情况必须对类进行初始化</p><ol><li>当遇到 new、 getstatic、putstatic 或 invokestatic 这 4 条字节码指令时</li><li>对类进行反射调用时</li><li>初始化一个类，如果其父类还未初始化，则先触发该父类的初始化。</li><li>当虚拟机启动时，虚拟机需要定义一个主类，这个主类需要被初始化</li><li>MethodHandle 和 VarHandle 可以看作是轻量级的反射调用机制，而要想使用这 2 个调用，就必须先使用 findStaticVarHandle 来初始化要调用的类。</li><li>当一个接口中定义了被default关键字修饰的接口方法的时候，如果有这个接口的实现类发生了初始化，那该接口要在其之前被初始化。</li></ol><h2 id="讲一下双亲委派模型。【⭐⭐⭐⭐⭐】"><a href="#讲一下双亲委派模型。【⭐⭐⭐⭐⭐】" class="headerlink" title="讲一下双亲委派模型。【⭐⭐⭐⭐⭐】"></a>讲一下双亲委派模型。【⭐⭐⭐⭐⭐】</h2><p>类加载器有很多种：启动类加载器，扩展类加载器、应用程序类加载器等等，双亲委派模型就是用来确定具体用哪一个类加载器加载。<br>它是这样运作的，每当一个类加载器接到加载请求的时候，系统会判断当前类是否被加载过，如果加载过就直接返回，否则才会尝试加载；进行类加载的时候，会先把这个请求委派给父类的加载器，这样依次类推，所有的请求都会最终传送到顶层的启动类加载器；只有当父类加载器没有找到所需要的类的时候，子加载器才会自己尝试加载；如果最终子类加载器也无法加载这个类，会抛出classnotfoundexception异常</p><p>双亲委派模型的好处是可以避免类的重复加载，保证Java的核心API不被修改</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;运行时数据区中包含哪些区域？哪些线程共享？哪些线程独享？【⭐⭐⭐⭐⭐】&quot;&gt;&lt;a href=&quot;#运行时数据区中包含哪些区域？哪些线程共享？哪些线程独享？【⭐⭐⭐⭐⭐】&quot; class=&quot;headerlink&quot; title=&quot;运行时数据区中包含哪些区域？哪些线程共享？哪</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>八股文骚套路之Java集合</title>
    <link href="http://www.meprotoss.com/undefined/2ca694ee.html"/>
    <id>http://www.meprotoss.com/undefined/2ca694ee.html</id>
    <published>2024-06-08T07:04:20.000Z</published>
    <updated>2024-06-14T02:28:33.209Z</updated>
    
    <content type="html"><![CDATA[<h2 id="集合概述"><a href="#集合概述" class="headerlink" title="集合概述"></a>集合概述</h2><p>Java集合，也叫容器主要有两大接口派生而来</p><ul><li>Collection<ul><li>List(列表):有序可重复<ul><li>ArrayList</li><li>Vector</li><li>LinkedList(双向链表)</li></ul></li><li>Set(集合)：不可重复&#x2F;唯一<ul><li>HashSet(无序唯一)<ul><li>LinkedHashSet:底层使用LinkedHashMap实现</li></ul></li><li>TreeSet(有序唯一)：红黑树(自平衡排序二叉树)</li></ul></li><li>Queue(队列)：特定的排序规则，有序可重复</li></ul></li><li>Map(映射 可以多对一，不能一对多)<ul><li>HashMap：JdK1.8之前是数组+链表，JdK1.8之后在链表长度大于阈值8的时候会将链表转化为红黑树以减少搜索时间，但是在转化之前还会判断当前的哈希桶数组(用来存键值对的数组)的长度是不是小于64，如果不是，那么会先对数组进行扩容。<ul><li>LinkedHashMap:在HashMap的基础上增加了一条双向链表，使HashMap的结构可以保持键值对的插入顺序</li></ul></li><li>Hashtable</li><li>SortedMap</li></ul></li></ul><blockquote><p>[!TIP]<br>在 HashMap 中，主要有一个用于存储键值对的数组，这个数组被称为“哈希桶数组”或“Entry 数组”。在 JDK 1.8 之前，HashMap 的底层数据结构由一个数组 + 链表组成。数组的每个元素（称为桶或者 Entry）都是一个链表的头节点，每个节点存储一个键值对。当发生哈希冲突时，具有相同哈希值的键值对会被放置在同一个桶中，通过链表形式串联在一起。</p></blockquote><h3 id="如何选用集合？"><a href="#如何选用集合？" class="headerlink" title="如何选用集合？"></a>如何选用集合？</h3><ul><li><p>需要根据键值获取元素则选Map接口下的集合，需要排序则用TreeMap，不需要排序则选HashMap，需要线程安全就用ConcurrentHashMap,尽量不用HashTable</p></li><li><p>当只需要存放元素值的时候选用Collection接口的集合，需要唯一用Set接口下的集合，比如TreeSet和HashSet，不需要就用List下的接口比如ArrayList和LinkedList。</p></li></ul><h3 id="ArrayList-数组列表-和-Array（数组）的区别？"><a href="#ArrayList-数组列表-和-Array（数组）的区别？" class="headerlink" title="ArrayList(数组列表) 和 Array（数组）的区别？"></a>ArrayList(数组列表) 和 Array（数组）的区别？</h3><p>ArrayList 内部基于动态数组实现，比 Array（静态数组） 使用起来更加灵活</p><ul><li>ArrayList可以动态地扩容或缩容，而 Array 被创建之后就不能改变它的长度了。</li><li>ArrayList 允许你使用泛型来确保类型安全，Array 则不可以。</li><li>ArrayList 中只能存储对象。对于基本类型数据，基本数据类型要使用包装类。Array 可以直接存储基本类型数据，也可以存储对象。</li><li>ArrayList 支持插入、删除、遍历等常见操作，并且提供了丰富的 API 操作方法，比如 add()、remove()等。Array 只是一个固定长度的数组，只能按照下标访问其中的元素，不具备动态添加、删除元素的能力。</li><li>ArrayList创建时不需要指定大小，而Array创建时必须指定大小。</li></ul><h3 id="ArrayList-与-LinkedList-区别"><a href="#ArrayList-与-LinkedList-区别" class="headerlink" title="ArrayList 与 LinkedList 区别?"></a>ArrayList 与 LinkedList 区别?</h3><p>两者都是线程不安全的</p><p>然后记住ArrayList 采用数组存储 LinkedList 采用链表存储,再根据底层数据结构从插入删除元素，随机访问，内存空间占用上展开来将就行</p><h2 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h2><h3 id="Comparable-和-Comparator-的区别"><a href="#Comparable-和-Comparator-的区别" class="headerlink" title="Comparable 和 Comparator 的区别"></a>Comparable 和 Comparator 的区别</h3><p>Comparable 接口和 Comparator 接口都是 Java 中用于排序的接口, 用于在类对象之间比较大小、排序</p><p>一般我们需要对一个集合使用自定义排序时，我们就要重写compareTo()方法或compare()方法</p><h3 id="无序性和不可重复性的含义是什么"><a href="#无序性和不可重复性的含义是什么" class="headerlink" title="无序性和不可重复性的含义是什么"></a>无序性和不可重复性的含义是什么</h3><ul><li><p>无序性指的是存储的数据在底层数组中的顺序不是按照数组索引的顺序添加，而是根据数据的哈希值决定</p></li><li><p>不可重复性指 equals() 判断的时候返回false，所以需要同时重写equals方法和hashcode方法</p></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;集合概述&quot;&gt;&lt;a href=&quot;#集合概述&quot; class=&quot;headerlink&quot; title=&quot;集合概述&quot;&gt;&lt;/a&gt;集合概述&lt;/h2&gt;&lt;p&gt;Java集合，也叫容器主要有两大接口派生而来&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Collection&lt;ul&gt;
&lt;li&gt;List(列表</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>八股文骚套路之Java基础</title>
    <link href="http://www.meprotoss.com/undefined/df1beea2.html"/>
    <id>http://www.meprotoss.com/undefined/df1beea2.html</id>
    <published>2024-06-04T13:30:42.000Z</published>
    <updated>2024-06-24T08:41:28.450Z</updated>
    
    <content type="html"><![CDATA[<p>⭐ ：面试中不常问到，如果面试官问到尽量能答出来，答不出来也没关系。<br>⭐⭐ ：面试中不常问到，但是如果面试官问到的话，答不出来对你的印象会减分。<br>⭐⭐⭐：面试中会问到，答不出来面试有点悬。面试官会惊讶为什么你这也不会。<br>⭐⭐⭐⭐：面试高频考点。<br>⭐⭐⭐⭐⭐：面试超高频考点。四星考点和五星考点是参加十场面试，至少能有五场面试问到这些的。大家在准备面试过程中尽量把这些知识点的回答条理梳理清楚，面试官一问就开背。</p><h2 id="🆗Java-语言的特点⭐️⭐️"><a href="#🆗Java-语言的特点⭐️⭐️" class="headerlink" title="🆗Java 语言的特点⭐️⭐️"></a>🆗Java 语言的特点⭐️⭐️</h2><ul><li>语法简单，上手容易</li><li>面向对象(封装 继承 多态)</li><li>Java 虚拟机实现了 Java 语言的跨平台性</li><li>支持多线程</li><li>可靠(异常处理和自动内存管理机制)、安全(多重安全防护机制如访问权限修饰符、限制程序直接访问操作系统资源)</li><li>高效性(预编译等技术)</li><li>支持网络编程</li><li>编译与解释并存</li></ul><h2 id="🆗比较-JVM-和-JDK-以及-JRE-⭐️⭐️⭐️"><a href="#🆗比较-JVM-和-JDK-以及-JRE-⭐️⭐️⭐️" class="headerlink" title="🆗比较 JVM 和 JDK 以及 JRE ⭐️⭐️⭐️"></a>🆗比较 JVM 和 JDK 以及 JRE ⭐️⭐️⭐️</h2><ul><li>JVM(Java Virtual Machine) Java 虚拟机是运行 Java 字节码的虚拟机</li><li>JDK(Java Development Kit) Java 开发工具包，提供 Java 的开发环境，<strong>包含 JRE</strong></li><li>JRE(Java Runtime Environment)  Java 运行时环境，包含 JVM 和一些核心类库<br>总结： JDK 包含了 JRE 和开发工具， JRE 包含了 JVM 和核心类库</li></ul><h2 id="🆗为什么说-Java-解释与编译并存-⭐️⭐️"><a href="#🆗为什么说-Java-解释与编译并存-⭐️⭐️" class="headerlink" title="🆗为什么说 Java 解释与编译并存 ⭐️⭐️"></a>🆗为什么说 Java 解释与编译并存 ⭐️⭐️</h2><ul><li>高级编程语言按照程序的执行方式分为编译型和解释型</li><li>编译型是通过编译器一次性将源码翻译为机器码，而解释型是通过解释器逐句将代码解释为机器码再执行。</li><li>Java 程序执行需要先由编译器编译为字节码 .class 文件,再由 Java 解释器解释执行。</li></ul><h2 id="🆗Java-基本类型有哪几种，各占多少位？⭐️⭐️"><a href="#🆗Java-基本类型有哪几种，各占多少位？⭐️⭐️" class="headerlink" title="🆗Java 基本类型有哪几种，各占多少位？⭐️⭐️"></a>🆗Java 基本类型有哪几种，各占多少位？⭐️⭐️</h2><p>基本类型有8种</p><p>6种数字类型：</p><ul><li><p>4种整型:byte short int long (分别为8 16 32 64)</p></li><li><p>2种浮点型:float double(分别为32 64)</p></li><li><p>1种字符型：char(16)</p></li><li><p>1种布尔型：boolean(8)</p></li></ul><h2 id="🆗Java中的泛型和类型擦除-⭐️⭐️⭐️"><a href="#🆗Java中的泛型和类型擦除-⭐️⭐️⭐️" class="headerlink" title="🆗Java中的泛型和类型擦除 ⭐️⭐️⭐️"></a>🆗Java中的泛型和类型擦除 ⭐️⭐️⭐️</h2><p>泛型是Java的一个新特性，可以用来增强可读性和稳定性。<br>Java编译器可以对泛型参数进行检测，可以指定传入对象的泛型<br>泛型一般有三种使用方式：泛型类、泛型接口、泛型方法<br>但是泛型是语法糖的一种，Java虚拟机里没有泛型，只有普通类和普通方法，Java虚拟机会在编译阶段通过类型擦除的方式进行解语法糖，类型擦除就是将所有的泛型参数用其最顶级的父类进行替换。</p><h3 id="🆗既然编译器要将泛型擦除，那为什么还要使用泛型，用Object代替不行吗？-使用泛型的好处"><a href="#🆗既然编译器要将泛型擦除，那为什么还要使用泛型，用Object代替不行吗？-使用泛型的好处" class="headerlink" title="🆗既然编译器要将泛型擦除，那为什么还要使用泛型，用Object代替不行吗？(使用泛型的好处)"></a>🆗既然编译器要将泛型擦除，那为什么还要使用泛型，用Object代替不行吗？(使用泛型的好处)</h3><ol><li>使用泛型可在编译期前进行类型检测。</li><li>使用 Object 类型需要手动添加强制类型转换，降低代码可读性，提高出错概率。</li></ol><h2 id="🆗-和-equals-的区别⭐️⭐️⭐️"><a href="#🆗-和-equals-的区别⭐️⭐️⭐️" class="headerlink" title="🆗&#x3D;&#x3D; 和 equals() 的区别⭐️⭐️⭐️"></a>🆗&#x3D;&#x3D; 和 equals() 的区别⭐️⭐️⭐️</h2><p>这两者对于基本类型和引用类型的效果是不同的</p><ul><li>对于基本数据类型，&#x3D;&#x3D; 比较的是值；对于引用数据类型，&#x3D;&#x3D;比较的是内存地址</li></ul><p>因为在Java中只有值传递，所以本质上来说 &#x3D;&#x3D; 比较的就是值。</p><ul><li>equals()不能用来判断<strong>基本数据类</strong>的变量，只能用来判断两个<strong>对象</strong>是否相等，这有两种情况：第一种是没有重写equals方法，那么默认比较的是两个对象的地址，等同于&#x3D;&#x3D;；但是一般会重写equals方法来判断两个对象的属性是否相等,若属性相等则返回true认为两个对象相等</li></ul><h2 id="🆗hashCode-和-equals-⭐⭐⭐⭐"><a href="#🆗hashCode-和-equals-⭐⭐⭐⭐" class="headerlink" title="🆗hashCode() 和 equals() ⭐⭐⭐⭐"></a>🆗hashCode() 和 equals() ⭐⭐⭐⭐</h2><p>hashCode是用来获取散列码，用来确定对象在hash表中的索引位置，帮助快速找到所需要的对象。<br>当把对象加入hashset，hashset会先计算当前对象的哈希值来确定该对象加入的位置，同时也会将这个哈希值和已经加入对象的哈希值作比较，如果没有一样的，hashset会假设这个对象没有重复出现。但是如果发现有相同的哈希值的对象，则更进一步用equals方法来检查两个对象是不是真的相同。如果相同那么就不会让这个对象加入；如果不同，那么会重新将这个对象散列到其他位置。这样可以大大减少equals方法的执行速度。</p><ul><li>重写equals的时候必须重写hashcode()方法，因为hashcode相等是两个对象相等的必要不充分条件。</li></ul><h2 id="🆗重载和重写的区别⭐⭐⭐⭐"><a href="#🆗重载和重写的区别⭐⭐⭐⭐" class="headerlink" title="🆗重载和重写的区别⭐⭐⭐⭐"></a>🆗重载和重写的区别⭐⭐⭐⭐</h2><ul><li>重载是同一个类中多个同名方法，根据输入参数的数据类型或者数量的不同，作出不同的处理</li><li>重写是子类继承父类的相同方法时，输入数据是一样的，但是需要作出不同于父类的处理，比如功能的扩展之类的，需要覆盖父类的方法(重写发生在运行时,可以改变内部逻辑，但是外部的样子不能改变)</li></ul><h2 id="🆗深拷贝和浅拷贝"><a href="#🆗深拷贝和浅拷贝" class="headerlink" title="🆗深拷贝和浅拷贝"></a>🆗深拷贝和浅拷贝</h2><ul><li>深拷贝会完全复制整个对象，包括这个对象的内部对象。</li><li>浅拷贝会在堆上创建一个新的对象，但是如果对象内部是引用类型的话，不会拷贝内部对象，而是拷贝内部对象的地址引用</li><li>引用拷贝则是只拷贝引用地址</li></ul><h2 id="成员变量和局部变量的区别⭐️⭐️⭐️"><a href="#成员变量和局部变量的区别⭐️⭐️⭐️" class="headerlink" title="成员变量和局部变量的区别⭐️⭐️⭐️"></a>成员变量和局部变量的区别⭐️⭐️⭐️</h2><ul><li>成员变量是属于类的，而局部变量是在代码块或方法中定义的变量或是方法的参数；成员变量可以被访问控制修饰符修饰，局部变量不能；但是两者都可以被final修饰。</li><li>生命周期上，成员变量是对象的一部分，生命周期和对象一致，而局部变量是方法的，随着方法的调用和调用结束产生和消亡</li><li>默认值:成员变量如果没被赋值那么会有默认值(final修饰的成员变量必须显示赋值)；而局部变量不会被自动赋值。</li></ul><h2 id="面向对象三大特性是什么。并解释这三大特性。⭐️⭐️⭐️⭐️"><a href="#面向对象三大特性是什么。并解释这三大特性。⭐️⭐️⭐️⭐️" class="headerlink" title="面向对象三大特性是什么。并解释这三大特性。⭐️⭐️⭐️⭐️"></a>面向对象三大特性是什么。并解释这三大特性。⭐️⭐️⭐️⭐️</h2><ul><li>三大特性是封装、继承和多态</li></ul><p>封装是把一个对象的属性隐藏在对象内部，不允许外部对象直接访问对象的内部信息</p><ul><li>继承</li></ul><ol><li>子类继承父类对象所有的属性和方法，但是父类中的私有属性和方法子类只是拥有不能访问。</li><li>子类可以对父类的属性和方法进行扩展(子承父业，发扬广大)</li><li>子类可以重写(overwrite)父类的方法, 在其基础之上实现功能的扩展</li></ol><ul><li>多态</li></ul><p>一个对象拥有多种状态，父类的引用指向子类的实现</p><ol><li>对象类型和引用类型之间存在继承&#x2F;实现接口的关系；</li><li>引用类型变量发出的方法调用的到底是哪个类中的方法，必须到程序运行时才能确定;3. 多态不能调用“只在子类中有，但是父类中没有的”的方法；</li><li>如果子类重写了父类的方法，真正执行的是子类中重写的方法，如果子类没有重写父类的方法，执行的是父类的方法。(就近原则)</li></ol><h2 id="String、StringBuffer-和-StringBuilder-的区别。-⭐⭐⭐⭐"><a href="#String、StringBuffer-和-StringBuilder-的区别。-⭐⭐⭐⭐" class="headerlink" title="String、StringBuffer 和 StringBuilder 的区别。 ⭐⭐⭐⭐"></a>String、StringBuffer 和 StringBuilder 的区别。 ⭐⭐⭐⭐</h2><p>从可变性上来说，String是不可变的。而StringBuffer和StringBuilder是继承于AbstractStringBuilder类，虽然三者都是用字符数组保存字符串,但AbstractStringBuilder 中没有使用final 和private关键字修饰，而且还提供了许多修改字符串的方法(比如append等等)</p><p>从线程安全性上来说，String中的对象是不变的，所以线程安全（可理解为常量<br>而StringBuffer虽然可变，但是对AbstractStringBuilder中的方法添加了同步锁，所以线程安全<br>而StringBuilder没有加锁，所以线程不安全</p><h2 id="Java异常⭐️⭐️⭐️"><a href="#Java异常⭐️⭐️⭐️" class="headerlink" title="Java异常⭐️⭐️⭐️"></a>Java异常⭐️⭐️⭐️</h2><p>Java中，所有的异常都有一个共同的祖先Throwable类，这个类主要有两个重要的子类</p><p>Exception 和 Error</p><ul><li>Exception 是程序本身可以处理的异常，可以通过catch来捕获。<ul><li>Exception又可以分为 Checked Exception可检异常(必须要处理)和Unchecked Exception不可检异常(可以不处理)</li><li>可检异常有：ClassNotFoundException(加载不存在的类时抛出的异常)、SQLException(与数据库交互时候的抛出的异常)、IOException(输入输出操作时候的异常)、ParseException(对日期和时间解析时可能抛出的异常)、FileNoteFoundException(尝试打开一个存在的文件时抛出的异常)</li><li>不可检异常：<ul><li>NullPointerException(空指针错误)</li><li>IllegalArgumentException(参数错误比如方法入参类型错误)</li><li>NumberFormatException（字符串转换为数字格式错误，IllegalArgumentException的子类）</li><li>ArrayIndexOutOfBoundsException（数组越界错误）</li><li>ClassCastException（类型转换错误）</li><li>ArithmeticException（算术错误）</li><li>SecurityException （安全错误比如权限不够）</li><li>UnsupportedOperationException(不支持的操作错误比如重复创建同一用户)</li></ul></li></ul></li><li>Error: Error属于程序无法处理的错误，没法通过catch来捕获。异常发生时Java虚拟机一般会选择终止。</li></ul><p>TODO: 异常捕获的代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">catch</span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">finally</span>&#123;</span><br><span class="line"></span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure><h2 id="🆗序列化和反序列化-⭐️⭐️"><a href="#🆗序列化和反序列化-⭐️⭐️" class="headerlink" title="🆗序列化和反序列化 ⭐️⭐️"></a>🆗序列化和反序列化 ⭐️⭐️</h2><p>序列化：将数据结构对象转化为<strong>二进制字节流</strong>的过程<br>反序列化：将在序列化过程中生成的二进制字节流转化成数据结构或者对象的过程</p><p>序列化的主要目的是通过网络对象或者是将对象存储到文件系统、数据库、内存中。</p><h2 id="反射-⭐⭐-面试官可能会问你什么是反射，它的优缺点是什么，有哪些应用场景"><a href="#反射-⭐⭐-面试官可能会问你什么是反射，它的优缺点是什么，有哪些应用场景" class="headerlink" title="反射 ⭐⭐ 面试官可能会问你什么是反射，它的优缺点是什么，有哪些应用场景"></a>反射 ⭐⭐ 面试官可能会问你什么是反射，它的优缺点是什么，有哪些应用场景</h2><p>通过反射可以获取任意一个类的所有属性和方法，并且可以调用这些方法和属性</p><p>优点：</p><ul><li>反射可以让代码更加灵活、为各种框架开发提供了遍历</li></ul><p>缺点：</p><ul><li>安全问题，可以无视泛型参数的安全检查(泛型参数的安全检查发生在编译时)</li><li>性能稍微差点</li></ul><p>反射的应用场景：</p><ul><li>框架中大量使用了动态代理，而动态代理的实现依赖反射</li><li>注解的实现也用到了反射</li></ul><h2 id="List、Set、Map、Queue的区别-⭐⭐"><a href="#List、Set、Map、Queue的区别-⭐⭐" class="headerlink" title="List、Set、Map、Queue的区别 ⭐⭐"></a>List、Set、Map、Queue的区别 ⭐⭐</h2><ul><li>List: 存储的元素是有序的、可重复的。</li><li>Set: 存储的元素不可重复的。</li><li>Queue: 按特定的排队规则来确定先后顺序，存储的元素是有序的、可重复的。</li><li>Map: 使用键值对（key-value）存储，类似于数学上的函数 y&#x3D;f(x)，”x” 代表 key，”y” 代表 value，key 是无序的、不可重复的，value 是无序的、可重复的，每个键最多映射到一个值</li></ul><h2 id="ArrayList-和-LinkedList-的区别。⭐⭐⭐⭐"><a href="#ArrayList-和-LinkedList-的区别。⭐⭐⭐⭐" class="headerlink" title="ArrayList 和 LinkedList 的区别。⭐⭐⭐⭐"></a>ArrayList 和 LinkedList 的区别。⭐⭐⭐⭐</h2><p>线程安全性：ArrayList 和 LinkedList 都是线程不安全的。</p><p>底层数据结构：ArrayList底层采用object数组存储，LinkedList底层采用的是双向链表</p><p>插入和删除元素：</p><ul><li>ArrayList采用数组存储，所以插入和删除元素的复杂度受到元素位置的影响</li><li>而LinkedList 采用双向链表 所以再头尾插入元素不受元素位置的影响。而在其他位置插入元素的话需要先遍历到那个位置。</li></ul><p>随机访问：ArrayList支持随机访问，而LinkedList不支持随机访问。</p><p>内存占用：ArrayList占用连续的内存空间，且在list列表的表尾会预留一部分空间导致内存的浪费；而LinkedList中的每一个元素都会占据比ArrayList更多的空间，因为要存放前驱+后继+元素</p><blockquote><p>我们在项目中一般是不会使用到 LinkedList 的，需要用到 LinkedList 的场景几乎都可以使用 ArrayList 来代替，并且，性能通常会更好！</p></blockquote><h2 id="比较HashSet、LinkedHashSet-和-TreeSet-三者的异同。【⭐⭐⭐】"><a href="#比较HashSet、LinkedHashSet-和-TreeSet-三者的异同。【⭐⭐⭐】" class="headerlink" title="比较HashSet、LinkedHashSet 和 TreeSet 三者的异同。【⭐⭐⭐】"></a>比较HashSet、LinkedHashSet 和 TreeSet 三者的异同。【⭐⭐⭐】</h2><ul><li>HashSet、LinkedHashSet 和 TreeSet 都是 Set 接口的实现类，都能保证元素唯一，并且都不是线程安全的。</li><li>HashSet、LinkedHashSet 和 TreeSet 的主要区别在于底层数据结构不同。<br>HashSet 的底层数据结构是哈希表（基于 HashMap 实现）。<br>LinkedHashSet 的底层数据结构是链表和哈希表，元素的插入和取出顺序满足 FIFO。<br>TreeSet 底层数据结构是红黑树，元素是有序的，排序的方式有自然排序和定制排序。</li><li>底层数据结构不同又导致这三者的应用场景不同。<br>HashSet 用于不需要保证元素插入和取出顺序的场景<br>LinkedHashSet 用于保证元素的插入和取出顺序满足 FIFO 的场景<br>TreeSet 用于支持对元素自定义排序规则的场景</li></ul><h2 id="HashMap-多线程操作导致死循环问题。【⭐⭐⭐】"><a href="#HashMap-多线程操作导致死循环问题。【⭐⭐⭐】" class="headerlink" title="HashMap 多线程操作导致死循环问题。【⭐⭐⭐】"></a>HashMap 多线程操作导致死循环问题。【⭐⭐⭐】</h2><p>Java1.7之前 HashMap在多线程的环境下扩容操作可能存在死循环的问题，因为当有多个元素需要扩容的时候，多个线程同时对链表进行操作，头插法可能会导致链表中的节点指向错误的位置，形成环形链表。Java1.8之后改为尾插法解决了这个问题。<br>但是多线程使用HashMap还容易导致数据覆盖的问题，并发环境下可以使用<code>ConcurrentHashMap</code></p><h2 id="HashMap-的长度为什么是-2-的幂次方。【⭐⭐⭐】"><a href="#HashMap-的长度为什么是-2-的幂次方。【⭐⭐⭐】" class="headerlink" title="HashMap 的长度为什么是 2 的幂次方。【⭐⭐⭐】"></a>HashMap 的长度为什么是 2 的幂次方。【⭐⭐⭐】</h2><p>为了尽量减少hash冲突，hash值的范围很大，但是这么大的映射空间的数组内存是放不下的，所以用之前会对数组进行取模运算，得到的余数才是对应的最终的数组下标，所以这样操作主要是考虑到了对运算效率的提升。<br>在设计算法的时候取余操作只有当除数是 2 的幂次才等价于与其除数减一的与(&amp;)操作<br>（也就是说 hash%length&#x3D;&#x3D;hash&amp;(length-1)的前提是 length 是 2 的 n 次方；）</p><h2 id="HashMap、HashTable、以及-ConcurrentHashMap-的区别⭐⭐⭐⭐⭐"><a href="#HashMap、HashTable、以及-ConcurrentHashMap-的区别⭐⭐⭐⭐⭐" class="headerlink" title="HashMap、HashTable、以及 ConcurrentHashMap 的区别⭐⭐⭐⭐⭐"></a>HashMap、HashTable、以及 ConcurrentHashMap 的区别⭐⭐⭐⭐⭐</h2><ol><li>首先HashMap和HashTable</li></ol><p>从线程安全性上来说：<br>HashMap是非线程安全的，HashTable是线程安全的，因为Hash的大部分方法都使用了synchronized修饰(但是如果想保证线程安全 还是要用ConcurrentHashMap)</p><p>从效率上来说：<br>因为线程安全问题，hashMap比HashTable效率高，而且hashtable有上位替代ConcurrentHashMap</p><p>从null key 和 null value 的支持上来说：HashMap可以存储null的key和value，但是null作为key只能有一个，作为值可以有多个；HashTable不允许有NUll键和Null值，否则会抛<code>NullPointerException</code></p><p>从初始容量大小和每次扩充的的容量大小上来说：</p><ol><li>如果不指定容量的初始，Hashtable默认为11 ，之后每次扩充扩充为原来容量的2N+1；HashMap默认大小为16,之后每次扩充为原来两倍。</li><li>如果指定容量的初始值，hashtable会直接用你指定的大小，而hashmap会将其扩充为2的幂次方大小。</li></ol><p>从底层数据结构上来说：<br>Java1.8之后的HashMap在解决哈希冲突时有了很大变化，当链表长度大于阈值的时候，将链表转化为红黑树以减少搜索的时间(在转化成红黑树之前会先判断当前数组的长度是否小于64，如果小于则先进行扩容,而不是转化成红黑树),而HashTable没有这样的机制。</p><ol start="2"><li>ConcurrentHashMap 和 Hashtable 的区别</li></ol><p>两者主要的区别是实现线程安全的方式不同</p><p>从底层数据结构上来说： JDK1.7 的ConcurrentHashMap采用<code>分段数组+链表</code>实现，JDK1.8采用的数据结构和HashMap1.8一样，采用数组+链表&#x2F;红黑二叉树。Hashtable 和 JDK1.8 之前的 HashMap 的底层数据结构类似,都是采用 数组+链表 的形式，<strong>数组是 HashMap 的主体，链表则是主要为了解决哈希冲突而存在的</strong></p><p>从实现线程安全的方式上来说：并发HashMap有多把锁，而Hashtable共用一把锁<br>在 JDK1.7 的时候，ConcurrentHashMap 对整个桶数组进行了分割(segment)，每一把锁只锁容器其中一部分数据，多线程访问容器里不同数据段的数据，就不会存在锁竞争，提高并发访问率。<br>到了 JDK1.8 的时候，ConcurrentHashMap不用segment了，而是直接用 Node 数组+链表+红黑树的数据结构来实现，并发控制使用 synchronized 和 CAS 来操作</p><p>Hashtable(同一把锁) :使用 synchronized 来保证线程安全，效率非常低下。当一个线程访问同步方法时，其他线程也访问同步方法，可能会进入阻塞或轮询状态，效率十分低下</p><blockquote><p>什么是 CAS? CAS 即比较并替换（Compare And Swap)，是实现并发算法时常用到的一种技术。CAS 操作包含三个操作数——内存位置、预期原值及新值。执行 CAS 操作的时候，将内存位置的值与预期原值比较，如果相匹配，那么处理器会自动将该位置值更新为新值，否则，处理器不做任何操作。我们都知道，CAS 是一条 CPU 的原子指令（cmpxchg 指令），不会造成所谓的数据不一致问题，Unsafe 提供的 CAS 方法（如 compareAndSwapXXX）底层实现即为 CPU 指令 cmpxchg 。</p></blockquote><h3 id="JDK-1-7-和-JDK-1-8-的-ConcurrentHashMap-实现有什么不同？"><a href="#JDK-1-7-和-JDK-1-8-的-ConcurrentHashMap-实现有什么不同？" class="headerlink" title="JDK 1.7 和 JDK 1.8 的 ConcurrentHashMap 实现有什么不同？"></a>JDK 1.7 和 JDK 1.8 的 ConcurrentHashMap 实现有什么不同？</h3><ul><li>线程安全实现方式：JDK 1.7 采用 Segment 分段锁来保证安全， Segment 是继承自 ReentrantLock。JDK1.8 放弃了 Segment 分段锁的设计，采用 Node + CAS + synchronized 保证线程安全，锁粒度更细，synchronized 只锁定当前链表或红黑二叉树的首节点。</li><li>Hash 碰撞解决方法 : JDK 1.7 采用拉链法，JDK1.8 采用拉链法结合红黑树（链表长度超过一定阈值时，将链表转换为红黑树）。</li><li>并发度：JDK 1.7 最大并发度是 Segment 的个数，默认是 16。JDK 1.8 最大并发度是 Node 数组的大小，并发度更大。</li></ul><h3 id="为什么要用红黑树"><a href="#为什么要用红黑树" class="headerlink" title="为什么要用红黑树"></a>为什么要用红黑树</h3><p>主要目的是解决哈希冲突<br>当哈希冲突发生时，通常会使用链表将具有相同哈希值的键值对存储在同一个桶中。<br>然而，当链表中的元素达到一定的阈值的时候，Java1.8会将链表转化为红黑树，红黑树是一种平衡二叉搜索树，具有更快的查找效率，可以解决链表过长的时候查找效率低下的问题</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;⭐ ：面试中不常问到，如果面试官问到尽量能答出来，答不出来也没关系。&lt;br&gt;⭐⭐ ：面试中不常问到，但是如果面试官问到的话，答不出来对你的印象会减分。&lt;br&gt;⭐⭐⭐：面试中会问到，答不出来面试有点悬。面试官会惊讶为什么你这也不会。&lt;br&gt;⭐⭐⭐⭐：面试高频考点。&lt;br&gt;⭐⭐</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>测试基础</title>
    <link href="http://www.meprotoss.com/undefined/322e93bb.html"/>
    <id>http://www.meprotoss.com/undefined/322e93bb.html</id>
    <published>2024-05-25T07:21:22.000Z</published>
    <updated>2024-06-09T07:49:49.473Z</updated>
    
    <content type="html"><![CDATA[<h2 id="2024-05-25"><a href="#2024-05-25" class="headerlink" title="2024-05-25"></a>2024-05-25</h2><h3 id="记住测试流程-6个步骤"><a href="#记住测试流程-6个步骤" class="headerlink" title="记住测试流程(6个步骤)"></a>记住测试流程(6个步骤)</h3><ul><li>需求分析</li><li>测试计划</li><li>用例设计</li><li>用例执行</li><li>缺陷管理</li><li>测试报告</li></ul><h3 id="测试分类-7个"><a href="#测试分类-7个" class="headerlink" title="测试分类(7个)"></a>测试分类(7个)</h3><h3 id="给你一个测试对象-如何设计测试用例？"><a href="#给你一个测试对象-如何设计测试用例？" class="headerlink" title="给你一个测试对象 如何设计测试用例？"></a>给你一个测试对象 如何设计测试用例？</h3><p>首先分析这个测试对象使用于什么场景(如穷举场景、边界限制场景。。。)，根据场景选择对应的测试方法</p><p>在使用测试用例的过程中，可以用质量模型来思考测试时应该考虑的方面。<br>质量模型从以下几个方面来思考：功能、性能、兼容、易用性、安全</p><p>例题：如何去测试一个花瓶？</p><ol><li>功能： 插花、装水、养鱼、种菜</li><li>性能：防摔、耐高温、耐低温、耐腐蚀</li><li>易用：防滑、便携</li><li>属性：长、宽、高、样式、材质</li><li>……</li></ol><h3 id="穷举场景"><a href="#穷举场景" class="headerlink" title="穷举场景"></a>穷举场景</h3><p>使用”等价类划分法”</p><p>重点：有效等价和单个无效等价各取<strong>1个</strong>即可。</p><p>步骤：</p><ol><li>明确需求</li><li>确定有效和无效等价</li><li>根据有效和无效造数据编写用例(划分等价)</li></ol><p>重点：</p><ol><li>正向用例：一条尽可能覆盖多条</li><li>逆向用例：每一条数据，都是一条单独用例。</li></ol><p>针对：</p><ol><li>需要有大量数据测试输入，但是没法穷举测试的地方。</li><li>输入框</li><li>下拉列表</li><li>单选复选框</li></ol><p>典型代表：页面的输入框类测试。</p><h3 id="边界限制场景"><a href="#边界限制场景" class="headerlink" title="边界限制场景"></a>边界限制场景</h3><p>步骤:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1、明确需求</span><br><span class="line">2、确定有效和无效等价(类型)</span><br><span class="line">3、确定边界范围</span><br><span class="line">  上点(边界点)、离点(边界点两边最近的点)、内点(边界点内)</span><br><span class="line">所以一共有7个点</span><br><span class="line">4、提取数据编写用例</span><br></pre></td></tr></table></figure><p>优化：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">重点：开内闭外（开区间选包含的点，闭区选不包含的点）</span><br><span class="line"></span><br><span class="line">开区间：不包含边界上的点（没有等号）。如：a&lt;10</span><br><span class="line"></span><br><span class="line">闭区间：包含边界上的点（有等号）。 如:a&lt;=10</span><br></pre></td></tr></table></figure><p>典型代表:有边界范围的输入框类测试</p><h2 id="2024-05-26"><a href="#2024-05-26" class="headerlink" title="2024-05-26"></a>2024-05-26</h2><h3 id="多条件依赖问题"><a href="#多条件依赖问题" class="headerlink" title="多条件依赖问题"></a>多条件依赖问题</h3><p>使用判定表</p><p>步骤:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">1、明确需求</span><br><span class="line">2、画出判定表</span><br><span class="line">  1）、列出条件桩和动作桩 </span><br><span class="line">  2）、填写条件项，对条件进行全组合 </span><br><span class="line">  3）、根据条件项的组合确定动作项 </span><br><span class="line">  4）、简化、合并相似规则(有相同的动作)</span><br><span class="line">3、根据规则编写测试用例</span><br></pre></td></tr></table></figure><p>使用场景：</p><ol><li>有多个输入条件，多个输出结果，输入条件之间有组合关系，输入条件和输出结果之间有依赖关系</li><li>判定表一般适用于条件组合数量较少的情况(4个以下)</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"> 提示：</span><br><span class="line">1、多条件之间有依赖关系，使用判定表来进行测试覆盖。</span><br><span class="line">2、判定表一般适合4个以内条件依赖关系</span><br><span class="line">3、如果条件超过4个，就不适合覆盖所有条件，应采用（正交法）来解决。</span><br></pre></td></tr></table></figure><h3 id="业务测试"><a href="#业务测试" class="headerlink" title="业务测试"></a>业务测试</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">  重点:</span><br><span class="line">1、覆盖业务测试,需要使用流程图法</span><br><span class="line"></span><br><span class="line">2、先测试业务，在测试单功能、单模块、单页面</span><br></pre></td></tr></table></figure><p>⭐️ 面试题：任何测试都应该先走<strong>业务</strong></p><p>而测业务需要使用场景法</p><h3 id="错误推荐法"><a href="#错误推荐法" class="headerlink" title="错误推荐法"></a>错误推荐法</h3><p>应用场景：当项目用例都执行完毕，且BUG修复完成，离上线还有一段时间，在这段时间中可是使用错误推荐法复测主要业务或测试未覆盖的功能。</p><p>⭐️面试题：时间紧任务重不能加人的情况怎么尽最大努力测试? 答：1. 不写测试用例，先和产品人员沟通覆盖主要业务，选出重要的模块先正向后逆向2. 可以使用错误推荐法<strong>根据经验复测</strong>。</p><h2 id="缺陷"><a href="#缺陷" class="headerlink" title="缺陷"></a>缺陷</h2><h3 id="缺陷的描述"><a href="#缺陷的描述" class="headerlink" title="缺陷的描述"></a>缺陷的描述</h3><h4 id="缺陷的核心六要素"><a href="#缺陷的核心六要素" class="headerlink" title="缺陷的核心六要素"></a>缺陷的核心六要素</h4><ul><li>标题</li><li>预期结果</li><li>预置条件</li><li>实际结果</li><li>复现步骤</li><li>必要附件</li></ul><h4 id="缺陷类型"><a href="#缺陷类型" class="headerlink" title="缺陷类型"></a>缺陷类型</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">1、功能错误</span><br><span class="line">2、UI页面错误</span><br><span class="line">3、兼容性</span><br><span class="line">4、数据（数据库）</span><br><span class="line">5、易用性</span><br><span class="line">6、建议</span><br><span class="line">7、架构缺陷</span><br></pre></td></tr></table></figure><h4 id="工作流程小结"><a href="#工作流程小结" class="headerlink" title="工作流程小结"></a>工作流程小结</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">设计用例-&gt;执行用例（执行测试）-&gt;缺陷（提交、验证、关闭）</span><br><span class="line">缺陷定义：任何问题（Bug）</span><br><span class="line">缺陷标准：多功能、少功能、错误、缺少隐性功能、易用性</span><br><span class="line">描述缺陷重点：缺陷标题、前置条件、复现步骤、预期结果、实际结果、附件备注</span><br><span class="line">提交缺陷信息：指派人、缺陷等级、修复优先级、类型、状态（统计缺陷）</span><br></pre></td></tr></table></figure><h3 id="⭐️写用例的套路"><a href="#⭐️写用例的套路" class="headerlink" title="⭐️写用例的套路"></a>⭐️写用例的套路</h3><p>见xmind</p><ul><li>记住验证码测试用例永远是四条</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">  </span><br><span class="line">正向：</span><br><span class="line">  正确+未过期</span><br><span class="line">逆向： </span><br><span class="line">  为空</span><br><span class="line">  过期</span><br><span class="line">  错误</span><br></pre></td></tr></table></figure><ul><li>浏览器测试兼容性(显示输入操作)</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">五大浏览器内核：谷歌 火狐 IE 苹果 欧朋</span><br></pre></td></tr></table></figure><h3 id="提交注意事项"><a href="#提交注意事项" class="headerlink" title="提交注意事项"></a>提交注意事项</h3><p>当你发现缺陷后，首先会怎么办？</p><p>答案：确定Bug可复现，确定是Bug，提交时，要检查缺陷是否已存在。</p><h3 id="缺陷管理工具"><a href="#缺陷管理工具" class="headerlink" title="缺陷管理工具"></a>缺陷管理工具</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1、项目管理工具-管理缺陷 (禅道、JIRA、TFS)</span><br><span class="line">2、Excel管理缺陷</span><br></pre></td></tr></table></figure><h2 id="2024-05-27"><a href="#2024-05-27" class="headerlink" title="2024-05-27"></a>2024-05-27</h2><h3 id="登录界面的测试"><a href="#登录界面的测试" class="headerlink" title="登录界面的测试"></a>登录界面的测试</h3><h4 id="分析需求和提取测试点"><a href="#分析需求和提取测试点" class="headerlink" title="分析需求和提取测试点"></a>分析需求和提取测试点</h4><p>使用xmind</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;2024-05-25&quot;&gt;&lt;a href=&quot;#2024-05-25&quot; class=&quot;headerlink&quot; title=&quot;2024-05-25&quot;&gt;&lt;/a&gt;2024-05-25&lt;/h2&gt;&lt;h3 id=&quot;记住测试流程-6个步骤&quot;&gt;&lt;a href=&quot;#记住测试流程-6个步</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>MySql</title>
    <link href="http://www.meprotoss.com/undefined/6cac71de.html"/>
    <id>http://www.meprotoss.com/undefined/6cac71de.html</id>
    <published>2024-05-10T13:52:23.000Z</published>
    <updated>2024-05-13T08:13:36.668Z</updated>
    
    <content type="html"><![CDATA[<h2 id="单表查询"><a href="#单表查询" class="headerlink" title="单表查询"></a>单表查询</h2><h3 id="1757可回收且低脂的产品"><a href="#1757可回收且低脂的产品" class="headerlink" title="1757可回收且低脂的产品"></a>1757可回收且低脂的产品</h3><ul><li>注意要返回的是什么那么就去select什么</li></ul><h3 id="584寻找用户推荐人"><a href="#584寻找用户推荐人" class="headerlink" title="584寻找用户推荐人"></a>584寻找用户推荐人</h3><ul><li><p>MySQL是三值逻辑，分别为TRUE、FALSE和UNKNOWN，逻辑判断是如果逻辑运算符一端为NULL，则为UNKNOWN； 这段代码 referee_id &#x3D;2 为TRUE，则NOT TURE为FALSE和UNKNOWN，即&lt;&gt;2 OR 为NULL</p></li><li><p>null不可以和数值类直接比较，其结果为unkonwn</p></li><li><p>⭐️IFNULL(referee_id, 0) &lt;&gt; 2:意思是如果 referee_id 列的值为 NULL，则将其替换为 0，然后与 2 进行比较。如果 referee_id 列的值不等于 2，那么这一行将被包含在结果中</p></li></ul><h3 id="1148文章浏览-1"><a href="#1148文章浏览-1" class="headerlink" title="1148文章浏览 1"></a>1148文章浏览 1</h3><ul><li>我们可以在 SELECT 语句中使用 DISTINCT 关键字来从表 Views 中检索唯一元素</li><li>select 可以给列取别名</li></ul><h3 id="1683-无效的推文"><a href="#1683-无效的推文" class="headerlink" title="1683.无效的推文"></a>1683.无效的推文</h3><ul><li>获取某列字符长度的函数： CHAR_LENGTH ()</li></ul><h2 id="多表查询"><a href="#多表查询" class="headerlink" title="多表查询"></a>多表查询</h2><p>多表之间的业务关系主要有以下三种：</p><ol><li>一对多(部门与部门员工的关系):多的一方建立外键，指向一的一方的主键</li><li>多对多(学生与课程的关系):建立第三张中间表,中间表至少包含两个外键,分别关联两方主键</li><li>一对一(用户与用户详情的关系):在任意一方加入外键,关联另外一方的主键,并且设置外键为唯一的(UNIQUE)</li></ol><h3 id="多表查询分类"><a href="#多表查询分类" class="headerlink" title="多表查询分类"></a>多表查询分类</h3><h4 id="连接"><a href="#连接" class="headerlink" title="连接"></a>连接</h4><h5 id="内连接"><a href="#内连接" class="headerlink" title="内连接"></a>内连接</h5><p>查询两个表之间的交集</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">1). 隐式内连接</span><br><span class="line">SELECT</span><br><span class="line">字段列表</span><br><span class="line">FROM</span><br><span class="line">表1 , 表2</span><br><span class="line">WHERE</span><br><span class="line">条件 ... ;</span><br></pre></td></tr></table></figure><p>2). 显式内连接</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">SELECT</span><br><span class="line">字段列表</span><br><span class="line">FROM</span><br><span class="line">表1</span><br><span class="line">[ INNER ]</span><br><span class="line">JOIN 表2</span><br><span class="line">ON</span><br><span class="line">连接条件 ... ;</span><br></pre></td></tr></table></figure><h5 id="外连接"><a href="#外连接" class="headerlink" title="外连接"></a>外连接</h5><p>外连接将两个表按照匹配条件合成一张表</p><ul><li>左外连接：查询左表所有数据,以及两张表交集部分数据   <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">   表1</span><br><span class="line">LEFT</span><br><span class="line">[ OUTER ]</span><br><span class="line">JOIN 表2</span><br><span class="line">ON</span><br><span class="line">条件 ... ;</span><br></pre></td></tr></table></figure></li><li>右外连接：查询右表所有数据,以及两张表交集部分数据<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"> 表1</span><br><span class="line">RIGHT</span><br><span class="line">[ OUTER ]</span><br><span class="line">JOIN 表2</span><br><span class="line">ON</span><br><span class="line">条件 ... ;</span><br></pre></td></tr></table></figure></li></ul><h5 id="自连接"><a href="#自连接" class="headerlink" title="自连接"></a>自连接</h5><p>当前表与自身的连接查询,自连接必须使用表别名</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"> 表A</span><br><span class="line">别名A</span><br><span class="line">JOIN</span><br><span class="line">表A</span><br><span class="line">别名B</span><br><span class="line">ON</span><br><span class="line">条件 ... ;</span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><p>[!TIP]<br>在自连接查询中,必须要为表起别名,要不然我们不清楚所指定的条件、返回的字段,到底<br>是哪一张表的字段。</p></blockquote><h5 id="联合查询"><a href="#联合查询" class="headerlink" title="联合查询"></a>联合查询</h5><h4 id="子查询"><a href="#子查询" class="headerlink" title="子查询"></a>子查询</h4><p>指嵌套在主查询中的一个查询</p><h3 id="1378-使用唯一标识码替换员工ID"><a href="#1378-使用唯一标识码替换员工ID" class="headerlink" title="1378.使用唯一标识码替换员工ID"></a>1378.使用唯一标识码替换员工ID</h3><p>使用outer join会保留主表的全部，以及次表与主表能匹配的记录，没有匹配时返回null</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">表1 left join 表2 on 连接条件</span><br></pre></td></tr></table></figure><p>左外连接表示保留表1的所有数据，表2中没有的记录返回null</p><h3 id="产品销售分析"><a href="#产品销售分析" class="headerlink" title="产品销售分析"></a>产品销售分析</h3><h3 id=""><a href="#" class="headerlink" title=""></a></h3>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;单表查询&quot;&gt;&lt;a href=&quot;#单表查询&quot; class=&quot;headerlink&quot; title=&quot;单表查询&quot;&gt;&lt;/a&gt;单表查询&lt;/h2&gt;&lt;h3 id=&quot;1757可回收且低脂的产品&quot;&gt;&lt;a href=&quot;#1757可回收且低脂的产品&quot; class=&quot;headerlink</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>八股文骚套路之Hr面</title>
    <link href="http://www.meprotoss.com/undefined/3593513e.html"/>
    <id>http://www.meprotoss.com/undefined/3593513e.html</id>
    <published>2024-05-10T13:52:23.000Z</published>
    <updated>2024-09-23T02:12:43.288Z</updated>
    
    <content type="html"><![CDATA[<h2 id="你做游戏测试的职业规划？"><a href="#你做游戏测试的职业规划？" class="headerlink" title="你做游戏测试的职业规划？"></a>你做游戏测试的职业规划？</h2><ol><li>首先作为一个游戏的重度爱好者，从事游戏行业一直是我的理想，能将自己的兴趣和工作结合起来，真的是一件很棒的事情</li><li>要扎实专业技能，因为先前很少有实际应用于游戏场景的测试经验，所以在刚迈入工作岗位的时候，有必要在业务中强化自己的专业能力，做好本职工作，积累经验。</li><li>其次作为一名测试人员，我认为丰富的知识面也是相当重要的，测试是产品上线之前的最后一道工序，在测试中检测出问题的时候，需要经常需要和开发、策划人员进行沟通和反馈，所以自己本身对于业务的技术框架也必须是熟悉的，也许不需要对细节有多么深入的理解，但是一定要有一个宏观上的把控,所以我会努力去拓展自己的知识面，不仅仅是将眼光局限于测试技能，而是也要加强自己的代码能力，强化数据库、微服务等知识。</li><li>除了技能上的锻炼，作为游戏行业的测试，不同于其他测试岗位，对于游戏行业的风向和市场的偏好也必须有深刻的理解，一个不懂游戏的人去担任游戏行业的从业者显然是一件很糟糕的事情。</li><li>还有的话，我认为不断提高自己的软实力也是非常有必要的，在有了一定的积累之后，将不再单单局限于测试本身，而是会进行更加宏观的设计，比如测试策略的指制定、测试进度的把控，同时要提升自己的人际交往能力，尤其是沟通和表达能力，有的时候这个也许比技术本身还要重要。</li></ol><h2 id="你做测试的优势在哪里"><a href="#你做测试的优势在哪里" class="headerlink" title="你做测试的优势在哪里"></a>你做测试的优势在哪里</h2><ul><li>首先我对游戏充满了热爱，同时对平时在游玩中遇到的bug和错误深恶痛绝，如果能成为一名游戏测试人员，那么就有机会在遇到检测出这些问题，这让我感到很兴奋</li><li>其次我对多种编程语言都有一定的涉猎，主学的是java，也自学过python，同时在维护和配置自己的archlinux系统和neovim编辑器的时候，经常会接触到shell和lua语言，对他们都有一定的了解</li><li>我有强烈的探索欲望和持之以恒的品质，不怕麻烦，不畏难，并乐于总结经验，进行分享。提及自己在配置和使用neovim和archlinux中遇到的问题和收获</li><li>我有较强的语言表达能力和人际交往能力，兴趣广泛，容易与人相处，作为一名测试人员，往往需要及时整理测试文档，与开发人员和策划人员进行沟通和接洽，所以必须要有这方面的能力，我喜欢与人交往，乐于表现，读书期间曾多次参加志愿者展演，也曾经在毕业晚会的舞台上登台演出。</li></ul><h2 id="你找工作的时候，最重要的考虑因素是什么？为什么"><a href="#你找工作的时候，最重要的考虑因素是什么？为什么" class="headerlink" title="你找工作的时候，最重要的考虑因素是什么？为什么"></a>你找工作的时候，最重要的考虑因素是什么？为什么</h2><ul><li>最重要的因素是岗位与自身的契合度，我认为岗位与人的匹配是非常重要的。</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;你做游戏测试的职业规划？&quot;&gt;&lt;a href=&quot;#你做游戏测试的职业规划？&quot; class=&quot;headerlink&quot; title=&quot;你做游戏测试的职业规划？&quot;&gt;&lt;/a&gt;你做游戏测试的职业规划？&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;首先作为一个游戏的重度爱好者，从事游戏行业一直是</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>算法</title>
    <link href="http://www.meprotoss.com/undefined/b7e144d1.html"/>
    <id>http://www.meprotoss.com/undefined/b7e144d1.html</id>
    <published>2024-05-10T13:37:57.000Z</published>
    <updated>2024-09-23T10:00:39.895Z</updated>
    
    <content type="html"><![CDATA[<h2 id="总体思路"><a href="#总体思路" class="headerlink" title="总体思路"></a>总体思路</h2><h2 id="测开岗高频算法题"><a href="#测开岗高频算法题" class="headerlink" title="测开岗高频算法题"></a>测开岗高频算法题</h2><p><strong>测开岗的算法题难度相对要低一些，差不多都是剑指offer上或者力扣上的热门且难度为简单、中等的题。把每个标签的前5~10道题刷一刷，面试的时候基本够用。</strong></p><p>三个数字的最大乘积</p><p>有两个很长很很长的字符串，但是字符都是数字，实现这俩字符串的加法，输出为一个字符串。如str1&#x3D;”1231213347845713824718237489123748343246217489132”, str2&#x3D;”623478573127438912743892017489132748172341324132”</p><p>两数之和 标签：哈希表 （★★★）</p><p>str1能不能最多交换两次字符变成str2，并设计测试用例。</p><p>和为s的连续正数序列 标签：暴力、双指针</p><p>有效括号 标签：栈 （★★★★）</p><p>数组中重复的数字 标签：哈希表 （★★★★★）</p><p>7的倍数或者包含7打印”-“，其余的打印数字，每行不超过5个数字</p><p>从1到100000000中取出一个数(自己申明一个变量，比如num &#x3D; 2333)，写代码找出取出的是哪个数。    标签：二分查找</p><p>一个数在有序数组里出现的次数。标签：二分</p><p>字符串转整数，并写测试用例。    标签：数学，有很多非数字类型需要考虑，还有数字越界的情况需要考虑，比较考察测试思维 （★★★★★）</p><p>连续子数组的最大和 标签：分治、DP （★★★★）</p><p>在字符串中找出没有重复字符的最长的连续子串，并返回子串及长度，譬如“aaabcdcbcbbb” 最长子串为abcd，长度为4</p><p>判断链表是否有环 标签：双指针</p><p>两个栈实现一个队列 （★★）</p><p>最长不含重复字符的子字符串 标签：双指针、滑动窗口 （★★★★★）</p><h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><ul><li>数组的元素在内存地址中是连续的，不能单独删除数组中的某个元素，只能覆盖。</li></ul><h3 id="704-二分查找"><a href="#704-二分查找" class="headerlink" title="704 二分查找"></a>704 二分查找</h3><p>要注意选取的是左闭右闭的区间还是左闭右开的区间</p><h3 id="27-原地移除数组中的元素"><a href="#27-原地移除数组中的元素" class="headerlink" title="27 原地移除数组中的元素"></a>27 原地移除数组中的元素</h3><p>双指针思路:</p><ul><li>快指针用于寻找”新“数组中的元素</li><li>慢指针是新数组的下标值</li><li>快指针遍历数组，当遇见不为val的数值（即新数组中的元素）则赋值给nums[slow]，遍历完就可得到新数组</li></ul><h3 id="977-有序数组的平方"><a href="#977-有序数组的平方" class="headerlink" title="977 有序数组的平方"></a>977 有序数组的平方</h3><ul><li>思路：因为数组中有负数，所以平方之后最大值就在数组的两端，那么定义两个指针从两边往中间遍历</li></ul><h3 id="209-长度最小的子数组"><a href="#209-长度最小的子数组" class="headerlink" title="209 长度最小的子数组"></a>209 长度最小的子数组</h3><ul><li>滑动窗口:</li></ul><p>窗口就是 满足其和 ≥ s 的长度最小的 连续 子数组。</p><p>窗口的起始位置如何移动：如果当前窗口的值大于等于s了，窗口就要向前移动了（也就是该缩小了,此时移动左边界）。</p><p>窗口的结束位置如何移动：窗口的结束位置就是遍历数组的右指针，也就是for循环里的索引。</p><p>整体思路：<br>  右指针遍历数组，将遍历到的值添加进结果数组<br>  每当添加一个新的值之后，判断当前数组中的值是否大于目标值，若是大于则判断当前的长度是比已记录的长度小 然后移动左指针缩写窗口，并将窗口左端的值移出结果</p><h3 id="⭐️54螺旋矩阵"><a href="#⭐️54螺旋矩阵" class="headerlink" title="⭐️54螺旋矩阵"></a>⭐️54螺旋矩阵</h3><p>略</p><p>算法思路:</p><ol><li>空值处理： 当 matrix 为空时，直接返回空列表 [] 即可。</li><li>初始化： 矩阵 左、右、上、下 四个边界 l , r , t , b ，用于打印的结果列表 res 。</li><li>循环打印： “从左向右、从上向下、从右向左、从下向上” 四个方向循环打印。<ol><li>根据边界打印，即将元素按顺序添加至列表 res 尾部。</li><li>边界向内收缩 1 （代表已被打印）。</li><li>判断边界是否相遇（是否打印完毕），若打印完毕则跳出。<br>&#x2F;&#x2F;            对左子表进行排序</li></ol></li><li>返回值： 返回 res 即可。</li></ol><h3 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h3><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><ul><li>是基于分治的思想的排序算法，一次排序确定一个元素（枢轴元素）的位置，将整个表划分为左右两个子表</li><li>使用递归的思想，算法的输入数据是：最左下标、最右下标、数组</li><li>一趟划分的算法中，要注意循环跳出条件是low &lt; high ,要注意在每次移动指针之前，都要判断low &lt; high,最终返回的是排序好的枢轴元素的下标low</li></ul><h3 id="数组章节总结"><a href="#数组章节总结" class="headerlink" title="数组章节总结"></a>数组章节总结</h3><ul><li>数组是存放在连续内存空间上的相同类型数据的集合。</li><li>数组下标都是从0开始的。</li><li>数组内存空间的地址是连续的；因为数组的在内存空间的地址是连续的，所以我们在删除或者增添元素的时候，就难免要移动其他元素的地址。</li></ul><h2 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h2><h3 id="链表理论基础"><a href="#链表理论基础" class="headerlink" title="链表理论基础"></a>链表理论基础</h3><p>Java中链表的定义</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ListNode</span> &#123;</span><br><span class="line">    <span class="comment">// 结点的值</span></span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 下一个结点</span></span><br><span class="line">    ListNode next;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 节点的构造函数(无参)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ListNode</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 节点的构造函数(有一个参数)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ListNode</span><span class="params">(<span class="type">int</span> val)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.val = val;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 节点的构造函数(有两个参数)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ListNode</span><span class="params">(<span class="type">int</span> val, ListNode next)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.val = val;</span><br><span class="line">        <span class="built_in">this</span>.next = next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>链表操作的两种方式：</p><ul><li><p>直接使用原来的链表来进行删除操作。</p></li><li><p>设置一个虚拟头结点在进行删除操作。(推荐)</p></li></ul><h3 id="206-反转链表"><a href="#206-反转链表" class="headerlink" title="206 反转链表"></a>206 反转链表</h3><ul><li>申请两个指针pre和cur</li><li>申请一个temp记录cur的位置</li><li>原地反转链表指针</li><li>同时向后平移两个指针</li></ul><h3 id="203-移除链表元素"><a href="#203-移除链表元素" class="headerlink" title="203 移除链表元素"></a>203 移除链表元素</h3><p>设置一个虚拟头结点，这样原链表的所有节点就都可以按照统一的方式进行移除了。</p><ul><li><p>注意遍历终止的条件是当前指针指向的节点为空</p></li><li><p>每一次判断之后同时移动两个指针</p></li><li><p>最后返回虚拟头结点的下一个节点即为新节点的头</p></li></ul><h3 id="707-设计链表"><a href="#707-设计链表" class="headerlink" title="707 设计链表"></a>707 设计链表</h3><ul><li>首先设计链表节点</li><li>然后用单链表+虚拟头结点实现需求</li></ul><h3 id="21-合并两个有序链表"><a href="#21-合并两个有序链表" class="headerlink" title="21 合并两个有序链表"></a>21 合并两个有序链表</h3><ul><li>依次比较两个链表的节点值做就行</li><li>注意一个链表遍历完了之后将另一个链表的剩余部分直接拼接到新链表尾部即可</li></ul><h2 id="哈希表理论基础和总结"><a href="#哈希表理论基础和总结" class="headerlink" title="哈希表理论基础和总结"></a>哈希表理论基础和总结</h2><p>哈希表是根据关键码的值而直接进行访问的数据结构</p><ul><li><p>需要 <strong>判断一个元素是否出现过</strong> 或者<strong>一个元素出现的频次</strong>场景应该第一时间想到哈希法。</p></li><li><p>数组就是一张简单的hash表</p></li><li><p>使用哈希表的时候注意数据结构的选择</p><ul><li>数组 : 适用于元素不是太大的情况,将数据转换成哈希数组的效率较高，建议优先使用。</li><li>set :转变成set需要进行hash运算，效率较低。</li><li>map :要存放两个元素（数值和频率）（key和value）</li></ul></li><li><p>解题思路</p><ul><li>先想到用哈希表</li><li>考虑用什么存储结构</li></ul></li></ul><h3 id="242-有效的字母异位词"><a href="#242-有效的字母异位词" class="headerlink" title="242 有效的字母异位词"></a>242 有效的字母异位词</h3><ul><li>申请一个长为26位的数组用来记录字符串中字母出现的次数，然后将字符串s的频次依次存入数组 数组下标对应26个字母， 数组的值对应频次；然后遍历字符串t减去对应频次；最后遍历数组，只要有位置上值不为0，就说明当前字母的出现频次不一样多</li><li>字母运算时会自动取 ASCII 码。</li><li>在Java中，s.charAt(i) 是一个常用的字符串（String）方法，用于获取字符串 s 中索引位置为 i 的字符</li></ul><h3 id="数组交集"><a href="#数组交集" class="headerlink" title="数组交集"></a>数组交集</h3><ul><li><p>思路是记录两个数组中相同元素出现的次数，只要都&gt;1就证明是有交集 ; 因为记录频次所以想到用hash 因为不清楚数值的范围且哈希值比较少比较分散 所以不选择数组，而是使用set ， 在java中对应的数据结构就是hashset</p></li><li><p>Java 基础回顾</p></li></ul><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">在Java中，List是一个接口，它代表了一个有序的集合，允许重复的元素。List接口继承自Collection接口，它是集合框架中的一部分，用于存储一组元素，并且可以对这些元素进行访问、添加、删除和修改等操作。</span><br><span class="line"></span><br><span class="line">Java中常用的List实现类包括：</span><br><span class="line"></span><br><span class="line">ArrayList：基于数组实现的动态数组，支持随机访问，但在插入和删除操作时可能会涉及元素的移动。大小可以动态增长。</span><br><span class="line">LinkedList：基于链表实现的双向链表，插入和删除操作性能较好，但随机访问效率较低。</span><br><span class="line">Vector：与ArrayList类似，但是它是线程安全的，因此在多线程环境下使用较为安全，但性能相对较低。</span><br><span class="line">List接口定义了一系列方法，包括但不限于：</span><br><span class="line"></span><br><span class="line">int size()：返回列表中的元素数量。</span><br><span class="line">boolean isEmpty()：检查列表是否为空。</span><br><span class="line">boolean contains(Object o)：检查列表是否包含指定的元素。</span><br><span class="line">boolean add(E e)：将指定的元素添加到列表的末尾。</span><br><span class="line">void add(int index, E element)：将指定的元素插入到列表的指定位置。</span><br><span class="line">E remove(int index)：移除列表中指定位置的元素。</span><br><span class="line">void clear()：清空列表中的所有元素。</span><br><span class="line">E get(int index)：返回列表中指定位置的元素。</span><br><span class="line">E set(int index, E element)：将列表中指定位置的元素替换为指定的元素。</span><br></pre></td></tr></table></figure><ul><li>使用数组来做哈希的题目，是因为题目都限制了数值的大小;而且如果哈希值比较少、特别分散、跨度非常大，使用数组就造成空间的极大浪费。此时就要使用另一种结构体了，set。</li></ul><h3 id="1-两数之和"><a href="#1-两数之和" class="headerlink" title="1 两数之和"></a>1 两数之和</h3><ul><li><p>思路：一边遍历，一边将其存入哈希表，在遍历时判断我们要找的元素之前是否出现过。</p></li><li><p>我们既要知道元素的值，还要知道元素的下标所以此时用set 和 数组都不合适 要使用map ，Java中对应的数据结构是hashmap</p></li><li><p>注意：map是要存放 <strong>遍历过</strong> 的元素, 我们是要判断元素是否出现过，所以元素得作为key ，而value用来存放元素在数组中对应的下标，因为最后要返回的是元素的下标</p></li><li><p>在遍历数组的时候，只需要去map查询目标元素是否已出现过，有的话就找到了，没有则将当前遍历的元素放入map中</p></li></ul><h3 id="202-快乐数"><a href="#202-快乐数" class="headerlink" title="202 快乐数"></a>202 快乐数</h3><ul><li>无限循环，即求和的过程中,如果求出的和反复出现了，那么就说明这个数永远不可能是快乐数了 所以无限循环的终止条件是<strong>n &#x3D; 1 或着n重复出现过了</strong> ,因为这里出现了判断一个数是否出现过的情况，所以用hash法</li><li>求和的过程中需要取出数值各个位上的数，这个算法经常用到，要记熟:用<code>n % 10</code>取出最小位上的数，然后<code>n / 10</code>舍去这一位</li></ul><h3 id="四数相加"><a href="#四数相加" class="headerlink" title="四数相加"></a>四数相加</h3><ul><li>思路：前两个数组遍历相加，把所有的和存到一个数组A里，同时要记录出现的次数；后两个数组遍历相加，把所有的和存在一个数组B里,同时要记录出现的次数；遍历A看看想要的数在B中是否存在</li><li>因为既要知道数，还要统计次数，所以使用map（键值对）作为hash表的存储结构，此时key是值，value是出现的次数</li><li>注意：两两分组的复杂度是n^2, 一三分组是n^3。</li><li>每次配对成功后，count计数应该是加value里的值</li></ul><h3 id="三数相加"><a href="#三数相加" class="headerlink" title="三数相加"></a>三数相加</h3><ul><li>先排序</li><li>去重逻辑（有了再考虑去重，而不是还没有用就去考虑去重）</li><li>双指针解  i left right</li></ul><h3 id="四数之和"><a href="#四数之和" class="headerlink" title="四数之和"></a>四数之和</h3><ul><li>思路类似三数之和 i j left right</li><li>注意剪枝操作和去重操作</li></ul><h2 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h2><h3 id="替换空格"><a href="#替换空格" class="headerlink" title="替换空格"></a>替换空格</h3><p>实现一个函数，将一个字符串中的所有空格替换为”%20”</p><p>这里关于字符串操作要注意:</p><ul><li>String 是不可变的，所以没有类似append、delete、replace等增删改的方法,需要操作的话必须先转化为StringBuffer类型</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">solution</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//法1</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">replaceSpace</span><span class="params">( StringBuffer str)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> str.toString().replace(<span class="string">&quot; &quot;</span>,<span class="string">&quot;%20&quot;</span>);<span class="comment">//转换成字符串String类型，然后调用方法replace</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 法2 遍历字符串</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">replaceSpace2</span><span class="params">(StringBuffer str)</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="variable">length</span> <span class="operator">=</span> str.length();</span><br><span class="line">    <span class="type">StringBuffer</span> <span class="variable">result</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuffer</span>();</span><br><span class="line">    <span class="comment">// 遍历字符串</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; length; i++) &#123;</span><br><span class="line">      <span class="type">char</span> <span class="variable">b</span> <span class="operator">=</span> str.charAt(i);<span class="comment">//取出当前index下的字符</span></span><br><span class="line">      <span class="keyword">if</span> (String.valueOf(b).equals(<span class="string">&quot; &quot;</span>)) &#123; <span class="comment">//此处 String.valueOf方法用于将其他类型转化为字符串类型String</span></span><br><span class="line">        result.append(<span class="string">&quot;%20&quot;</span>); <span class="comment">//如果为空格 则在result后方插入%20</span></span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        result.append(b); <span class="comment">//如果不是则直接append</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result.toString(); <span class="comment">//由于result是StringBuffer类型 ， 所以要转化为String类型返回</span></span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="1768合并字符串"><a href="#1768合并字符串" class="headerlink" title="1768合并字符串"></a>1768合并字符串</h3><ul><li>不可便字符序列<code>String</code>以及常用api</li></ul><p>（1）boolean isEmpty()：字符串是否为空</p><p>（2）int length()：返回字符串的长度</p><p>（3）String concat(xx)：拼接</p><p> （4）boolean equals(Object obj)：比较字符串是否相等，区分大小写</p><p>（5）boolean equalsIgnoreCase(Object obj)：比较字符串是否相等，不区分大小写</p><p>（6）int compareTo(String other)：比较字符串大小，区分大小写，按照Unicode编码值比较大小</p><p>（7）int compareToIgnoreCase(String other)：比较字符串大小，不区分大小写</p><p>（8）String toLowerCase()：将字符串中大写字母转为小写</p><p>（9）String toUpperCase()：将字符串中小写字母转为大写</p><p>（10）String trim()：去掉字符串前后空白符</p><p>（11）public String intern()：结果在常量池中共享</p><ul><li>可变字符序列<code>StringBuilder</code>和<code>StringBuffer</code> 前者线程不安全，后者线程安全 两者常用api一致</li></ul><p>（1）StringBuffer append(xx)：提供了很多的append()方法，用于进行字符串追加的方式拼接</p><p>（2）StringBuffer delete(int start, int end)：删除[start,end)之间字符</p><p>（3）StringBuffer deleteCharAt(int index)：删除[index]位置字符</p><p>（4）StringBuffer replace(int start, int end, String str)：替换[start,end)范围的字符序列为str</p><p>（5）void setCharAt(int index, char c)：替换[index]位置字符</p><p>（6）char charAt(int index)：查找指定index位置上的字符</p><p>（7）StringBuffer insert(int index, xx)：在[index]位置插入xx</p><p>（8）int length()：返回存储的字符数据的长度</p><p>（9）StringBuffer reverse()：反转</p><h4 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h4><p>直接模拟过程就行</p><h3 id="1071字符串的最大公因子"><a href="#1071字符串的最大公因子" class="headerlink" title="1071字符串的最大公因子"></a>1071字符串的最大公因子</h3><h3 id="344-反转字符串"><a href="#344-反转字符串" class="headerlink" title="344 反转字符串"></a>344 反转字符串</h3><ul><li>双指针秒了</li></ul><h3 id="541-反转字符串2"><a href="#541-反转字符串2" class="headerlink" title="541 反转字符串2"></a>541 反转字符串2</h3><p>难点就在如何去除多余的空格：这其实就是删除元素的算法，需要使用<strong>快慢指针</strong>的方法: 快指针寻找符合要求的字母（要收集的字母）、慢指针就是来表示要更新在哪里</p><p>题目要求：</p><ul><li>输入: “the sky is blue”</li><li>输出: “blue is sky the”</li><li>输入字符串可以在前面或者后面包含多余的空格，但是反转后的字符不能包括。</li><li>如果两个单词间有多余的空格，将反转后单词间的空格减少到只含一个。</li></ul><p>解题思路：</p><ul><li>将整个字符串都反转过来，那么单词的顺序指定是倒序了，只不过单词本身也倒序了，那么再把单词反转一下，单词不就正过来了。</li></ul><p>所以解题思路如下：</p><ul><li>移除多余空格</li><li>将整个字符串反转</li><li>将每个单词反转</li></ul><h3 id="KMP算法"><a href="#KMP算法" class="headerlink" title="KMP算法"></a>KMP算法</h3><ul><li>用以解决字符串匹配的问题 <strong>我直接放弃</strong></li></ul><h2 id="双指针法"><a href="#双指针法" class="headerlink" title="双指针法"></a>双指针法</h2><h3 id="27-移除元素"><a href="#27-移除元素" class="headerlink" title="27 移除元素"></a>27 移除元素</h3><ul><li><p>暴力法：两层for循环</p></li><li><p>双指针法:</p><ul><li>快指针：遍历旧数组</li><li>慢指针：指向新数组下标</li></ul></li></ul><h3 id="19-移除链表倒数第N个元素"><a href="#19-移除链表倒数第N个元素" class="headerlink" title="19 移除链表倒数第N个元素"></a>19 移除链表倒数第N个元素</h3><ul><li>双指针法,让fast先移动n个，然后同时移动fast和slow直到fast指向链表尾部，然后删除slow指向的节点即可</li></ul><h3 id="459-重复的子字符串"><a href="#459-重复的子字符串" class="headerlink" title="459 重复的子字符串"></a>459 重复的子字符串</h3><ul><li>暴力法：一个for循环获取字串的终止位置，然后另一个for循环判断字串是否能重复构成字符串；不需要遍历到结尾，只需要遍历到中间位置，因为子串结束位置大于中间位置的话，一定不能重复组成字符串。</li></ul><h3 id="链表相交"><a href="#链表相交" class="headerlink" title="链表相交"></a>链表相交</h3><ul><li><p>两链表相交的起始节点，代表指针相同，而不是值相同</p></li><li><p>如下图 只要定义两个指针 同时移动，如若有交点 一定会左a+c+b步之后相遇</p><p><img src="/home/time/%E6%96%87%E6%A1%A3/Notes/%E5%90%8E%E7%AB%AF%E5%BC%80%E5%8F%91%E6%B1%82%E8%81%8C%E7%AC%94%E8%AE%B0/%E7%AE%97%E6%B3%95.assets/image-20240628210035695.png" alt="image-20240628210035695"></p></li></ul><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><h3 id="9-回文数"><a href="#9-回文数" class="headerlink" title="9. 回文数"></a>9. 回文数</h3><ul><li>反转后看是否和原来的数字相等</li></ul><p>将整数反转的代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">reverseNum</span><span class="params">(<span class="type">int</span> x )</span>&#123;</span><br><span class="line">  <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> x;</span><br><span class="line">  <span class="type">int</span> <span class="variable">rev</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">while</span> (temp != <span class="number">0</span>)&#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">p</span> <span class="operator">=</span> temp % <span class="number">10</span>;</span><br><span class="line">    temp = temp / <span class="number">10</span>;</span><br><span class="line">    rev = rev * <span class="number">10</span> + p;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> rev;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;总体思路&quot;&gt;&lt;a href=&quot;#总体思路&quot; class=&quot;headerlink&quot; title=&quot;总体思路&quot;&gt;&lt;/a&gt;总体思路&lt;/h2&gt;&lt;h2 id=&quot;测开岗高频算法题&quot;&gt;&lt;a href=&quot;#测开岗高频算法题&quot; class=&quot;headerlink&quot; title=&quot;测</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Docker笔记</title>
    <link href="http://www.meprotoss.com/undefined/5c266b64.html"/>
    <id>http://www.meprotoss.com/undefined/5c266b64.html</id>
    <published>2024-05-10T03:33:55.000Z</published>
    <updated>2024-09-23T07:24:51.192Z</updated>
    
    <content type="html"><![CDATA[<h2 id="docker-是什么？"><a href="#docker-是什么？" class="headerlink" title="docker 是什么？"></a>docker 是什么？</h2><ul><li>docker 独立的容器（container），可以跨系统的运行打包好的程序</li></ul><h2 id="docker-常见命令"><a href="#docker-常见命令" class="headerlink" title="docker 常见命令"></a>docker 常见命令</h2><p>停止所有正在运行的容器并且删除所有容器</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker stop $(docker ps -aq) &amp;&amp; docker rm $(docker ps -aq)</span><br></pre></td></tr></table></figure><p><img src="/home/time/%E6%96%87%E6%A1%A3/Notes/%E5%90%8E%E7%AB%AF%E5%BC%80%E5%8F%91%E6%B1%82%E8%81%8C%E7%AC%94%E8%AE%B0/Docker%E7%AC%94%E8%AE%B0.assets/image-20240702142158297.png" alt="image-20240702142158297"></p><h2 id="使用docker的demo"><a href="#使用docker的demo" class="headerlink" title="使用docker的demo"></a>使用docker的demo</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">从dockerhub镜像仓库拉取镜像（image）</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">第1步，去DockerHub查看nginx镜像仓库及相关信息</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">第2步，拉取Nginx镜像</span></span><br><span class="line">docker pull nginx</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">第3步，查看镜像</span></span><br><span class="line">docker images</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">结果如下：</span></span><br><span class="line">REPOSITORY   TAG       IMAGE ID       CREATED         SIZE</span><br><span class="line">nginx        latest    605c77e624dd   16 months ago   141MB</span><br><span class="line">mysql        latest    3218b38490ce   17 months ago   516MB</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">第4步，创建并运行Nginx容器</span></span><br><span class="line">docker run -d --name nginx -p 80:80 nginx</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">第5步，查看运行中容器</span></span><br><span class="line">docker ps</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">也可以加格式化方式访问，格式会更加清爽</span></span><br><span class="line">docker ps --format &quot;table &#123;&#123;.ID&#125;&#125;\t&#123;&#123;.Image&#125;&#125;\t&#123;&#123;.Ports&#125;&#125;\t&#123;&#123;.Status&#125;&#125;\t&#123;&#123;.Names&#125;&#125;&quot;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">第6步，访问网页，地址：http://虚拟机地址</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">第7步，停止容器</span></span><br><span class="line">docker stop nginx</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">第8步，查看所有容器,将还指令<span class="built_in">alias</span> 为dps 格式化查看容器</span></span><br><span class="line">docker ps -a --format &quot;table &#123;&#123;.ID&#125;&#125;\t&#123;&#123;.Image&#125;&#125;\t&#123;&#123;.Ports&#125;&#125;\t&#123;&#123;.Status&#125;&#125;\t&#123;&#123;.Names&#125;&#125;&quot;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">第9步，再次启动nginx容器</span></span><br><span class="line">docker start nginx</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">第10步，再次查看容器</span></span><br><span class="line">docker ps --format &quot;table &#123;&#123;.ID&#125;&#125;\t&#123;&#123;.Image&#125;&#125;\t&#123;&#123;.Ports&#125;&#125;\t&#123;&#123;.Status&#125;&#125;\t&#123;&#123;.Names&#125;&#125;&quot;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">第11步，查看容器详细信息</span></span><br><span class="line">docker inspect nginx</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">第12步，进入容器,查看容器内目录</span></span><br><span class="line">docker exec -it nginx bash</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">或者，可以进入MySQL</span></span><br><span class="line">docker exec -it mysql mysql -uroot -p</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">第13步，删除容器</span></span><br><span class="line">docker rm nginx</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">发现无法删除，因为容器运行中，强制删除容器</span></span><br><span class="line">docker rm -f nginx</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="挂载宿主机目录和容器内目录"><a href="#挂载宿主机目录和容器内目录" class="headerlink" title="挂载宿主机目录和容器内目录"></a>挂载宿主机目录和容器内目录</h2><h3 id="方法1-通过数据卷间接挂载（较为繁琐-不常用）"><a href="#方法1-通过数据卷间接挂载（较为繁琐-不常用）" class="headerlink" title="方法1:通过数据卷间接挂载（较为繁琐 不常用）"></a>方法1:通过数据卷间接挂载（较为繁琐 不常用）</h3><ul><li>数据卷（volume）是一个虚拟目录，是容器内目录与宿主机目录之间映射的桥梁。</li><li>容器与数据卷的挂载要在创建容器时配置，对于创建好的容器，是不能设置数据卷的。而且创建容器的过程中，数据卷会自动创建。</li></ul><h4 id="demo"><a href="#demo" class="headerlink" title="demo"></a>demo</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">1.首先创建容器并指定数据卷，注意通过 -v 参数来指定数据卷</span></span><br><span class="line">docker run -d --name nginx -p 80:80 -v html:/usr/share/nginx/html nginx</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">2.然后查看数据卷</span></span><br><span class="line">docker volume ls</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">结果</span></span><br><span class="line">DRIVER    VOLUME NAME</span><br><span class="line">local     29524ff09715d3688eae3f99803a2796558dbd00ca584a25a4bbc193ca82459f</span><br><span class="line">local     html</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">3.查看数据卷详情</span></span><br><span class="line">docker volume inspect html</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">结果</span></span><br><span class="line">[</span><br><span class="line">&#123;</span><br><span class="line">  &quot;CreatedAt&quot;: &quot;2024-05-17T19:57:08+08:00&quot;,</span><br><span class="line">    &quot;Driver&quot;: &quot;local&quot;,</span><br><span class="line">    &quot;Labels&quot;: null,</span><br><span class="line">    &quot;Mountpoint&quot;: &quot;/var/lib/docker/volumes/html/_data&quot;,</span><br><span class="line">    &quot;Name&quot;: &quot;html&quot;,</span><br><span class="line">    &quot;Options&quot;: null,</span><br><span class="line">    &quot;Scope&quot;: &quot;local&quot;</span><br><span class="line">&#125;</span><br><span class="line">]</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">4.查看/var/lib/docker/volumes/html/_data目录</span></span><br><span class="line">ll /var/lib/docker/volumes/html/_data</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">可以看到与nginx的html目录内容一样，结果如下：</span></span><br><span class="line">总用量 8</span><br><span class="line">-rw-r--r--. 1 root root 497 12月 28 2021 50x.html</span><br><span class="line">-rw-r--r--. 1 root root 615 12月 28 2021 index.html</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">5.进入该目录，并随意修改index.html内容</span></span><br><span class="line">cd /var/lib/docker/volumes/html/_data</span><br><span class="line">vi index.html</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">6.打开页面，查看效果</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">7.进入容器内部，查看/usr/share/nginx/html目录内的文件是否变化</span></span><br><span class="line">docker exec -it nginx bash</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="法二：不通过数据卷直接挂载"><a href="#法二：不通过数据卷直接挂载" class="headerlink" title="法二：不通过数据卷直接挂载"></a>法二：不通过数据卷直接挂载</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">挂载本地目录</span></span><br><span class="line">-v 本地目录:容器内目录</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">挂载本地文件</span></span><br><span class="line">-v 本地文件:容器内文件</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="构建docker镜像"><a href="#构建docker镜像" class="headerlink" title="构建docker镜像"></a>构建docker镜像</h2><ol><li>编写<code>Dockerfile</code> 文件，其对应的语法可以参考官方文档：<a href="https://docs.docker.com/engine/reference/builder/">官方文档</a></li><li>构建镜像</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 进入镜像目录</span></span><br><span class="line"><span class="built_in">cd</span> /root/demo</span><br><span class="line"><span class="comment"># 开始构建</span></span><br><span class="line">docker build -t [镜像名称]:[TAG(不写默认为latest)] [Dockerfile所在目录]</span><br></pre></td></tr></table></figure><h2 id="Docker自定义网络"><a href="#Docker自定义网络" class="headerlink" title="Docker自定义网络"></a>Docker自定义网络</h2><p>自定义网络，在同一个网络中的容器可以互联</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 1.首先通过命令创建一个网络</span></span><br><span class="line">docker network create hmall</span><br><span class="line"></span><br><span class="line"><span class="comment"># 2.然后查看网络</span></span><br><span class="line">docker network <span class="built_in">ls</span></span><br><span class="line"><span class="comment"># 结果：</span></span><br><span class="line">NETWORK ID     NAME      DRIVER    SCOPE</span><br><span class="line">639bc44d0a87   bridge    bridge    <span class="built_in">local</span></span><br><span class="line">403f16ec62a2   hmall     bridge    <span class="built_in">local</span></span><br><span class="line">0dc0f72a0fbb   host      host      <span class="built_in">local</span></span><br><span class="line">cd8d3e8df47b   none      null      <span class="built_in">local</span></span><br><span class="line"><span class="comment"># 其中，除了hmall以外，其它都是默认的网络</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 3.让dd和mysql都加入该网络，注意，在加入网络时可以通过--alias给容器起别名</span></span><br><span class="line"><span class="comment"># 这样该网络内的其它容器可以用别名互相访问！</span></span><br><span class="line"><span class="comment"># 3.1.mysql容器，指定别名为db，另外每一个容器都有一个别名是容器名</span></span><br><span class="line">docker network connect hmall mysql --<span class="built_in">alias</span> db</span><br><span class="line"><span class="comment"># 3.2.db容器，也就是我们的java项目</span></span><br><span class="line">docker network connect hmall <span class="built_in">dd</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 4.进入dd容器，尝试利用别名访问db</span></span><br><span class="line"><span class="comment"># 4.1.进入容器</span></span><br><span class="line">docker <span class="built_in">exec</span> -it <span class="built_in">dd</span> bash</span><br><span class="line"><span class="comment"># 4.2.用db别名访问</span></span><br><span class="line">ping db</span><br><span class="line"><span class="comment"># 结果</span></span><br><span class="line">PING db (172.18.0.2) 56(84) bytes of data.</span><br><span class="line">64 bytes from mysql.hmall (172.18.0.2): icmp_seq=1 ttl=64 time=0.070 ms</span><br><span class="line">64 bytes from mysql.hmall (172.18.0.2): icmp_seq=2 ttl=64 time=0.056 ms</span><br><span class="line"><span class="comment"># 4.3.用容器名访问</span></span><br><span class="line">ping mysql</span><br><span class="line"><span class="comment"># 结果：</span></span><br><span class="line">PING mysql (172.18.0.2) 56(84) bytes of data.</span><br><span class="line">64 bytes from mysql.hmall (172.18.0.2): icmp_seq=1 ttl=64 time=0.044 ms</span><br><span class="line">64 bytes from mysql.hmall (172.18.0.2): icmp_seq=2 ttl=64 time=0.054 ms</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;docker-是什么？&quot;&gt;&lt;a href=&quot;#docker-是什么？&quot; class=&quot;headerlink&quot; title=&quot;docker 是什么？&quot;&gt;&lt;/a&gt;docker 是什么？&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;docker 独立的容器（container），可以跨系</summary>
      
    
    
    
    
    <category term="计算机基础" scheme="http://www.meprotoss.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>Java新特性</title>
    <link href="http://www.meprotoss.com/undefined/9ac696fa.html"/>
    <id>http://www.meprotoss.com/undefined/9ac696fa.html</id>
    <published>2024-05-08T14:54:02.000Z</published>
    <updated>2024-05-08T16:09:44.776Z</updated>
    
    <content type="html"><![CDATA[<h2 id="函数式接口-functional-interface"><a href="#函数式接口-functional-interface" class="headerlink" title="函数式接口(functional interface)"></a>函数式接口(functional interface)</h2><p>定义：也称 SAM 接口，即 Single Abstract Method interfaces，有且只有一个抽象方法，但可以有多个非抽象方法的接口。</p><p>在 java 8 中专门有一个包放函数式接口java.util.function，该包下的所有接口都有 @FunctionalInterface 注解，提供函数式编程。在其他包中也有函数式接口，其中一些没有@FunctionalInterface 注解，但是只要符合函数式接口的定义就是函数式接口，与是否有@FunctionalInterface注解无关，注解只是在编译时起到强制规范定义的作用。其在 Lambda 表达式中有广泛的应用。</p><p>基本上，函数式编程是一种编程风格，它将计算看作为是数学函数的求值。</p><p>在数学中，函数是将输入集与输出集相关联的表达式。函数的输出仅取决于其输入。我们也可以将两个或多个函数组合在一起得到一个新函数</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;函数式接口-functional-interface&quot;&gt;&lt;a href=&quot;#函数式接口-functional-interface&quot; class=&quot;headerlink&quot; title=&quot;函数式接口(functional interface)&quot;&gt;&lt;/a&gt;函数式接口(f</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Linux系统疑难杂症</title>
    <link href="http://www.meprotoss.com/undefined/c66bafdb.html"/>
    <id>http://www.meprotoss.com/undefined/c66bafdb.html</id>
    <published>2024-05-07T01:36:08.000Z</published>
    <updated>2024-07-01T05:55:31.047Z</updated>
    
    <content type="html"><![CDATA[<h2 id="ideaVim中英文输入法切换问题"><a href="#ideaVim中英文输入法切换问题" class="headerlink" title="ideaVim中英文输入法切换问题"></a>ideaVim中英文输入法切换问题</h2><ol><li>安装ideaVimExtension 插件</li><li>.ideavimrc中开启</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">set keep-english-in-normal</span><br><span class="line">set keep-english-in-normal-and-restore-in-insert</span><br></pre></td></tr></table></figure><h2 id="idea中输入法不跟随鼠标的问题"><a href="#idea中输入法不跟随鼠标的问题" class="headerlink" title="idea中输入法不跟随鼠标的问题"></a>idea中输入法不跟随鼠标的问题</h2><h3 id="问题原因"><a href="#问题原因" class="headerlink" title="问题原因"></a>问题原因</h3><p>具体问题官方其实七年前就有了（参考 <a href="https://youtrack.jetbrains.com/issue/JBR-2460%EF%BC%89%EF%BC%8C%E4%BD%86%E6%98%AF%E6%AF%94%E8%BE%83%E5%9D%91%E7%9A%84%E6%98%AF%E5%AE%98%E6%96%B9%E4%B9%9F%E4%B8%80%E7%9B%B4%E6%B2%A1%E6%9C%89%E8%A7%A3%E5%86%B3%E8%BF%99%E4%B8%AA%E9%97%AE%E9%A2%98%F0%9F%90%B6%EF%BC%88%E6%AD%A4%E5%A4%84%E5%BF%8D%E4%B8%8D%E4%BD%8F%E5%90%90%E6%A7%BD%E4%B8%80%E4%B8%8B%E5%93%88%EF%BC%89%E3%80%82%E7%AE%80%E5%8D%95%E6%9D%A5%E8%AF%B4%E5%B0%B1%E6%98%AF">https://youtrack.jetbrains.com/issue/JBR-2460），但是比较坑的是官方也一直没有解决这个问题🐶（此处忍不住吐槽一下哈）。简单来说就是</a> Idea 的 jre 运行环境一个 bug，导致输入法无法定位到鼠标位置。因此，我们要解决该问题必须要修改 JetBrainsRuntime 的运行代码。</p><h3 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h3><ul><li>下载已经修改好的 JRE 环境<br><a href="https://www.jianguoyun.com/p/De33XAgQ89jhCRjDh8EFIAA%EF%BC%9A">下载地址</a></li><li>替换idea目录的JRE</li></ul><h2 id="无法识别移动硬盘和U盘"><a href="#无法识别移动硬盘和U盘" class="headerlink" title="无法识别移动硬盘和U盘"></a>无法识别移动硬盘和U盘</h2><h3 id="问题原因-1"><a href="#问题原因-1" class="headerlink" title="问题原因"></a>问题原因</h3><p>文件系统不兼容</p><h3 id="解决方法-1"><a href="#解决方法-1" class="headerlink" title="解决方法"></a>解决方法</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo pacman -S ntfs-3g</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="steam加速"><a href="#steam加速" class="headerlink" title="steam加速"></a>steam加速</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">yay -S watt-toolkit-bin</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;ideaVim中英文输入法切换问题&quot;&gt;&lt;a href=&quot;#ideaVim中英文输入法切换问题&quot; class=&quot;headerlink&quot; title=&quot;ideaVim中英文输入法切换问题&quot;&gt;&lt;/a&gt;ideaVim中英文输入法切换问题&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;安装id</summary>
      
    
    
    
    
  </entry>
  
</feed>
