<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>CHEN先生的小站</title>
  
  <subtitle>忽有故人心上过</subtitle>
  <link href="http://www.meprotoss.com/atom.xml" rel="self"/>
  
  <link href="http://www.meprotoss.com/"/>
  <updated>2024-05-10T03:34:20.216Z</updated>
  <id>http://www.meprotoss.com/</id>
  
  <author>
    <name>Mr.Chen</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Docker笔记</title>
    <link href="http://www.meprotoss.com/undefined/5c266b64.html"/>
    <id>http://www.meprotoss.com/undefined/5c266b64.html</id>
    <published>2024-05-10T03:33:55.000Z</published>
    <updated>2024-05-10T03:34:20.216Z</updated>
    
    <content type="html"><![CDATA[<h2 id="docker-是什么？"><a href="#docker-是什么？" class="headerlink" title="docker 是什么？"></a>docker 是什么？</h2><ul><li>docker 独立的容器（container），可以跨系统的运行打包好的程序</li></ul><h2 id="docker-常见命令"><a href="#docker-常见命令" class="headerlink" title="docker 常见命令"></a>docker 常见命令</h2><p><a href="https://b11et3un53m.feishu.cn/docx/Wq51d3o2koFiptxqby9cHTNznpd?openbrd=1&doc_app_id=501&blockId=FSOjd6yPIoTyvjxJFqBclOignxh&blockType=whiteboard&blockToken=RoUSwA3I5hXhLib69YScieXXnBb#FSOjd6yPIoTyvjxJFqBclOignxh">docker命令图解</a></p><h2 id="使用docker的demo"><a href="#使用docker的demo" class="headerlink" title="使用docker的demo"></a>使用docker的demo</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">从dockerhub镜像仓库拉取镜像（image）</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">第1步，去DockerHub查看nginx镜像仓库及相关信息</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">第2步，拉取Nginx镜像</span></span><br><span class="line">docker pull nginx</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">第3步，查看镜像</span></span><br><span class="line">docker images</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">结果如下：</span></span><br><span class="line">REPOSITORY   TAG       IMAGE ID       CREATED         SIZE</span><br><span class="line">nginx        latest    605c77e624dd   16 months ago   141MB</span><br><span class="line">mysql        latest    3218b38490ce   17 months ago   516MB</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">第4步，创建并运行Nginx容器</span></span><br><span class="line">docker run -d --name nginx -p 80:80 nginx</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">第5步，查看运行中容器</span></span><br><span class="line">docker ps</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">也可以加格式化方式访问，格式会更加清爽</span></span><br><span class="line">docker ps --format &quot;table &#123;&#123;.ID&#125;&#125;\t&#123;&#123;.Image&#125;&#125;\t&#123;&#123;.Ports&#125;&#125;\t&#123;&#123;.Status&#125;&#125;\t&#123;&#123;.Names&#125;&#125;&quot;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">第6步，访问网页，地址：http://虚拟机地址</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">第7步，停止容器</span></span><br><span class="line">docker stop nginx</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">第8步，查看所有容器,将还指令<span class="built_in">alias</span> 为dps 格式化查看容器</span></span><br><span class="line">docker ps -a --format &quot;table &#123;&#123;.ID&#125;&#125;\t&#123;&#123;.Image&#125;&#125;\t&#123;&#123;.Ports&#125;&#125;\t&#123;&#123;.Status&#125;&#125;\t&#123;&#123;.Names&#125;&#125;&quot;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">第9步，再次启动nginx容器</span></span><br><span class="line">docker start nginx</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">第10步，再次查看容器</span></span><br><span class="line">docker ps --format &quot;table &#123;&#123;.ID&#125;&#125;\t&#123;&#123;.Image&#125;&#125;\t&#123;&#123;.Ports&#125;&#125;\t&#123;&#123;.Status&#125;&#125;\t&#123;&#123;.Names&#125;&#125;&quot;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">第11步，查看容器详细信息</span></span><br><span class="line">docker inspect nginx</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">第12步，进入容器,查看容器内目录</span></span><br><span class="line">docker exec -it nginx bash</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">或者，可以进入MySQL</span></span><br><span class="line">docker exec -it mysql mysql -uroot -p</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">第13步，删除容器</span></span><br><span class="line">docker rm nginx</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">发现无法删除，因为容器运行中，强制删除容器</span></span><br><span class="line">docker rm -f nginx</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="挂载宿主机目录和容器内目录"><a href="#挂载宿主机目录和容器内目录" class="headerlink" title="挂载宿主机目录和容器内目录"></a>挂载宿主机目录和容器内目录</h2><h3 id="方法1-通过数据卷间接挂载（较为繁琐-不常用）"><a href="#方法1-通过数据卷间接挂载（较为繁琐-不常用）" class="headerlink" title="方法1:通过数据卷间接挂载（较为繁琐 不常用）"></a>方法1:通过数据卷间接挂载（较为繁琐 不常用）</h3><ul><li>数据卷（volume）是一个虚拟目录，是容器内目录与宿主机目录之间映射的桥梁。</li><li>容器与数据卷的挂载要在创建容器时配置，对于创建好的容器，是不能设置数据卷的。而且创建容器的过程中，数据卷会自动创建。</li></ul><h4 id="demo"><a href="#demo" class="headerlink" title="demo"></a>demo</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">1.首先创建容器并指定数据卷，注意通过 -v 参数来指定数据卷</span></span><br><span class="line">docker run -d --name nginx -p 80:80 -v html:/usr/share/nginx/html nginx</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">2.然后查看数据卷</span></span><br><span class="line">docker volume ls</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">结果</span></span><br><span class="line">DRIVER    VOLUME NAME</span><br><span class="line">local     29524ff09715d3688eae3f99803a2796558dbd00ca584a25a4bbc193ca82459f</span><br><span class="line">local     html</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">3.查看数据卷详情</span></span><br><span class="line">docker volume inspect html</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">结果</span></span><br><span class="line">[</span><br><span class="line">&#123;</span><br><span class="line">  &quot;CreatedAt&quot;: &quot;2024-05-17T19:57:08+08:00&quot;,</span><br><span class="line">    &quot;Driver&quot;: &quot;local&quot;,</span><br><span class="line">    &quot;Labels&quot;: null,</span><br><span class="line">    &quot;Mountpoint&quot;: &quot;/var/lib/docker/volumes/html/_data&quot;,</span><br><span class="line">    &quot;Name&quot;: &quot;html&quot;,</span><br><span class="line">    &quot;Options&quot;: null,</span><br><span class="line">    &quot;Scope&quot;: &quot;local&quot;</span><br><span class="line">&#125;</span><br><span class="line">]</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">4.查看/var/lib/docker/volumes/html/_data目录</span></span><br><span class="line">ll /var/lib/docker/volumes/html/_data</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">可以看到与nginx的html目录内容一样，结果如下：</span></span><br><span class="line">总用量 8</span><br><span class="line">-rw-r--r--. 1 root root 497 12月 28 2021 50x.html</span><br><span class="line">-rw-r--r--. 1 root root 615 12月 28 2021 index.html</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">5.进入该目录，并随意修改index.html内容</span></span><br><span class="line">cd /var/lib/docker/volumes/html/_data</span><br><span class="line">vi index.html</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">6.打开页面，查看效果</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">7.进入容器内部，查看/usr/share/nginx/html目录内的文件是否变化</span></span><br><span class="line">docker exec -it nginx bash</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="法二：不通过数据卷直接挂载"><a href="#法二：不通过数据卷直接挂载" class="headerlink" title="法二：不通过数据卷直接挂载"></a>法二：不通过数据卷直接挂载</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">挂载本地目录</span></span><br><span class="line">-v 本地目录:容器内目录</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">挂载本地文件</span></span><br><span class="line">-v 本地文件:容器内文件</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="构建docker镜像"><a href="#构建docker镜像" class="headerlink" title="构建docker镜像"></a>构建docker镜像</h2><ol><li>编写<code>Dockerfile</code> 文件，其对应的语法可以参考官方文档：<a href="https://docs.docker.com/engine/reference/builder/">官方文档</a></li><li>构建镜像</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 进入镜像目录</span></span><br><span class="line"><span class="built_in">cd</span> /root/demo</span><br><span class="line"><span class="comment"># 开始构建</span></span><br><span class="line">docker build -t [镜像名称]:[TAG(不写默认为latest)] [Dockerfile所在目录]</span><br></pre></td></tr></table></figure><h2 id="Docker自定义网络"><a href="#Docker自定义网络" class="headerlink" title="Docker自定义网络"></a>Docker自定义网络</h2><p>自定义网络，在同一个网络中的容器可以互联</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 1.首先通过命令创建一个网络</span></span><br><span class="line">docker network create hmall</span><br><span class="line"></span><br><span class="line"><span class="comment"># 2.然后查看网络</span></span><br><span class="line">docker network <span class="built_in">ls</span></span><br><span class="line"><span class="comment"># 结果：</span></span><br><span class="line">NETWORK ID     NAME      DRIVER    SCOPE</span><br><span class="line">639bc44d0a87   bridge    bridge    <span class="built_in">local</span></span><br><span class="line">403f16ec62a2   hmall     bridge    <span class="built_in">local</span></span><br><span class="line">0dc0f72a0fbb   host      host      <span class="built_in">local</span></span><br><span class="line">cd8d3e8df47b   none      null      <span class="built_in">local</span></span><br><span class="line"><span class="comment"># 其中，除了hmall以外，其它都是默认的网络</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 3.让dd和mysql都加入该网络，注意，在加入网络时可以通过--alias给容器起别名</span></span><br><span class="line"><span class="comment"># 这样该网络内的其它容器可以用别名互相访问！</span></span><br><span class="line"><span class="comment"># 3.1.mysql容器，指定别名为db，另外每一个容器都有一个别名是容器名</span></span><br><span class="line">docker network connect hmall mysql --<span class="built_in">alias</span> db</span><br><span class="line"><span class="comment"># 3.2.db容器，也就是我们的java项目</span></span><br><span class="line">docker network connect hmall <span class="built_in">dd</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 4.进入dd容器，尝试利用别名访问db</span></span><br><span class="line"><span class="comment"># 4.1.进入容器</span></span><br><span class="line">docker <span class="built_in">exec</span> -it <span class="built_in">dd</span> bash</span><br><span class="line"><span class="comment"># 4.2.用db别名访问</span></span><br><span class="line">ping db</span><br><span class="line"><span class="comment"># 结果</span></span><br><span class="line">PING db (172.18.0.2) 56(84) bytes of data.</span><br><span class="line">64 bytes from mysql.hmall (172.18.0.2): icmp_seq=1 ttl=64 time=0.070 ms</span><br><span class="line">64 bytes from mysql.hmall (172.18.0.2): icmp_seq=2 ttl=64 time=0.056 ms</span><br><span class="line"><span class="comment"># 4.3.用容器名访问</span></span><br><span class="line">ping mysql</span><br><span class="line"><span class="comment"># 结果：</span></span><br><span class="line">PING mysql (172.18.0.2) 56(84) bytes of data.</span><br><span class="line">64 bytes from mysql.hmall (172.18.0.2): icmp_seq=1 ttl=64 time=0.044 ms</span><br><span class="line">64 bytes from mysql.hmall (172.18.0.2): icmp_seq=2 ttl=64 time=0.054 ms</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;docker-是什么？&quot;&gt;&lt;a href=&quot;#docker-是什么？&quot; class=&quot;headerlink&quot; title=&quot;docker 是什么？&quot;&gt;&lt;/a&gt;docker 是什么？&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;docker 独立的容器（container），可以跨系</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Java新特性</title>
    <link href="http://www.meprotoss.com/undefined/9ac696fa.html"/>
    <id>http://www.meprotoss.com/undefined/9ac696fa.html</id>
    <published>2024-05-08T14:54:02.000Z</published>
    <updated>2024-05-08T16:09:44.776Z</updated>
    
    <content type="html"><![CDATA[<h2 id="函数式接口-functional-interface"><a href="#函数式接口-functional-interface" class="headerlink" title="函数式接口(functional interface)"></a>函数式接口(functional interface)</h2><p>定义：也称 SAM 接口，即 Single Abstract Method interfaces，有且只有一个抽象方法，但可以有多个非抽象方法的接口。</p><p>在 java 8 中专门有一个包放函数式接口java.util.function，该包下的所有接口都有 @FunctionalInterface 注解，提供函数式编程。在其他包中也有函数式接口，其中一些没有@FunctionalInterface 注解，但是只要符合函数式接口的定义就是函数式接口，与是否有@FunctionalInterface注解无关，注解只是在编译时起到强制规范定义的作用。其在 Lambda 表达式中有广泛的应用。</p><p>基本上，函数式编程是一种编程风格，它将计算看作为是数学函数的求值。</p><p>在数学中，函数是将输入集与输出集相关联的表达式。函数的输出仅取决于其输入。我们也可以将两个或多个函数组合在一起得到一个新函数</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;函数式接口-functional-interface&quot;&gt;&lt;a href=&quot;#函数式接口-functional-interface&quot; class=&quot;headerlink&quot; title=&quot;函数式接口(functional interface)&quot;&gt;&lt;/a&gt;函数式接口(f</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Linux系统疑难杂症</title>
    <link href="http://www.meprotoss.com/undefined/c66bafdb.html"/>
    <id>http://www.meprotoss.com/undefined/c66bafdb.html</id>
    <published>2024-05-07T01:36:08.000Z</published>
    <updated>2024-05-07T14:09:10.937Z</updated>
    
    <content type="html"><![CDATA[<h2 id="ideaVim中英文输入法切换问题"><a href="#ideaVim中英文输入法切换问题" class="headerlink" title="ideaVim中英文输入法切换问题"></a>ideaVim中英文输入法切换问题</h2><ol><li>安装ideaVimExtension 插件</li><li>.ideavimrc中开启</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">set keep-english-in-normal</span><br><span class="line">set keep-english-in-normal-and-restore-in-insert</span><br></pre></td></tr></table></figure><h2 id="idea中输入法不跟随鼠标的问题"><a href="#idea中输入法不跟随鼠标的问题" class="headerlink" title="idea中输入法不跟随鼠标的问题"></a>idea中输入法不跟随鼠标的问题</h2><h3 id="问题原因"><a href="#问题原因" class="headerlink" title="问题原因"></a>问题原因</h3><p>具体问题官方其实七年前就有了（参考 <a href="https://youtrack.jetbrains.com/issue/JBR-2460%EF%BC%89%EF%BC%8C%E4%BD%86%E6%98%AF%E6%AF%94%E8%BE%83%E5%9D%91%E7%9A%84%E6%98%AF%E5%AE%98%E6%96%B9%E4%B9%9F%E4%B8%80%E7%9B%B4%E6%B2%A1%E6%9C%89%E8%A7%A3%E5%86%B3%E8%BF%99%E4%B8%AA%E9%97%AE%E9%A2%98%F0%9F%90%B6%EF%BC%88%E6%AD%A4%E5%A4%84%E5%BF%8D%E4%B8%8D%E4%BD%8F%E5%90%90%E6%A7%BD%E4%B8%80%E4%B8%8B%E5%93%88%EF%BC%89%E3%80%82%E7%AE%80%E5%8D%95%E6%9D%A5%E8%AF%B4%E5%B0%B1%E6%98%AF">https://youtrack.jetbrains.com/issue/JBR-2460），但是比较坑的是官方也一直没有解决这个问题🐶（此处忍不住吐槽一下哈）。简单来说就是</a> Idea 的 jre 运行环境一个 bug，导致输入法无法定位到鼠标位置。因此，我们要解决该问题必须要修改 JetBrainsRuntime 的运行代码。</p><h3 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h3><ul><li>下载已经修改好的 JRE 环境<br><a href="https://www.jianguoyun.com/p/De33XAgQ89jhCRjDh8EFIAA%EF%BC%9A">下载地址</a></li><li>替换idea目录的JRE</li></ul><h2 id="无法识别移动硬盘和U盘"><a href="#无法识别移动硬盘和U盘" class="headerlink" title="无法识别移动硬盘和U盘"></a>无法识别移动硬盘和U盘</h2><h3 id="问题原因-1"><a href="#问题原因-1" class="headerlink" title="问题原因"></a>问题原因</h3><p>文件系统不兼容</p><h3 id="解决方法-1"><a href="#解决方法-1" class="headerlink" title="解决方法"></a>解决方法</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo pacman -S ntfs-3g</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;ideaVim中英文输入法切换问题&quot;&gt;&lt;a href=&quot;#ideaVim中英文输入法切换问题&quot; class=&quot;headerlink&quot; title=&quot;ideaVim中英文输入法切换问题&quot;&gt;&lt;/a&gt;ideaVim中英文输入法切换问题&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;安装id</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Java常见面试题总结</title>
    <link href="http://www.meprotoss.com/undefined/ec262441.html"/>
    <id>http://www.meprotoss.com/undefined/ec262441.html</id>
    <published>2024-05-06T10:05:37.000Z</published>
    <updated>2024-05-08T14:53:47.636Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h2><h3 id="前端"><a href="#前端" class="headerlink" title="前端"></a>前端</h3><h4 id="Axios"><a href="#Axios" class="headerlink" title="Axios"></a>Axios</h4><p>Axios 是一个流行的基于 Promise 的 HTTP 客户端，用于浏览器和 Node.js 环境。它使得在 JavaScript 中发送 AJAX 请求变得更加简单和便捷。<br>使用 Axios，你可以轻松地执行各种 HTTP 请求，例如 GET、POST 等，并处理响应数据。</p><h3 id="并发编程"><a href="#并发编程" class="headerlink" title="并发编程"></a>并发编程</h3><h4 id="ThreadLocal"><a href="#ThreadLocal" class="headerlink" title="ThreadLocal"></a>ThreadLocal</h4><h5 id="ThreadLocal有什么用？"><a href="#ThreadLocal有什么用？" class="headerlink" title="ThreadLocal有什么用？"></a>ThreadLocal有什么用？</h5><p>通常情况下，我们创建的变量是可以被任何一个线程访问并修改的。<br>如果想实现每一个线程都有自己的专属本地变量该如何解决呢？</p><p>DK 中自带的ThreadLocal类正是为了解决这样的问题。 ThreadLocal类主要解决的就是让每个线程绑定自己的值，可以将ThreadLocal类形象的比喻成存放数据的盒子，盒子中可以存储每个线程的私有数据。</p><p>如果你创建了一个ThreadLocal变量，那么访问这个变量的每个线程都会有这个变量的本地副本，这也是ThreadLocal变量名的由来。他们可以使用 get() 和 set() 方法来获取默认值或将其值更改为当前线程所存的副本的值，从而避免了线程安全问题。</p><h5 id="ThreadLocal内存泄露问题是怎么倒置的？"><a href="#ThreadLocal内存泄露问题是怎么倒置的？" class="headerlink" title="ThreadLocal内存泄露问题是怎么倒置的？"></a>ThreadLocal内存泄露问题是怎么倒置的？</h5><blockquote><p>[!TIP]<br>待施工</p></blockquote><h4 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h4><p>线程池就是管理一系列线程的资源池。<br>当有任务要处理时，直接从线程池中获取线程来处理，处理完之后线程并不会立即被销毁，而是等待下一个任务。</p><h5 id="为什么要用线程池？"><a href="#为什么要用线程池？" class="headerlink" title="为什么要用线程池？"></a>为什么要用线程池？</h5><p>池化技术想必大家已经屡见不鲜了，线程池、数据库连接池、HTTP 连接池等等都是对这个思想的应用。池化技术的思想主要是为了减少每次获取资源的消耗，提高对资源的利用率。</p><p>使用线程池的好处：</p><ul><li>降低资源消耗。通过重复利用已创建的线程降低线程创建和销毁造成的消耗。</li><li>提高响应速度。当任务到达时，任务可以不需要等到线程创建就能立即执行。</li><li>提高线程的可管理性。线程是稀缺资源，如果无限制的创建，不仅会消耗系统资源，还会降低系统的稳定性，使用线程池可以进行统一的分配，调优和监控。</li></ul><h5 id="如何创建线程池"><a href="#如何创建线程池" class="headerlink" title="如何创建线程池"></a>如何创建线程池</h5><p>法一：通过ThreadPoolExecutor构造函数来创建（推荐）。</p><p>法二：通过 Executor 框架的工具类 Executors 来创建。</p><p>Executors工具类可以创建多种类型的线程池，包括：</p><ul><li>FixedThreadPool：固定线程数量的线程池。该线程池中的线程数量始终不变。当有一个新的任务提交时，线程池中若有空闲线程，则立即执行。若没有，则新的任务会被暂存在一个任务队列中，待有线程空闲时，便处理在任务队列中的任务。</li><li>SingleThreadExecutor： 只有一个线程的线程池。若多余一个任务被提交到该线程池，任务会被保存在一个任务队列中，待线程空闲，按先入先出(队列)的顺序执行队列中的任务。</li><li>CachedThreadPool： 可根据实际情况调整线程数量的线程池。线程池的线程数量不确定，但若有空闲线程可以复用，则会优先使用可复用的线程。若所有线程均在工作，又有新的任务提交，则会创建新的线程处理任务。所有线程在当前任务执行完毕后，将返回线程池进行复用。</li><li>ScheduledThreadPool：给定的延迟后运行任务或者定期执行任务的线程池。</li></ul><h5 id="为什么不推荐使用内置线程池"><a href="#为什么不推荐使用内置线程池" class="headerlink" title="为什么不推荐使用内置线程池"></a>为什么不推荐使用内置线程池</h5><p>《阿里巴巴 Java 开发手册》“并发处理”这一章节，明确指出线程资源必须通过线程池提供，不允许在应用中自行显式创建线程。</p><ul><li>使用线程池的好处是减少在创建和销毁线程上所消耗的时间以及系统资源开销，解决资源不足的问题。如果不使用线程池，有可能会造成系统创建大量同类线程而导致消耗完内存或者“过度切换”的问题。</li></ul><p>另外，《阿里巴巴 Java 开发手册》中强制线程池不允许使用 Executors 去创建，而是通过 ThreadPoolExecutor 构造函数的方式，因为<code>Executors</code>容易导致OOM(out of memory)问题</p><h5 id="线程池常见参数"><a href="#线程池常见参数" class="headerlink" title="线程池常见参数"></a>线程池常见参数</h5><h5 id="线程池的拒绝策略有哪些？"><a href="#线程池的拒绝策略有哪些？" class="headerlink" title="线程池的拒绝策略有哪些？"></a>线程池的拒绝策略有哪些？</h5><h5 id="如果不允许丢弃任务任务，应该选择哪个拒绝策略？"><a href="#如果不允许丢弃任务任务，应该选择哪个拒绝策略？" class="headerlink" title="如果不允许丢弃任务任务，应该选择哪个拒绝策略？"></a>如果不允许丢弃任务任务，应该选择哪个拒绝策略？</h5><h5 id="CallerRunsPolicy-拒绝策略有什么风险？如何解决？"><a href="#CallerRunsPolicy-拒绝策略有什么风险？如何解决？" class="headerlink" title="CallerRunsPolicy 拒绝策略有什么风险？如何解决？"></a>CallerRunsPolicy 拒绝策略有什么风险？如何解决？</h5><h5 id="线程池常用的阻塞队列有哪些？"><a href="#线程池常用的阻塞队列有哪些？" class="headerlink" title="线程池常用的阻塞队列有哪些？"></a>线程池常用的阻塞队列有哪些？</h5><h5 id="线程池处理任务的流程"><a href="#线程池处理任务的流程" class="headerlink" title="线程池处理任务的流程"></a>线程池处理任务的流程</h5><h5 id="如何给线程池命名？"><a href="#如何给线程池命名？" class="headerlink" title="如何给线程池命名？"></a>如何给线程池命名？</h5><h5 id="如何设定线程池的大小？"><a href="#如何设定线程池的大小？" class="headerlink" title="如何设定线程池的大小？"></a>如何设定线程池的大小？</h5><h5 id="如何动态修改线程池的参数？"><a href="#如何动态修改线程池的参数？" class="headerlink" title="如何动态修改线程池的参数？"></a>如何动态修改线程池的参数？</h5><h5 id="如何设计一个能够根据任务的优先级来执行的线程池？"><a href="#如何设计一个能够根据任务的优先级来执行的线程池？" class="headerlink" title="如何设计一个能够根据任务的优先级来执行的线程池？"></a>如何设计一个能够根据任务的优先级来执行的线程池？</h5><blockquote><p>[!TIP]<br>待施工</p></blockquote><h4 id="Java中session和cookie的使用"><a href="#Java中session和cookie的使用" class="headerlink" title="Java中session和cookie的使用"></a>Java中session和cookie的使用</h4><h5 id="Session简单介绍"><a href="#Session简单介绍" class="headerlink" title="Session简单介绍"></a>Session简单介绍</h5><blockquote><p>[!TIP]<br>session通常是基于cookie实现的,每一个session都会有一个sessionid保存在浏览器的cookie中</p></blockquote><p>session和cookie都是Java开发中实现会话跟踪的技术。</p><p>在WEB开发中，服务器可以为每个用户浏览器创建一个会话对象（session对象），注意：一个浏览器独占一个session对象(默认情况下)。</p><p>因此，在需要保存用户数据时，服务器程序可以把用户数据写到用户浏览器独占的session中，当用户使用浏览器访问其它程序时，其它程序可以从用户的session中取出该用户的数据，为用户服务。</p><h5 id="Cookie简单介绍"><a href="#Cookie简单介绍" class="headerlink" title="Cookie简单介绍"></a>Cookie简单介绍</h5><p>浏览器与WEB服务器之间是使用HTTP协议进行通信的，当某个用户发出页面请求时，WEB服务器只是简单的进行响应，然后就关闭与该用户的连接。<br>因此当一个请求发送到WEB服务器时，无论其是否是第一次来访，服务器都会把它当作第一次来对待，这样的不好之处可想而知。为了弥补这个缺陷，Netscape开发出了cookie这个有效的工具来保存某个用户的识别信息，因此人们昵称为“小甜饼”。</p><p>cookies是一种WEB服务器通过浏览器在访问者的硬盘上存储信息的手段：Netscape Navigator使用一个名为cookies.txt本地文件保存从所有站点接收的Cookie信息；而IE浏览器把Cookie信息保存在类似于C:\windows\cookies的目录下。当用户再次访问某个站点时，服务端将要求浏览器查找并返回先前发送的Cookie信息，来识别这个用户。</p><h5 id="⭐️Session和Cookie的主要区别"><a href="#⭐️Session和Cookie的主要区别" class="headerlink" title="⭐️Session和Cookie的主要区别"></a>⭐️Session和Cookie的主要区别</h5><p>Cookie 和 Session 都是用来跟踪浏览器用户身份的会话方式，但是两者的应用场景不太一样。</p><p>Cookie一般用来保存用户信息</p><ol><li><p>我们在 Cookie 中保存已经登录过得用户信息，下次访问网站的时候页面可以自动帮你登录的一些基本信息给填了</p></li><li><p>一般的网站都会有保持登录也就是说下次你再访问网站的时候就不需要重新登录了<br>这是因为用户登录的时候我们可以存放了一个 Token 在 Cookie 中，下次登录的时候只需要根据 Token 值来查找用户即可<br>(为了安全考虑，重新登录一般要将 Token 重写)</p></li><li><p>登录一次网站后访问网站其他页面不需要重新登录。Session 的主要作用就是通过服务端记录用户的状态。<br>典型的场景是购物车，当你要添加商品到购物车的时候，系统不知道是哪个用户操作的，因为 HTTP 协议是无状态的。<br>服务端给特定的用户创建特定的 Session 之后就可以标识这个用户并且跟踪这个用户了。</p></li></ol><p>Cookie 数据保存在客户端(浏览器端)，Session 数据保存在服务器端。</p><p>Cookie 存储在客户端中，而 Session 存储在服务器上，相对来说 Session 安全性更高。<br>如果使用 Cookie 的一些敏感信息不要写入 Cookie 中，最好能将 Cookie 信息加密然后使用到的时候再去服务器端解密。</p><h5 id="Session实现原理"><a href="#Session实现原理" class="headerlink" title="Session实现原理"></a>Session实现原理</h5><p>服务器创建session出来后，会把session的id号，以cookie的形式回写给客户机。<br>这样，只要客户机的浏览器不关，再去访问服务器时，都会带着session的id号去，服务器发现客户机浏览器带session id过来了，就会使用内存中与之对应的session为之服务。</p><h5 id="Session的创建和销毁时机"><a href="#Session的创建和销毁时机" class="headerlink" title="Session的创建和销毁时机"></a>Session的创建和销毁时机</h5><ul><li>session对象的创建</li></ul><p>在程序中第一次调用request.getSession()方法时就会创建一个新的Session，可以用isNew()方法来判断Session是不是新创建的</p><ul><li>session对象的销毁</li></ul><p>session对象默认30分钟没有使用，则服务器会自动销毁session，在web.xml文件中可以手工配置session的失效时间</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;Java&quot;&gt;&lt;a href=&quot;#Java&quot; class=&quot;headerlink&quot; title=&quot;Java&quot;&gt;&lt;/a&gt;Java&lt;/h2&gt;&lt;h3 id=&quot;前端&quot;&gt;&lt;a href=&quot;#前端&quot; class=&quot;headerlink&quot; title=&quot;前端&quot;&gt;&lt;/a&gt;前端&lt;/h</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>黑马点评项目记录</title>
    <link href="http://www.meprotoss.com/undefined/c6c80d57.html"/>
    <id>http://www.meprotoss.com/undefined/c6c80d57.html</id>
    <published>2024-05-06T09:17:22.000Z</published>
    <updated>2024-05-09T14:03:10.673Z</updated>
    
    <content type="html"><![CDATA[<h2 id="基于-Session-短信登录"><a href="#基于-Session-短信登录" class="headerlink" title="基于 Session 短信登录"></a>基于 Session 短信登录</h2><h3 id="发送短信验证码"><a href="#发送短信验证码" class="headerlink" title="发送短信验证码"></a>发送短信验证码</h3><p>用户提交手机号，服务器生成验证码并保存到session,然后将验证码发给用户</p><h3 id="短信验证码登录和注册"><a href="#短信验证码登录和注册" class="headerlink" title="短信验证码登录和注册"></a>短信验证码登录和注册</h3><p>用户提交手机号和验证码，服务器先校验验证码，然后根据手机号去数据库查询用户，若不存在，则创建新用户，然后保存用户信息到session</p><ul><li>前台发送的数据格式是json的样式 后台要用@RequestBody注解 实现用LoginFormDTO实体类接收</li><li>登录成功之后要把用户信息存储到session中。</li></ul><h3 id="登录校验-验证登录状态"><a href="#登录校验-验证登录状态" class="headerlink" title="登录校验(验证登录状态)"></a>登录校验(验证登录状态)</h3><p>用户请求(request)中携带cookie(cookie中带有sessionid,而登录的凭证就是sessionid就保存在cookie中)</p><p>服务器从session中获取用户 获取到之后将用户缓存到<code>ThreadLocal</code>中,方便后续的使用</p><blockquote><p>[!TIP]<br>在业务中用户的每个请求都是一个独立的线程，所以不能将用户信息保存到本地变量中，这样会出现多线程并发修改的安全问题，因此要使用ThreadLocal技术</p></blockquote><h4 id="登录拦截校验功能"><a href="#登录拦截校验功能" class="headerlink" title="登录拦截校验功能"></a>登录拦截校验功能</h4><ul><li>⚠️有有很多controller(业务)都需要校验登录状态，不能在每一个controller中都写一遍校验登录状态的业务代码，所以引入spiringmvc中的拦截器，拦截器可以在所有controller执行之前执行，将校验用户登录的流程都统一放在拦截器中</li><li>同时要注意将拦截到的用户信息传递给每一个controller的时候不能出现线程安全问题，所以用到<code>ThreadLocal</code>,让用户的每一个请求都拥有独立的线程。然后每个controller都从对应的<code>ThreadLocal</code>中取出用户即可。</li></ul><h4 id="隐藏用户敏感信息"><a href="#隐藏用户敏感信息" class="headerlink" title="隐藏用户敏感信息"></a>隐藏用户敏感信息</h4><p>在<code>/me</code>中,是从UserHolder中获取的用户信息直接返回，而UserHolder是从拦截器session中取出来的，</p><p>而session中的信息是在登录业务中存入的</p><p>这里会有两个问题：</p><p>session是tomcat的内存空间,存太多信息也会增加服务器的负担</p><p>登录校验返回的信息有些太多了，时间密码等敏感信息不需要返回。</p><ul><li>所以定义UserDTO类来简化存入session的用户信息，即在登录业务的时候将User转为UserDTO</li></ul><h4 id="基于session登录的集群的session共享问题"><a href="#基于session登录的集群的session共享问题" class="headerlink" title="基于session登录的集群的session共享问题"></a>基于session登录的集群的session共享问题</h4><p>问题：为了服务器的负载均衡，通常会配置多个tomcat服务器进行轮循访问，而多台tomcat不共享session的存储空间(每个tomcat有独立的session)，当请求切换到不同的tomcat服务器的时候会导致用户登录数据的丢失</p><p>解决方法：让session共享,且应满足：</p><ol><li>数据共享(让任何一台tomcat访问)</li><li>内存存储</li><li>key，value结构</li></ol><p>(即使用Redis代替session)</p><h4 id="Redis代替session"><a href="#Redis代替session" class="headerlink" title="Redis代替session"></a>Redis代替session</h4><h5 id="发送短信验证码业务"><a href="#发送短信验证码业务" class="headerlink" title="发送短信验证码业务"></a>发送短信验证码业务</h5><p>保存验证码到Redis，且要设置一个有效期</p><ul><li>以手机号为key(为了确保每一个手机号都有不一样的key,且有助于后面根据手机号获取验证码) 验证码为value</li></ul><h5 id="短信验证码登录、注册业务"><a href="#短信验证码登录、注册业务" class="headerlink" title="短信验证码登录、注册业务"></a>短信验证码登录、注册业务</h5><ul><li>保存用户信息到redis,key用随机token(使用UUID生成)</li><li>value是用户对象,保存对象可以使用string结构(将java对象序列化为json字符串,优点是比较直观)或hash结构(再次将value分为key和value两个部分，将对象中的每个字段独立存储,优点是可以针对单个字段做crud，且内存占用更少),所以优先推荐使用hash结构</li><li>然后需要将token作为登录凭证(使用手机号作为key的话有泄露的风险)，登录之后需要手动把生成的token返回给前端</li></ul><h5 id="token有效期的设置"><a href="#token有效期的设置" class="headerlink" title="token有效期的设置"></a>token有效期的设置</h5><ul><li>更新校验登录状态的代码（写在拦截器中），在里面设置token的更新逻辑</li></ul><h5 id="登录拦截器的优化"><a href="#登录拦截器的优化" class="headerlink" title="登录拦截器的优化"></a>登录拦截器的优化</h5><ul><li>问题1： 此时的拦截器只拦截了部分请求，所以并不是所有请求都能刷新token有效期</li></ul><p>solution：在现在的拦截器之前再加一个拦截器，在这个拦截器中拦截一切路径，但只做刷新token和保存用户信息的工作，第二个用户才做登录拦截</p><ul><li>问题2: 控制拦截器的先后顺序</li></ul><p>solution：在注册拦截器的时候添加.order</p><h2 id="商户查询缓存"><a href="#商户查询缓存" class="headerlink" title="商户查询缓存"></a>商户查询缓存</h2><h3 id="什么是缓存？-cache"><a href="#什么是缓存？-cache" class="headerlink" title="什么是缓存？(cache)"></a>什么是缓存？(cache)</h3><p>缓存就是数据交换的缓冲区，是存储数据的临时的地方，读写性能较高</p><h4 id="如何使用缓存？"><a href="#如何使用缓存？" class="headerlink" title="如何使用缓存？"></a>如何使用缓存？</h4><p>实际开发中,会构筑多级缓存来使系统运行速度进一步提升,例如:本地缓存与redis中的缓存并发使用</p><p><strong>浏览器缓存</strong>：主要是存在于浏览器端的缓存</p><p><strong>应用层缓存</strong>: 可以分为tomcat本地缓存，比如之前提到的map，或者是使用redis作为缓存</p><p><strong>数据库缓存</strong>: 在数据库中有一片空间是 buffer pool，增改查数据都会先加载到mysql的缓存中</p><p><strong>CPU缓存</strong>: 当代计算机最大的问题是 cpu性能提升了，但内存读写速度没有跟上，所以为了适应当下的情况，增加了cpu的L1，L2，L3级的缓存</p><h4 id="缓存的成本"><a href="#缓存的成本" class="headerlink" title="缓存的成本"></a>缓存的成本</h4><ul><li>数据一致性</li><li>代码维护</li><li>运维成本</li><li>硬件成本</li></ul><h3 id="添加商户缓存"><a href="#添加商户缓存" class="headerlink" title="添加商户缓存"></a>添加商户缓存</h3><h4 id="缓存模型和思路"><a href="#缓存模型和思路" class="headerlink" title="缓存模型和思路"></a>缓存模型和思路</h4><p>标准的操作方式就是查询数据库之前先查询缓存</p><p>如果缓存数据存在，则直接从缓存中返回</p><p>如果缓存数据不存在，再查询数据库，然后将数据存入redis,然后将信息返回</p><h3 id="缓存更新策略"><a href="#缓存更新策略" class="headerlink" title="缓存更新策略"></a>缓存更新策略</h3><p>缓存更新是redis为了节约内存而设计出来的一个东西，主要是因为内存数据宝贵，当我们向redis插入太多数据，此时就可能会导致缓存中的数据过多，所以redis会对部分数据进行更新，或者把他叫为淘汰更合适</p><p>常见的几个策略如下：</p><p><strong>内存淘汰：</strong>redis自动进行，当redis内存达到咱们设定的max-memery的时候，会自动触发淘汰机制，淘汰掉一些不重要的数据(可以自己设置策略方式),一致性比较差,无维护成本。</p><p><strong>超时剔除：</strong>当我们给redis设置了过期时间ttl之后，redis会将超时的数据进行删除，方便咱们继续使用缓存。一致性的强弱取决于ttl时间，一致性一般，低维护成本(只要在缓存逻辑上添加一个超时)。</p><p><strong>主动更新：</strong>我们可以手动调用方法把缓存删掉，通常用于解决缓存和数据库不一致问题。一致性好，维护成本较高。</p><p>具体选哪个方法主要看业务场景。</p><h3 id="数据库缓存不一致解决方案"><a href="#数据库缓存不一致解决方案" class="headerlink" title="数据库缓存不一致解决方案"></a>数据库缓存不一致解决方案</h3><p>由于我们的<strong>缓存的数据源来自于数据库</strong>,而数据库的<strong>数据是会发生变化的</strong>,因此,如果当数据库中<strong>数据发生变化,而缓存却没有同步</strong>,此时就会有<strong>一致性问题存在</strong>,其后果是:</p><p>用户使用缓存中的过时数据,就会产生类似多线程数据安全问题,从而影响业务,产品口碑等;怎么解决呢？有如下几种方案</p><p>Cache Aside Pattern（旁路缓存） 人工编码方式：缓存调用者在更新完数据库后再去更新缓存，也称之为双写方案✅</p><p>Read&#x2F;Write Through Pattern : 由系统本身完成，数据库与缓存的问题交由系统本身去处理</p><p>Write Behind Caching Pattern ：调用者只操作缓存，其他线程去异步处理数据库，实现最终一致</p><h3 id="数据库和缓存不一致采用什么方案"><a href="#数据库和缓存不一致采用什么方案" class="headerlink" title="数据库和缓存不一致采用什么方案"></a>数据库和缓存不一致采用什么方案</h3><p>综合考虑使用方案一，但是方案一调用者如何处理呢？这里有几个问题</p><p>操作缓存和数据库时有三个问题需要考虑：</p><p>如果采用第一个方案，那么假设我们每次操作数据库后，都操作缓存，但是中间如果没有人查询，那么这个更新动作实际上只有最后一次生效(发生了写远大于读的操作,则无效写的操作很多)，中间的更新动作意义并不大，我们可以把缓存删除，等待再次查询时，将缓存中的数据加载出来</p><ul><li><p>删除缓存还是更新缓存？</p><ul><li>更新缓存：每次更新数据库都更新缓存，无效写操作较多❎</li><li>删除缓存：更新数据库时让缓存失效，查询时再更新缓存✅</li></ul></li><li><p>如何保证缓存与数据库的操作的<strong>同时</strong>成功或失败？（保证事务的原子性）</p><ul><li>单体系统，将缓存与数据库操作放在一个事务</li><li>分布式系统，利用<code>TCC</code>(微服务内容)等分布式事务方案</li></ul></li></ul><blockquote><p>[!TIP]<br>事务的原子性是指事务中的所有操作要么全部执行成功，要么全部执行失败回滚，没有中间状态。原子性保证了事务的完整性和一致性，即事务中的所有操作要么都生效，要么都不生效，不会出现部分操作生效而部分操作失败的情况。</p></blockquote><p>应该具体操作缓存还是操作数据库，我们应当是先操作数据库，再删除缓存，原因在于，如果你选择第一种方案，在两个线程并发来访问时，假设线程1先来，他先把缓存删了，此时线程2过来，他查询缓存数据并不存在，此时他写入缓存，当他写入缓存后，线程1再执行更新动作时，实际上写入的就是旧的数据，新的数据被旧数据覆盖了。</p><ul><li>先操作缓存还是先操作数据库？(线程安全性问题)<ul><li>先删除缓存，再操作数据库</li><li>先操作数据库，再删除缓存✅(该方案的出现问题的可能性较低，因为操作数据库的时间要远长于操作缓存)</li></ul></li></ul><h3 id="缓存更新策略方案的最佳实践总结"><a href="#缓存更新策略方案的最佳实践总结" class="headerlink" title="缓存更新策略方案的最佳实践总结"></a>缓存更新策略方案的最佳实践总结</h3><h4 id="低一致性需求"><a href="#低一致性需求" class="headerlink" title="低一致性需求"></a>低一致性需求</h4><ul><li>使用Redis自带的内存淘汰机制</li></ul><h4 id="高一致性需求：主动更新，并以超时剔除作为兜底方案"><a href="#高一致性需求：主动更新，并以超时剔除作为兜底方案" class="headerlink" title="高一致性需求：主动更新，并以超时剔除作为兜底方案"></a>高一致性需求：主动更新，并以超时剔除作为兜底方案</h4><ul><li>读操作：<ul><li>缓存命中则直接返回</li><li>缓存未命中则查询数据库，并写入缓存，设定超时时间</li></ul></li><li>写操作：<ul><li>先写数据库，然后再删除缓存</li><li>要确保数据库与缓存操作的原子性</li></ul></li></ul><h3 id="缓存穿透"><a href="#缓存穿透" class="headerlink" title="缓存穿透"></a>缓存穿透</h3><p>缓存穿透 ：缓存穿透是指客户端请求的数据在缓存中和数据库中都不存在，这样缓存永远不会生效，这些请求都会打到数据库。(只要有请求那么一定会到达数据库)</p><h4 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h4><p>常见的解决方案有两种：</p><ul><li>缓存空对象<ul><li>优点：实现简单，维护方便</li><li>缺点：<ul><li>额外的内存消耗</li><li>可能造成短期的不一致</li></ul></li></ul></li><li>布隆过滤<ul><li>优点：内存占用较少，没有多余key</li><li>缺点：<ul><li>实现复杂</li><li>存在误判可能</li></ul></li></ul></li></ul><p><strong>缓存空对象思路分析：</strong>当我们客户端访问不存在的数据时，先请求redis，但是此时redis中没有数据，此时会访问到数据库，但是数据库中也没有数据，这个数据穿透了缓存，直击数据库，我们都知道数据库能够承载的并发不如redis这么高，如果大量的请求同时过来访问这种不存在的数据，这些请求就都会访问到数据库，简单的解决方案就是哪怕这个数据在数据库中也不存在，我们也把这个数据存入到redis中去，这样，下次用户过来访问这个不存在的数据，那么在redis中也能找到这个数据就不会进入到缓存了</p><p><strong>布隆过滤器：</strong>在客户端和缓存之间再添加一层布隆过滤器的拦截，请求来了之后让布隆过滤器判断这个数据是否存在，若不存在则直接返回,若存在则放行到缓存，后续的流程不变</p><p>这种方式优点在于节约内存空间，存在误判，误判原因在于：布隆过滤器是哈希思想，只要哈希思想，就可能存在哈希冲突</p><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>缓存穿透产生的原因是什么？</p><ul><li>用户请求的数据在缓存中和数据库中都不存在，不断发起这样的请求，给数据库带来巨大压力</li></ul><p>缓存穿透的解决方案有哪些？</p><p>被动方案（亡羊补牢）:</p><ul><li>缓存null值</li><li>布隆过滤</li></ul><p>主动方案（未雨绸缪）:</p><ul><li>增强id的复杂度，避免被猜测id规律</li><li>做好数据的基础格式校验</li><li>加强用户权限校验</li><li>做好热点参数的限流</li></ul><h3 id="缓存雪崩"><a href="#缓存雪崩" class="headerlink" title="缓存雪崩"></a>缓存雪崩</h3><p>缓存雪崩：缓存中的大量key同时失效或者缓存服务器Redis突然宕机，导致大量请求到达数据库，给服务器带来巨大压力</p><h4 id="解决思路"><a href="#解决思路" class="headerlink" title="解决思路"></a>解决思路</h4><ul><li>给不同的Key的TTL添加随机值(解决key同时失效)</li><li>利用Redis集群提高服务的可用性(解决Redis宕机)</li><li>给缓存业务添加降级限流策略</li><li>给业务添加多级缓存(可以在反向代理nginx等等部分也建立缓存，类似于多层防弹衣)</li></ul><h3 id="缓存击穿-热点key问题"><a href="#缓存击穿-热点key问题" class="headerlink" title="缓存击穿(热点key问题)"></a>缓存击穿(热点key问题)</h3><p>缓存击穿问题也叫热点Key问题，就是一个被高并发访问并且缓存重建业务较复杂的key突然失效了，无数的请求访问会在瞬间给数据库带来巨大的冲击(大量线程同时缓存重建)。</p><p>常见的解决方案:</p><ul><li><p>互斥锁(排队依次重建)</p></li><li><p>逻辑过期(不是真的过期 而是由程序员判断是否真的过期,本质上是设置热点key永久有效)</p></li></ul><p>方案分析：我们之所以会出现这个缓存击穿问题，<strong>主要原因是在于我们对key设置了过期时间</strong>，假设我们不设置过期时间，其实就不会有缓存击穿的问题，但是不设置过期时间，这样数据不就一直占用我们内存了吗，我们可以采用逻辑过期方案。</p><p>我们把过期时间设置在redis热点key的value中，注意：这个过期时间并不会直接作用于redis，而是我们后续通过逻辑去处理。实际流程如下:</p><p>假设线程1去查询缓存，然后从value中判断当前的数据是否过期(如果直接在缓存中未命中，则直接返回空)</p><p>如果未过期，那么直接返回信息。</p><p>如果过期了，此时线程1去尝试获得互斥锁<br>  如果获取失败了，那么代表以及有线程在缓存重建，线程1直接返回旧信息<br>  如果获取成功了，那么线程1会开启另外一个独立线程2去执行缓存重建，自己依旧返回旧信息。</p><p>假设现在线程3过来访问，由于线程线程2持有着锁，所以线程3无法获得锁，线程3也直接返回数据，只有等到新开的线程2把重建数据构建完后，其他线程才能走返回正确的数据。</p><p>这种方案巧妙在于，异步的构建缓存，缺点在于在构建完缓存之前，返回的都是脏数据。</p><h4 id="两种方案的对比"><a href="#两种方案的对比" class="headerlink" title="两种方案的对比"></a>两种方案的对比</h4><p>两种方案都是在解决缓存重建过程中的并发问题</p><p><strong>互斥锁方案：</strong> 强调一致性</p><p>由于保证了互斥性，所以数据一致，且实现简单，因为仅仅只需要加一把锁而已，也没其他的事情需要操心，所以没有额外的内存消耗，</p><p>缺点在于有锁就有死锁问题的发生，且只能串行执行性能肯定受到影响</p><p><strong>逻辑过期方案：</strong> 强调可用性</p><p>线程读取过程中不需要等，性能好，有一个额外的线程持有锁去进行重构数据，</p><p>但是在重构数据完成前，其他的线程只能返回之前的数据，且实现起来麻烦</p><h3 id="利用互斥锁解决缓存击穿问题"><a href="#利用互斥锁解决缓存击穿问题" class="headerlink" title="利用互斥锁解决缓存击穿问题"></a>利用互斥锁解决缓存击穿问题</h3><p>核心思路：相较于原来从缓存中查询不到数据后直接查询数据库而言，现在的方案是进行查询之后，如果从缓存没有查询到数据，则进行互斥锁的获取，获取互斥锁后，判断是否获得到了锁，如果没有获得到，则休眠，过一会再进行尝试，直到获取到锁为止，才能进行查询。</p><p><strong>操作锁的代码：</strong></p><p>核心思路就是利用redis的setnx方法来表示获取锁（锁其实就是redis中存储的一个key），<br>该方法含义是redis中如果没有这个key，则插入成功，返回1，在stringRedisTemplate中返回true，、如果有这个key则插入失败，则返回0，<br>在stringRedisTemplate返回false，我们可以通过true，或者是false，来表示是否有线程成功插入key，成功插入的key的线程我们认为他就是获得到锁的线程。</p><h3 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h3><p>在 Java 中，Boolean 是一个包装类，用于封装基本数据类型 boolean 的值。<br>当使用 Boolean 类型进行自动拆箱（Unboxing）时，如果 Boolean 对象的值为 null，就会触发 NullPointerException 异常。</p><p>例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Boolean</span> <span class="variable">boolObj</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"><span class="type">boolean</span> <span class="variable">boolPrimitive</span> <span class="operator">=</span> boolObj; <span class="comment">// 自动拆箱，触发 NullPointerException</span></span><br></pre></td></tr></table></figure><p>在上面的例子中，当试图将 null 的 Boolean 对象自动拆箱为基本数据类型 boolean 时，会导致 NullPointerException 异常。</p><p>为了避免这种情况，应该在进行自动拆箱之前先检查 Boolean 对象是否为 null，或者使用条件语句处理可能为 null 的情况。</p><h3 id="利用逻辑过期解决缓存击穿问题"><a href="#利用逻辑过期解决缓存击穿问题" class="headerlink" title="利用逻辑过期解决缓存击穿问题"></a>利用逻辑过期解决缓存击穿问题</h3><ul><li>添加过期时间</li></ul><p>因为现在redis中存储的数据的value需要带上过期时间，此时要么你去修改原来的实体类，但是这个方案修改了原来的代码，不符合代码的ocp(开闭原则)。</p><p>因此我们选择新建一个实体类，此时又有两种选择，一个是继承原来的shop类，优点是较为简单，但是依然需要对原来的代码进行少量修改；而另一种方案是在该类中新建一个存储数据的对象。</p><ul><li>开启缓存重建的线程的时候调用线程池</li></ul><h3 id="缓存工具封装-⭐️"><a href="#缓存工具封装-⭐️" class="headerlink" title="缓存工具封装(⭐️)"></a>缓存工具封装(⭐️)</h3><p>基于StringRedisTemplate封装一个缓存工具类，满足下列需求：</p><p>存：</p><ul><li>方法1：将<strong>任意Java对象</strong>序列化为json并存储在string类型的key中，并且可以<strong>设置TTL过期时间</strong>(往redis中存数据)</li><li>方法2：将任意Java对象序列化为json并存储在string类型的key中，并且可以<strong>设置逻辑过期时间</strong>，用于处理缓存击穿问题</li></ul><p>取：</p><ul><li>方法3：根据指定的key查询缓存，并反序列化为指定类型，利用缓存空值的方式解决缓存穿透问题</li><li>方法4：根据指定的key查询缓存，并反序列化为指定类型，需要利用逻辑过期解决缓存击穿问题</li></ul><p>方法1、3用来解决普通缓存问题；方法2、4是用来解决热点key问题的</p><h2 id="优惠券秒杀"><a href="#优惠券秒杀" class="headerlink" title="优惠券秒杀"></a>优惠券秒杀</h2><h3 id="全局唯一ID"><a href="#全局唯一ID" class="headerlink" title="全局唯一ID"></a>全局唯一ID</h3><p><strong>全局ID生成器</strong>，是一种在分布式系统下用来生成全局唯一ID的工具，一般要满足下列特性：</p><ul><li>唯一性</li><li>高可用</li><li>高性能</li><li>递增性</li><li>安全性</li></ul><h3 id="Redis实现全局唯一ID"><a href="#Redis实现全局唯一ID" class="headerlink" title="Redis实现全局唯一ID"></a>Redis实现全局唯一ID</h3><p>为了增加ID的安全性，我们可以不直接使用Redis自增的数值，而是拼接一些其它信息：</p><p>ID的组成部分(⭐️)：</p><ul><li><p>符号位：1bit，永远为0</p></li><li><p>时间戳：31bit，以秒为单位，可以使用69年</p></li><li><p>序列号：32bit，秒内的计数器，支持每秒产生2^32个不同ID</p></li></ul><p>在序列号上添加日期部分(每天一个key)可以避免序列号数量超过redis的存储上限（2^64,其实此处最多只能达到2^32，其次还可以便于基于日期部分统计每一天的下单量。)</p><h3 id="全局唯一ID的生成策略"><a href="#全局唯一ID的生成策略" class="headerlink" title="全局唯一ID的生成策略"></a>全局唯一ID的生成策略</h3><ul><li>UUID</li><li>Redis自增</li><li>snowflake(雪花)算法</li><li>数据库自增(用一张额外的表来专门实现自增)</li></ul><h3 id="优惠券-这一块细节很多，可以作为项目的难点"><a href="#优惠券-这一块细节很多，可以作为项目的难点" class="headerlink" title="优惠券(这一块细节很多，可以作为项目的难点)"></a>优惠券(这一块细节很多，可以作为项目的难点)</h3><h4 id="普通券和秒杀券"><a href="#普通券和秒杀券" class="headerlink" title="普通券和秒杀券"></a>普通券和秒杀券</h4><h4 id="库存超卖问题"><a href="#库存超卖问题" class="headerlink" title="库存超卖问题"></a>库存超卖问题</h4><h5 id="问题原因"><a href="#问题原因" class="headerlink" title="问题原因"></a>问题原因</h5><p>假设线程1过来查询库存，判断出来库存大于1，正准备去扣减库存，但是还没有来得及去扣减，此时线程2过来，线程2也去查询库存，发现这个数量一定也大于1，那么这两个线程都会去扣减库存，最终多个线程相当于一起去扣减库存，此时就会出现库存的超卖问题。</p><h5 id="解决方法-1"><a href="#解决方法-1" class="headerlink" title="解决方法"></a>解决方法</h5><p>悲观锁：认为线程安全问题一定会发生，因此在操作数据之前一定要先获取锁，确保线程串行执行</p><p>乐观锁：认为线程安全问题不一定会发生，因此不加所锁，只是在数据更新时才去判断有没有别的线程对数据进行了修改。</p><ul><li>如果没有修改则认为是安全的,自己更新数据</li><li>如果已被其他线程修改过说明发生了安全问题，此时可以重试或异常</li></ul><h5 id="乐观锁CAS法解决超卖问题"><a href="#乐观锁CAS法解决超卖问题" class="headerlink" title="乐观锁CAS法解决超卖问题"></a>乐观锁CAS法解决超卖问题</h5><p>乐观锁的关键是判断之前查询的数据是否被修改过，常见的方法有两种</p><ul><li>版本号法:简单来说就是给数据添加一个版本号字段，一旦执行修改数据的操作，那么同时就要修改版本号，修改的之前要确认此时的版本号和查询数据库的时候的版本号是否一致，一致则说明在查询和修改的这段时间内没有其他线程修改过数据,不一致则不执行操作</li><li>CAS法(compare and switch):版本号法的简化，由于每次查询和修改的时候版本号和数据数量都做了修改，那么就不用多此一举多设置一个版本号，只要在修改之前再一次比较一下当前的数量是否和查询时的数量一致即可。</li></ul><h4 id="一人一单问题"><a href="#一人一单问题" class="headerlink" title="一人一单问题"></a>一人一单问题</h4><p>只需要在秒杀业务中添加一个判断：在判断库存是否足够之后再根据优惠卷id和用户id查询是否已经下过这个订单，如果下过这个订单，则不再下单，否则进行下单。</p><p>也会出现高并发问题,需要给减库存操作和创建订单操作添加悲观锁,要注意因为是一人一单，所以只要对userid加锁，而不用对整个方法加锁；这里还有一个细节，在判断userid前后是否一致的时候，由于是一个字符串对象，所以必须要对该对象调用.intern()方法才能到字符串常量池中去找原先的对象，否则就会new一个新的对象，导致即使数值一致，但判断依然是不一致（因为是两个不同的对象）</p><h3 id="集群环境下的并发问题-syn锁失效"><a href="#集群环境下的并发问题-syn锁失效" class="headerlink" title="集群环境下的并发问题(syn锁失效)"></a>集群环境下的并发问题(syn锁失效)</h3><p>通过加锁可以解决在单机情况下的一人一单安全问题，但是在集群模式下就不行了。</p><p><strong>有关锁失效原因分析</strong>:</p><p>由于现在我们部署了多个tomcat，每个tomcat都有一个属于自己的jvm，那么假设在服务器A的tomcat内部，有两个线程，这两个线程由于使用的是同一份代码，那么他们的锁对象是同一个，是可以实现互斥的，但是如果现在是服务器B的tomcat内部，又有两个线程，但是他们的锁对象写的虽然和服务器A一样，但是锁对象却不是同一个，所以线程3和线程4可以实现互斥，但是却无法和线程1和线程2实现互斥，这就是 集群环境下，syn锁失效的原因，在这种情况下，我们就需要使用分布式锁来解决这个问题。</p><h2 id="分布式锁"><a href="#分布式锁" class="headerlink" title="分布式锁"></a>分布式锁</h2><h3 id="基本原理和实现方式"><a href="#基本原理和实现方式" class="headerlink" title="基本原理和实现方式"></a>基本原理和实现方式</h3><p>分布式锁：满足分布式系统或集群模式下<strong>多进程可见并且互斥的锁</strong>。</p><p>分布式锁的核心思想就是让大家都使用同一把锁，只要大家使用的是同一把锁，那么我们就能锁住线程，不让线程进行，让程序串行执行，这就是分布式锁的核心思路。</p><p>那么分布式锁他应该满足一些什么样的条件呢？</p><p>可见性：多个线程都能看到相同的结果，注意：这个地方说的可见性并不是并发编程中指的内存可见性，只是说多个进程之间都能感知到变化的意思</p><p>互斥：互斥是分布式锁的最基本的条件，使得程序串行执行</p><p>高可用：程序不易崩溃，时时刻刻都保证较高的可用性</p><p>高性能：由于加锁本身就让性能降低，所有对于分布式锁本身需要他就较高的加锁性能和释放锁性能</p><p>安全性：安全也是程序中必不可少的一环</p><p>常见的分布式锁有三种</p><p>Mysql：mysql本身就带有锁机制，但是由于mysql性能本身一般，所以采用分布式锁的情况下，其实使用mysql作为分布式锁比较少见</p><p>Redis：redis作为分布式锁是非常常见的一种使用方式，现在企业级开发中基本都使用redis或者zookeeper作为分布式锁，利用setnx(当我们尝试往数据库中set一个数据的时候，只有数据不存在才能set成功)这个方法，如果插入key成功，则表示获得到了锁，如果有人插入成功，其他人插入失败则表示无法获得到锁，利用这套逻辑来实现分布式锁</p><p>Zookeeper：zookeeper也是企业级开发中较好的一个实现分布式锁的方案，由于本套视频并不讲解zookeeper的原理和分布式锁的实现，所以不过多阐述</p><h3 id="Redis分布式锁的实现核心思路"><a href="#Redis分布式锁的实现核心思路" class="headerlink" title="### Redis分布式锁的实现核心思路"></a>### Redis分布式锁的实现核心思路</h3><p>实现分布式锁时需要实现的两个基本方法：</p><ul><li><p>获取锁：</p><ul><li>互斥：确保只能有一个线程获取锁</li><li>非阻塞：<strong>尝试一次</strong>，成功返回true，失败返回false</li></ul></li><li><p>释放锁：</p><ul><li>手动释放</li><li>超时释放：获取锁时添加一个超时时间,如果服务器发生了宕机或者别的意外，锁始终会自动释放，从而避免了死锁的发生</li></ul></li></ul><p>核心思路：</p><p>我们利用redis 的setNx 方法，当有多个线程进入时，我们就利用该方法，第一个线程进入时，redis 中就有这个key 了，返回了1，如果结果是1，则表示他抢到了锁，那么他去执行业务，然后再删除锁，退出锁逻辑，没有抢到锁的哥们，等待一定时间后重试即可</p><blockquote><p>[!TIP]<br>在使用自动拆箱的时候一定要记得考虑发生空指针异常的可能性。</p></blockquote><h3 id="实现分布式锁"><a href="#实现分布式锁" class="headerlink" title="实现分布式锁"></a>实现分布式锁</h3><h4 id="加锁逻辑"><a href="#加锁逻辑" class="headerlink" title="加锁逻辑"></a>加锁逻辑</h4><ul><li><p>利用setnx方法进行加锁，同时增加过期时间，防止死锁，此方法可以保证加锁和增加过期时间具有原子性</p></li><li><p>获取锁的时候还需要存入线程标识（可以用UUID表示）</p></li></ul><h4 id="释放锁的逻辑"><a href="#释放锁的逻辑" class="headerlink" title="释放锁的逻辑"></a>释放锁的逻辑</h4><ul><li>释放锁的时候要确认锁的线程标识，判断是否与当前线程标示一致,如果一致则释放锁，如果不一致则不释放</li></ul><h3 id="分布式锁的原子性问题"><a href="#分布式锁的原子性问题" class="headerlink" title="分布式锁的原子性问题"></a>分布式锁的原子性问题</h3><p>线程1现在持有锁之后，在执行业务逻辑过程中，他正准备删除锁，而且已经走到了条件判断的过程中，比如他已经拿到了当前这把锁确实是属于他自己的，正准备删除锁，但是此时他的锁到期了(发生了阻塞或其他原因导致超时自动释放)，那么此时线程2进来，但是线程1他会接着往后执行，当他卡顿结束后，他直接就会执行删除锁那行代码，相当于条件判断并没有起到作用，这就是删锁时的原子性问题，之所以有这个问题，是因为线程1的拿锁，比锁，删锁，实际上并不是原子性(一起执行，中间没有间隔)的，我们要防止刚才的情况发生，</p><h3 id="Lua脚本解决多条命令原子性问题"><a href="#Lua脚本解决多条命令原子性问题" class="headerlink" title="Lua脚本解决多条命令原子性问题"></a>Lua脚本解决多条命令原子性问题</h3><p>Redis提供了Lua脚本功能，在一个脚本中编写多条Redis命令，确保多条命令执行时的原子性。</p><p>这里重点介绍Redis提供的调用函数，语法如下：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redis.call(<span class="string">&#x27;命令名称&#x27;</span>, <span class="string">&#x27;key&#x27;</span>, <span class="string">&#x27;其它参数&#x27;</span>, ...)␍</span><br></pre></td></tr></table></figure><p>我们可以使用lua去操作redis，又能保证他的原子性，这样就可以实现拿锁比锁删锁是一个原子性动作了，作为Java程序员这一块并不作一个简单要求，并不需要大家过于精通，只需要知道他有什么作用即可。</p><h3 id="利用Java代码调用Lua脚本改造分布式锁"><a href="#利用Java代码调用Lua脚本改造分布式锁" class="headerlink" title="利用Java代码调用Lua脚本改造分布式锁"></a>利用Java代码调用Lua脚本改造分布式锁</h3><p>接下来我们来回一下我们释放锁的逻辑：</p><p>释放锁的业务流程是这样的:</p><ol><li>获取锁中的线程标示</li><li>判断是否与指定的标示（当前线程标示）一致</li><li>如果一致则释放锁（删除）</li><li>如果不一致则什么都不做</li></ol><p>最终我们操作redis的拿锁比锁删锁的lua脚本就会变成这样:</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 这里的 KEYS[1] 就是锁的key，这里的ARGV[1] 就是当前线程标示</span></span><br><span class="line"><span class="comment">-- 获取锁中的标示，判断是否与当前线程标示一致</span></span><br><span class="line"><span class="keyword">if</span> (redis.call(<span class="string">&#x27;GET&#x27;</span>, KEYS[<span class="number">1</span>]) == ARGV[<span class="number">1</span>]) <span class="keyword">then</span></span><br><span class="line">  <span class="comment">-- 一致，则删除锁</span></span><br><span class="line">  <span class="keyword">return</span> redis.call(<span class="string">&#x27;DEL&#x27;</span>, KEYS[<span class="number">1</span>])</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="comment">-- 不一致，则直接返回</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span></span><br></pre></td></tr></table></figure><p><strong>Java代码</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> DefaultRedisScript&lt;Long&gt; UNLOCK_SCRIPT;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        UNLOCK_SCRIPT = <span class="keyword">new</span> <span class="title class_">DefaultRedisScript</span>&lt;&gt;();</span><br><span class="line">        UNLOCK_SCRIPT.setLocation(<span class="keyword">new</span> <span class="title class_">ClassPathResource</span>(<span class="string">&quot;unlock.lua&quot;</span>));</span><br><span class="line">        UNLOCK_SCRIPT.setResultType(Long.class);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">unlock</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 调用lua脚本</span></span><br><span class="line">    stringRedisTemplate.execute(</span><br><span class="line">            UNLOCK_SCRIPT,</span><br><span class="line">            Collections.singletonList(KEY_PREFIX + name),</span><br><span class="line">            ID_PREFIX + Thread.currentThread().getId());</span><br><span class="line">&#125;</span><br><span class="line">经过以上代码改造后，我们就能够实现 拿锁比锁删锁的原子性动作了</span><br></pre></td></tr></table></figure><p>小总结：</p><p>基于Redis的分布式锁实现思路：</p><ul><li>利用set nx ex获取锁，并设置过期时间，保存线程标示</li><li>释放锁时先判断线程标示是否与自己一致，一致则删除锁<ul><li>特性：<ul><li>利用set nx满足互斥性</li><li>利用set ex保证故障时锁依然能释放，避免死锁，提高安全性</li><li>利用Redis集群保证高可用和高并发特性</li></ul></li></ul></li></ul><p>笔者总结：我们一路走来，利用添加过期时间，防止死锁问题的发生，但是有了过期时间之后，可能出现误删别人锁的问题，这个问题我们开始是利用删之前 通过拿锁，比锁，删锁这个逻辑来解决的，也就是删之前判断一下当前这把锁是否是属于自己的，但是现在还有原子性问题，也就是我们没法保证拿锁比锁删锁是一个原子性的动作，最后通过lua表达式来解决这个问题</p><p>但是目前还剩下一个问题锁不住，什么是锁不住呢，你想一想，如果当过期时间到了之后，我们可以给他续期一下，比如续个30s，就好像是网吧上网， 网费到了之后，然后说，来，网管，再给我来10块的，是不是后边的问题都不会发生了，那么续期问题怎么解决呢，可以依赖于我们接下来要学习redission啦</p><p><strong>测试逻辑：</strong></p><p>第一个线程进来，得到了锁，手动删除锁，模拟锁超时了，其他线程会执行lua来抢锁，当第一天线程利用lua删除锁时，lua能保证他不能删除他的锁，第二个线程删除锁时，利用lua同样可以保证不会删除别人的锁，同时还能保证原子性。</p><h2 id="分布式锁redisson"><a href="#分布式锁redisson" class="headerlink" title="分布式锁redisson"></a>分布式锁redisson</h2><p>Redisson是一个在Redis的基础上实现的Java驻内存数据网格（In-Memory Data Grid）。它不仅提供了一系列的分布式的Java常用对象，还提供了许多分布式服务，其中就包含了各种分布式锁的实现。</p><h3 id="分布式锁-redisson功能介绍"><a href="#分布式锁-redisson功能介绍" class="headerlink" title="分布式锁-redisson功能介绍"></a>分布式锁-redisson功能介绍</h3><p>基于setnx实现的分布式锁存在下面的问题：</p><p><strong>重入问题</strong>：重入问题是指获得锁的线程可以再次进入到相同的锁的代码块中，可重入锁的意义在于防止死锁，比如HashTable这样的代码中，他的方法都是使用synchronized修饰的，假如他在一个方法内，调用另一个方法，那么此时如果是不可重入的，不就死锁了吗？所以可重入锁他的主要意义是防止死锁，我们的synchronized和Lock锁都是可重入的。</p><p><strong>不可重试</strong>：是指目前的分布式只能尝试一次，我们认为合理的情况是：当线程在获得锁失败后，他应该能再次尝试获得锁。</p><p><strong>超时释放：</strong>我们在加锁时增加了过期时间，这样的我们可以防止死锁，但是如果卡顿的时间超长，虽然我们采用了lua表达式防止删锁的时候，误删别人的锁，但是毕竟没有锁住，有安全隐患</p><p><strong>主从一致性：</strong> (可简单理解为读写分离模式,主节点和从节点可能分别负责写和读的操作,这样就可以同时在多个节点上进行写和读的操作,如果主节点宕机了，那么还可以从分节点中挑一个继续作为主节点,但是主从节点之间的同步是有延迟的)如果Redis提供了主从集群(一个主节点和多个分节点)，当我们向集群写数据时，主机需要异步的将数据同步给从机，而万一在同步过去之前，主机宕机了，就会出现死锁问题。</p><h3 id="redisson-入门"><a href="#redisson-入门" class="headerlink" title="redisson 入门"></a>redisson 入门</h3><ol><li>引入依赖</li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.redisson<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>redisson<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>3.13.6<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br></pre></td></tr></table></figure><ol start="2"><li>配置Redisson客户端</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RedissonConfig</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> RedissonClient <span class="title function_">redissonClient</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">// 配置</span></span><br><span class="line">        <span class="type">Config</span> <span class="variable">config</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Config</span>();</span><br><span class="line">        config.useSingleServer().setAddress(<span class="string">&quot;redis://192.168.150.101:6379&quot;</span>)</span><br><span class="line">            .setPassword(<span class="string">&quot;123321&quot;</span>);</span><br><span class="line">        <span class="comment">// 创建RedissonClient对象</span></span><br><span class="line">        <span class="keyword">return</span> Redisson.create(config);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="number">3.</span> 使用Redisson的分布式锁</span><br><span class="line">```java</span><br><span class="line"><span class="meta">@Resource</span></span><br><span class="line"><span class="keyword">private</span> RedissionClient redissonClient;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">testRedisson</span><span class="params">()</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line">    <span class="comment">//获取锁(可重入)，指定锁的名称</span></span><br><span class="line">    <span class="type">RLock</span> <span class="variable">lock</span> <span class="operator">=</span> redissonClient.getLock(<span class="string">&quot;anyLock&quot;</span>);</span><br><span class="line">    <span class="comment">//尝试获取锁，参数分别是：获取锁的最大等待时间(期间会重试)，锁自动释放时间，时间单位</span></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">isLock</span> <span class="operator">=</span> lock.tryLock(<span class="number">1</span>,<span class="number">10</span>,TimeUnit.SECONDS);</span><br><span class="line">    <span class="comment">//判断获取锁成功</span></span><br><span class="line">    <span class="keyword">if</span>(isLock)&#123;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;执行业务&quot;</span>);          </span><br><span class="line">        &#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">            <span class="comment">//释放锁</span></span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="redisson可重入锁的原理"><a href="#redisson可重入锁的原理" class="headerlink" title="redisson可重入锁的原理"></a>redisson可重入锁的原理</h3><p>在尝试获取锁的时候，如果发现现在的锁已经被人持有，会去再判断一下持有锁的人是不是自己,如果是，那么也会获取锁，同时也会设置一个计数器来计算获取锁的次数</p><p>在Lock锁中，他是借助于底层的一个voaltile的一个state变量来记录重入的状态的，比如当前没有人持有这把锁，那么state&#x3D;0，假如有人持有这把锁，那么state&#x3D;1，如果持有这把锁的人再次持有这把锁，那么state就会+1 ，如果是对于synchronized而言，他在c语言代码中会有一个count，原理和state类似，也是重入一次就加一，释放一次就-1 ，直到减少成0 时，表示当前这把锁没有被人持有。</p><h3 id="redisson锁重试和watchdog机制"><a href="#redisson锁重试和watchdog机制" class="headerlink" title="redisson锁重试和watchdog机制"></a>redisson锁重试和watchdog机制</h3><p>看门狗机制是用来在获取锁的时候更新锁的失效时间的</p><p>为了解决基于setnx实现的分布式锁的不可重入、不可重试、超时释放和主从一致性的问题,redisson分布式锁的解决方案</p><ul><li><p>可重入：利用hash结构记录线程id和重入次数</p></li><li><p>可重试：利用信号量和PubSub功能实现等待(等待释放锁的消息)、唤醒，获取锁失败的重试机制</p></li><li><p>超时续约：利用watchDog，每隔一段时间（releaseTime &#x2F; 3），重置超时时间</p></li></ul><h3 id="redisson锁的mutilock原理"><a href="#redisson锁的mutilock原理" class="headerlink" title="redisson锁的mutilock原理"></a>redisson锁的mutilock原理</h3><p>为了提高redis的可用性，我们会搭建集群或者主从，现在以主从为例</p><p>此时我们去写命令，写在主机上， 主机会将数据同步给从机，但是假设在主机还没有来得及把数据写入到从机去的时候，此时主机宕机，哨兵会发现主机宕机，并且选举一个slave变成master，而此时新的master中实际上并没有锁信息，此时锁信息就已经丢掉了</p><p>为了解决这个问题，redission提出来了MutiLock锁，使用这把锁咱们就不使用主从了，<strong>每个节点的地位都是一样的</strong>， 这把锁加锁的逻辑需要写入到每一个主丛节点上，只有 <strong>所有的服务器都写入成功，此时才是加锁成功</strong>，假设现在某个节点挂了，那么他去获得锁的时候，只要有一个节点拿不到，都不能算是加锁成功，就保证了加锁的可靠性。</p><p>所谓的联锁，就是多个独立的锁，而每一个独立的锁就和前面的锁完全一样</p><h3 id="redisson分布式锁原理总结"><a href="#redisson分布式锁原理总结" class="headerlink" title="redisson分布式锁原理总结"></a>redisson分布式锁原理总结</h3><p>1）不可重入Redis分布式锁：</p><p>原理：利用setnx的互斥性；利用ex避免死锁；释放锁时判断线程标示</p><p>缺陷：不可重入、无法重试、锁超时失效</p><p>2）可重入的Redis分布式锁：</p><p>原理：利用hash结构，记录线程标示和重入次数；利用watchDog延续锁时间；利用信号量控制锁重试等待</p><p>缺陷：redis宕机引起锁失效问题</p><p>3）Redisson的multiLock(可看作多个可重入式锁的集合)：</p><p>原理：多个独立的Redis节点，必须在所有节点都获取重入锁，才算获取锁成功</p><p>缺陷：运维成本高、实现复杂</p><h2 id="Redis优化秒杀"><a href="#Redis优化秒杀" class="headerlink" title="Redis优化秒杀"></a>Redis优化秒杀</h2><h3 id="秒杀优化-异步秒杀思路"><a href="#秒杀优化-异步秒杀思路" class="headerlink" title="秒杀优化-异步秒杀思路"></a>秒杀优化-<strong>异步秒杀</strong>思路</h3><p>当用户发起请求，此时会请求nginx，nginx会访问到tomcat，而tomcat中的程序，会进行串行操作，分成如下几个步骤：</p><ol><li><p>查询优惠卷</p></li><li><p>判断秒杀库存是否足够</p></li><li><p>查询订单</p></li><li><p>校验是否是一人一单</p></li><li><p>扣减库存</p></li><li><p>创建订单</p></li></ol><p>优化方案：<br>们将耗时比较短的逻辑判断放入到redis中，比如是否库存足够，比如是否一人一单，这样的操作，只要这种逻辑可以完成，就意味着我们是一定可以下单完成的，我们只需要进行快速的逻辑判断，根本就不用等下单逻辑走完，我们直接给用户返回成功， 再在后台开一个线程，后台线程<strong>慢慢</strong>的去执行queue里边的消息，这样程序不就超级快了吗？而且也不用担心线程池消耗殆尽的问题，因为这里我们的程序中并没有手动使用任何线程池，当然这里边有两个难点:</p><p>第一个难点是我们怎么在redis中去快速校验一人一单，还有库存判断</p><p>第二个难点是由于我们校验和tomct下单是两个线程，那么我们如何知道到底哪个单他最后是否成功，或者是下单完成，为了完成这件事我们在redis操作完之后，我们会将一些信息返回给前端，同时也会把这些信息丢到<strong>异步queue</strong>中去，后续操作中，可以通过这个id来查询我们tomcat中的下单逻辑是否完成了</p><h3 id="redis完成秒杀资格判断"><a href="#redis完成秒杀资格判断" class="headerlink" title="redis完成秒杀资格判断"></a>redis完成秒杀资格判断</h3><h3 id="基于阻塞队列实现秒杀优化"><a href="#基于阻塞队列实现秒杀优化" class="headerlink" title="基于阻塞队列实现秒杀优化"></a>基于阻塞队列实现秒杀优化</h3><p>阻塞队列：当一个线程从队列中获取元素的时候，如果队列中有元素会返回,如果队列中没有元素则会被阻塞，直到队列中有元素才会被唤醒去获取元素。</p><blockquote><p>[!TIP]<br>@PostConstruct注解：在 Java 中，@PostConstruct 注解用于指定一个方法在构造函数执行之后、依赖注入完成之后执行。它标识了一个初始化方法，该方法会在对象的所有依赖项都注入完成后自动被调用。</p></blockquote><p>使用 @PostConstruct 注解的方法必须满足以下条件：</p><p>方法不应该有任何参数。<br>方法的返回类型应该为 void。<br>方法不能是静态的。</p><p>总结：</p><p>秒杀优化的思路：</p><ul><li>改同步下单为异步下单,将业务分为两部分，利用Redis完成下单资格(库存余量、一人一单)的判断，及时响应</li><li>具体下单的业务则放入阻塞队列,开启独立线程慢慢完成。</li></ul><p>基于阻塞队列的异步秒杀有什么问题？</p><ul><li>内存限制问题<br>  现在使用的是jdk的阻塞队列，使用的是jdk的内存，在该并发的情况下可能会有无数的订单被创建放进阻塞队列里，可能导致内存溢出的问题(OOM),虽然在创建阻塞的队列时候设置了上限,但是如果队列满了，那么有新的订单来的时候就存不进去了。</li><li>数据安全问题<br>  现在是基于内存来保存订单信息的，但是如果服务器突然宕机了，那么内存中的所有订单信息就会消失。<br>  有一个线程从队列中取出了一个订单要去执行，此时突然发生异常导致该任务执行失败，由于任务从队列中取出来就没有了，那么该任务以后再也不会被执行，导致任务丢失。</li></ul><h2 id="Redis消息队列（Message-Queue）实现异步秒杀"><a href="#Redis消息队列（Message-Queue）实现异步秒杀" class="headerlink" title="Redis消息队列（Message Queue）实现异步秒杀"></a>Redis消息队列（Message Queue）实现异步秒杀</h2><h3 id="认识消息队列"><a href="#认识消息队列" class="headerlink" title="认识消息队列"></a>认识消息队列</h3><p>什么是消息队列：字面意思就是存放消息的队列。最简单的消息队列模型包括3个角色：</p><ul><li>消息队列：存储和管理消息，也被称为消息代理（Message Broker</li><li>生产者：发送消息到消息队列</li><li>消费者：从消息队列获取消息并处理消息</li></ul><p>使用队列的好处在于 <strong>解耦：</strong>所谓解耦，举一个生活中的例子就是：快递员(生产者)把快递放到快递柜里边(Message Queue)去，我们(消费者)从快递柜里边去拿东西，这就是一个异步，如果耦合，那么这个快递员相当于直接把快递交给你，这事固然好，但是万一你不在家，那么快递员就会一直等你，这就浪费了快递员的时间，所以这种思想在我们日常开发中，是非常有必要的。</p><p>这里我们可以使用一些现成的mq，比如kafka，rabbitmq等等，但是呢，如果没有安装mq，我们也可以直接使用redis提供的mq方案，降低我们的部署和学习成本。</p><h3 id="redis-消息队列"><a href="#redis-消息队列" class="headerlink" title="redis 消息队列"></a>redis 消息队列</h3><h4 id="基于List结构模拟消息队列"><a href="#基于List结构模拟消息队列" class="headerlink" title="基于List结构模拟消息队列"></a>基于List结构模拟消息队列</h4><p>双向链表很容易模拟出队列的效果</p><p>不过要注意的是，当队列中没有消息时RPOP或LPOP操作会返回null，并不像JVM的阻塞队列那样会阻塞并等待消息。因此这里应该使用<strong>BRPOP</strong>或者<strong>BLPOP</strong>来实现阻塞效果。</p><p>基于List的消息队列有哪些优缺点？<br>优点：</p><ul><li>利用Redis存储，不受限于JVM内存上限</li><li>基于Redis的持久化机制，数据安全性有保证</li><li>可以满足消息有序性</li></ul><p>缺点</p><ul><li>无法避免消息丢失</li><li>只支持单消费者</li></ul><h4 id="基于PubSub-发布订阅-的消息队列"><a href="#基于PubSub-发布订阅-的消息队列" class="headerlink" title="基于PubSub(发布订阅)的消息队列"></a>基于PubSub(发布订阅)的消息队列</h4><p>顾名思义，消费者可以订阅一个或多个channel，生产者向对应channel发送消息后，所有订阅者都能收到相关消息。与基于list 结构的消息队列相比最大的改进就是能支持多个消费者,但是不支持数据持久化。</p><p> SUBSCRIBE channel [channel] ：订阅一个或多个频道</p><p> PUBLISH channel msg ：向一个频道发送消息</p><p> PSUBSCRIBE pattern[pattern] ：订阅与pattern(通配符)格式匹配的所有频道</p><p>基于PubSub的消息队列有哪些优缺点？<br>优点：</p><ul><li>采用发布订阅模型，支持多生产、多消费</li></ul><p>缺点：</p><ul><li>不支持数据持久化</li><li>无法避免消息丢失</li><li>消息堆积有上限，超出时数据丢失(消息不在内存中保存，当发布消息的时候，如果有消费者监听，那么消息会放在消费者客户端的缓存区域，如果在消费者处理的时间段内，又来了很多消息，那么就会导致消费者缓存区域的堆积，超出数据会丢失)</li></ul><h3 id="基于Stream的消息队列"><a href="#基于Stream的消息队列" class="headerlink" title="基于Stream的消息队列"></a>基于Stream的消息队列</h3><p>Stream 是 Redis 5.0 引入的一种新<strong>数据类型</strong>，可以实现一个功能非常完善的消息队列。</p><p>STREAM类型消息队列的XREAD命令特点：</p><ul><li>消息可回溯</li><li>一个消息可以被多个消费者读取</li><li>可以阻塞读取</li><li>有消息漏读的风险</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;基于-Session-短信登录&quot;&gt;&lt;a href=&quot;#基于-Session-短信登录&quot; class=&quot;headerlink&quot; title=&quot;基于 Session 短信登录&quot;&gt;&lt;/a&gt;基于 Session 短信登录&lt;/h2&gt;&lt;h3 id=&quot;发送短信验证码&quot;&gt;&lt;a h</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Spring6启示录</title>
    <link href="http://www.meprotoss.com/undefined/38bc4ed6.html"/>
    <id>http://www.meprotoss.com/undefined/38bc4ed6.html</id>
    <published>2024-05-06T08:41:30.000Z</published>
    <updated>2024-05-07T02:56:41.230Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>[!TIP]<br>基于动力节点spring6总结</p></blockquote><h2 id="Spring启示录"><a href="#Spring启示录" class="headerlink" title="Spring启示录"></a>Spring启示录</h2><h3 id="OCP开闭原则"><a href="#OCP开闭原则" class="headerlink" title="OCP开闭原则"></a>OCP开闭原则</h3><p>在软件开发过程中应当对扩展开放，对修改关闭</p><h3 id="依赖倒置"><a href="#依赖倒置" class="headerlink" title="依赖倒置"></a>依赖倒置</h3><ul><li><p>Dependence Inversion Principle(DIP)</p></li><li><p>要倡导面向抽象编程，面向接口编程，不要面向具体编程，让上层不再依赖下层，下面改动了，上面的代码不会受到牵连。这样可以大大降低程序的耦合度，耦合度低了，扩展力就强了，同时代码复用性也会增强。（软件七大开发原则都是在为解耦合服务）</p></li><li><p>Spring框架可以帮助我们创建对象，并且可以帮助我们维护对象和对象之间的关系</p></li><li><p>Spring其实就是一个管理Bean对象的工厂</p></li></ul><h3 id="控制反转"><a href="#控制反转" class="headerlink" title="控制反转"></a>控制反转</h3><ul><li>Inversion of Control(IoC)</li></ul><p>控制反转的核心是：将对象的创建权交出去，将对象和对象之间关系的管理权交出去，由第三方容器来负责创建与维护。</p><ul><li>控制反转常见的实现方式：依赖注入（Dependency Injection，简称DI。</li></ul><h2 id="Spring概述"><a href="#Spring概述" class="headerlink" title="Spring概述"></a>Spring概述</h2><p>spring &#x3D; IOC + AOP(面向切面编程)</p><h3 id="Spring8大模块"><a href="#Spring8大模块" class="headerlink" title="Spring8大模块"></a>Spring8大模块</h3><h3 id="Spring-特点"><a href="#Spring-特点" class="headerlink" title="Spring 特点"></a>Spring 特点</h3><ol><li>轻量<br>  a. 小<br>  b. 非侵入式：Spring应用中的对象不依赖于Spring的特定类，也就是说 我们自己创建的对象不依赖spring容器</li><li>IoC</li><li>面向切面(AOP)</li><li>容器<br> Spring包含并管理应用对象的配置和生命周期，在这个意义上它是一种容器，你可以配置你的每个bean如何被创建——基于一个可配置原型（prototype），你的bean可以创建一个单独的实例或者每次需要时都生成一个新的实例——以及它们是如何相互关联的。</li><li>框架<br> Spring可以将简单的组件配置、组合成为复杂的应用。在Spring中，应用对象被声明式地组合，典型地是在一个XML文件里。Spring也提供了很多基础功能（事务管理、持久化框架集成等等），将应用逻辑的开发留给了你。</li></ol><h2 id="Spring-入门程序"><a href="#Spring-入门程序" class="headerlink" title="Spring 入门程序"></a>Spring 入门程序</h2><h3 id="第一个Spring程序"><a href="#第一个Spring程序" class="headerlink" title="第一个Spring程序"></a>第一个Spring程序</h3><ul><li><p>Spring的配置文件：beans.xml 放在类的根路径下。<br>配置文件中进行bean的配置</p><ul><li>id属性：代表对象的唯一标识。</li><li>class属性:用来指定要创建的java类的类名，这个类名必须是全限定类名（包含包名</li></ul></li><li><p>Spring是通过反射机制调用类的无参构造方法来创建对象的。</p></li></ul><h3 id="Spring6-启用Log4j2日志框架"><a href="#Spring6-启用Log4j2日志框架" class="headerlink" title="Spring6 启用Log4j2日志框架"></a>Spring6 启用Log4j2日志框架</h3><p>第一步：引入Log4j2的依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--log4j2的依赖--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.logging.log4j<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>log4j-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.19.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.logging.log4j<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>log4j-slf4j2-impl<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.19.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>第二步：在类的根路径下提供log4j2.xml配置文件（文件名固定为：log4j2.xml，文件必须放到类根路径下。）</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">loggers</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">            level指定日志级别，从低到高的优先级：</span></span><br><span class="line"><span class="comment">                ALL &lt; TRACE &lt; DEBUG &lt; INFO &lt; WARN &lt; ERROR &lt; FATAL &lt; OFF</span></span><br><span class="line"><span class="comment">        --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">root</span> <span class="attr">level</span>=<span class="string">&quot;DEBUG&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">appender-ref</span> <span class="attr">ref</span>=<span class="string">&quot;spring6log&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">root</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">loggers</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">appenders</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--输出日志信息到控制台--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">console</span> <span class="attr">name</span>=<span class="string">&quot;spring6log&quot;</span> <span class="attr">target</span>=<span class="string">&quot;SYSTEM_OUT&quot;</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--控制日志输出的格式--&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">PatternLayout</span> <span class="attr">pattern</span>=<span class="string">&quot;%d&#123;yyyy-MM-dd HH:mm:ss SSS&#125; [%t] %-3level %logger&#123;1024&#125; - %msg%n&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">console</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">appenders</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>第三步：使用日志框架</p><h2 id="四、Spring对IoC的实现"><a href="#四、Spring对IoC的实现" class="headerlink" title="四、Spring对IoC的实现"></a>四、Spring对IoC的实现</h2><h3 id="IoC控制反转"><a href="#IoC控制反转" class="headerlink" title="IoC控制反转"></a>IoC控制反转</h3><ul><li><p>控制反转是一种思想。</p></li><li><p>控制反转是为了降低程序耦合度，提高程序扩展力，达到OCP原则，达到DIP原则。</p></li><li><p>控制反转，反转的是什么？</p><ul><li><p>将对象的创建权利交出去，交给第三方容器负责。</p></li><li><p>将对象和对象之间关系的维护权交出去，交给第三方容器负责。</p></li></ul></li><li><p>控制反转这种思想如何实现呢？</p><ul><li>DI（Dependency Injection）：依赖注入</li></ul></li></ul><h3 id="IoC依赖注入"><a href="#IoC依赖注入" class="headerlink" title="IoC依赖注入"></a>IoC依赖注入</h3><p>依赖注入实现了控制反转的思想。</p><p>Spring通过依赖注入的方式来完成Bean管理的。</p><p>Bean管理说的是：Bean对象的创建，以及Bean对象中属性的赋值（或者叫做Bean对象之间关系的维护）。</p><p>依赖注入：</p><ul><li><p>依赖指的是对象和对象之间的关联关系。</p></li><li><p>注入指的是一种数据传递行为，通过注入行为来让对象和对象产生关系。</p></li></ul><p>依赖注入常见的实现方式包括两种：</p><p>set注入:基于<strong>set方法</strong>实现，底层通过反射机制调用属性对应的set方法然后给属性赋值。因此这种方法要求属性必须对外暴露set方法。</p><p>总结：set注入的核心实现原理：通过反射机制调用set方法来给属性赋值，让两个对象之间产生关系。</p><p>构造注入:通过调用<strong>构造方法</strong>来给属性赋值。</p><p>通过测试得知，通过构造方法注入的时候：</p><ul><li>可以通过下标</li><li>可以通过参数名</li><li>也可以不指定下标和参数名，可以类型自动推断。</li></ul><h3 id="p命名空间注入"><a href="#p命名空间注入" class="headerlink" title="p命名空间注入"></a>p命名空间注入</h3><p>p命名空间注入是基于setter方法的，所以需要对应的属性提供setter方法。</p><h3 id="c命名空间注入"><a href="#c命名空间注入" class="headerlink" title="c命名空间注入"></a>c命名空间注入</h3><p>c命名空间是简化构造方法注入的,需要提供构造方法</p><ul><li>注意：不管是p命名空间还是c命名空间，注入的时候都可以注入简单类型以及非简单类型。</li></ul><h3 id="util命名空间"><a href="#util命名空间" class="headerlink" title="util命名空间"></a>util命名空间</h3><p>使用util命名空间可以让配置复用。</p><h3 id="基于XML的自动装配"><a href="#基于XML的自动装配" class="headerlink" title="基于XML的自动装配"></a>基于XML的自动装配</h3><p>Spring还可以完成自动化的注入，自动化注入又被称为自动装配。它可以根据名字进行自动装配，也可以根据类型进行自动装配。</p><p>如果根据名称装配(byName)，底层会调用set方法进行注入。<br>例如：setAge() 对应的名字是age，setPassword()对应的名字是password，setEmail()对应的名字是email。</p><p>当byType进行自动装配的时候，配置文件中某种类型的Bean必须是唯一的</p><h3 id="Spring-引入外部配置文件"><a href="#Spring-引入外部配置文件" class="headerlink" title="Spring 引入外部配置文件"></a>Spring 引入外部配置文件</h3><h2 id="Bean的作用域"><a href="#Bean的作用域" class="headerlink" title="Bean的作用域"></a>Bean的作用域</h2><h3 id="单例-singleton"><a href="#单例-singleton" class="headerlink" title="单例 singleton"></a>单例 singleton</h3><p>默认情况下，Spring的IoC容器创建的Bean对象是单例的。</p><p>Bean对象的创建是在初始化Spring上下文的时候就完成的。</p><h3 id="多例-prototype"><a href="#多例-prototype" class="headerlink" title="多例 prototype"></a>多例 prototype</h3><p>如果想让Spring的Bean对象以多例的形式存在，可以在bean标签中指定scope属性的值为：prototype</p><p>scope如果没有配置，它的默认值是什么呢？默认值是singleton，单例的。</p><h3 id="其他scope"><a href="#其他scope" class="headerlink" title="其他scope"></a>其他scope</h3><h2 id="Gof-gang-of-four-之工厂模式"><a href="#Gof-gang-of-four-之工厂模式" class="headerlink" title="Gof (gang of four) 之工厂模式"></a>Gof (gang of four) 之工厂模式</h2><p>设计模式: 一种可以被重复利用的方案</p><p>工厂模式是解决对象创建问题的，所以工厂模式属于创建型设计模式。这里为什么学习工厂模式呢？这是因为Spring框架底层使用了大量的工厂模式。</p><p>GoF23种设计模式可分为三大类:</p><ul><li>创建型（5个）：解决对象创建问题。</li><li>结构型(7个)：一些类或对象组合在一起的经典结构。</li><li>行为型（11个）：解决类或对象之间的交互问题。</li></ul><h3 id="工厂模式的三种形态"><a href="#工厂模式的三种形态" class="headerlink" title="工厂模式的三种形态"></a>工厂模式的三种形态</h3><ol><li>简单工厂模式（Simple Factory）：不属于23种设计模式之一。简单工厂模式又叫做：静态 工厂方法模式。简单工厂模式是工厂方法模式的一种特殊实现。</li><li>工厂方法模式（Factory Method）：是23种设计模式之一。</li><li>抽象工厂模式（Abstract Factory）：是23种设计模式之一。</li></ol><h3 id="简单工厂模式"><a href="#简单工厂模式" class="headerlink" title="简单工厂模式"></a>简单工厂模式</h3><p>单工厂模式的角色包括三个：</p><ol><li>抽象产品角色</li><li>具体产品角色</li><li>工厂类角色</li></ol><p>抽象产品角色：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.powernode.factory;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 武器（抽象产品角色）</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> 动力节点</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> 1.0</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@className</span> Weapon</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 1.0</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Weapon</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 所有的武器都有攻击行为</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">attack</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>具体产品角色：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.powernode.factory;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 坦克（具体产品角色）</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> 动力节点</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> 1.0</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@className</span> Tank</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 1.0</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Tank</span> <span class="keyword">extends</span> <span class="title class_">Weapon</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">attack</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;坦克开炮！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.powernode.factory;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 战斗机（具体产品角色）</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> 动力节点</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> 1.0</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@className</span> Fighter</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 1.0</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Fighter</span> <span class="keyword">extends</span> <span class="title class_">Weapon</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">attack</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;战斗机投下原子弹！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.powernode.factory;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 匕首（具体产品角色）</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> 动力节点</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> 1.0</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@className</span> Dagger</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 1.0</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Dagger</span> <span class="keyword">extends</span> <span class="title class_">Weapon</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">attack</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;砍他丫的！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>工厂类角色：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.powernode.factory;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 工厂类角色</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> 动力节点</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> 1.0</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@className</span> WeaponFactory</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 1.0</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WeaponFactory</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据不同的武器类型生产武器</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> weaponType 武器类型</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 武器对象</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Weapon <span class="title function_">get</span><span class="params">(String weaponType)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (weaponType == <span class="literal">null</span> || weaponType.trim().length() == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">Weapon</span> <span class="variable">weapon</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (<span class="string">&quot;TANK&quot;</span>.equals(weaponType)) &#123;</span><br><span class="line">            weapon = <span class="keyword">new</span> <span class="title class_">Tank</span>();</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">&quot;FIGHTER&quot;</span>.equals(weaponType)) &#123;</span><br><span class="line">            weapon = <span class="keyword">new</span> <span class="title class_">Fighter</span>();</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">&quot;DAGGER&quot;</span>.equals(weaponType)) &#123;</span><br><span class="line">            weapon = <span class="keyword">new</span> <span class="title class_">Dagger</span>();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;不支持该武器！&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> weapon;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>测试程序（客户端程序）：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.powernode.factory;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> 动力节点</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> 1.0</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@className</span> Client</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 1.0</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Weapon</span> <span class="variable">weapon1</span> <span class="operator">=</span> WeaponFactory.get(<span class="string">&quot;TANK&quot;</span>);</span><br><span class="line">        weapon1.attack();</span><br><span class="line"></span><br><span class="line">        <span class="type">Weapon</span> <span class="variable">weapon2</span> <span class="operator">=</span> WeaponFactory.get(<span class="string">&quot;FIGHTER&quot;</span>);</span><br><span class="line">        weapon2.attack();</span><br><span class="line"></span><br><span class="line">        <span class="type">Weapon</span> <span class="variable">weapon3</span> <span class="operator">=</span> WeaponFactory.get(<span class="string">&quot;DAGGER&quot;</span>);</span><br><span class="line">        weapon3.attack();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="依赖注入"><a href="#依赖注入" class="headerlink" title="依赖注入"></a>依赖注入</h2><h3 id="set-注入-主要应用"><a href="#set-注入-主要应用" class="headerlink" title="set 注入(主要应用)"></a>set 注入(主要应用)</h3><ul><li><input disabled="" type="checkbox"> set注入的核心实现原理：通过反射机制调用set方法来给属性赋值，让两个对象之间产生关系。</li><li><input disabled="" type="checkbox"> property标签的name是：setUserDao()方法名演变得到的</li><li><input disabled="" type="checkbox"> 注入外部bean</li></ul><blockquote><blockquote><ul><li><input disabled="" type="checkbox"> 外部Bean的特点：bean定义到外面，在property标签中使用ref属性进行注入。通常这种方式是常用。 [ ] 注入内部bean</li></ul></blockquote></blockquote><ul><li><input disabled="" type="checkbox"> 注入简单类型</li></ul><blockquote><blockquote><ul><li><input disabled="" type="checkbox"> 如果给简单类型赋值，使用value属性或value标签。而不是ref。</li><li><input disabled="" type="checkbox"> 简单类型包括哪些呢？</li></ul></blockquote></blockquote><ul><li>基本数据类型</li><li>基本数据类型对应的包装类</li><li>String或其他的CharSequence子类</li><li>Number子类</li><li>Date子类</li><li>Enum子类</li><li>URI</li><li>URL</li><li>Temporal子类</li><li>Locale</li><li>Class</li><li>另外还包括以上简单值类型对应的数组类型<blockquote><blockquote><ul><li><input disabled="" type="checkbox"> 需要注意的是：</li></ul></blockquote></blockquote></li><li>如果把Date当做简单类型的话，日期字符串格式不能随便写。格式必须符合Date的toString()方法格式。显然这就比较鸡肋了。如果我们提供一个这样的日期字符串：2010-10-11，在这里是无法赋值给Date类型的属性的。</li><li>spring6之后，当注入的是URL，那么这个url字符串是会进行有效性检测的。如果是一个存在的url，那就没问题。如果不存在则报错。</li></ul><hr><ul><li><input disabled="" type="checkbox"> 级联属性赋值</li></ul><blockquote><blockquote><ul><li><input disabled="" type="checkbox"> 要点：</li></ul></blockquote></blockquote><ul><li><p>在spring配置文件中，如上，注意顺序。</p></li><li><p>在spring配置文件中，clazz属性必须提供getter方法。</p></li><li><p><input disabled="" type="checkbox"> 注入数组<br>要点：</p></li><li><p>如果数组中是简单类型，使用value标签。</p></li><li><p>如果数组中是非简单类型，使用ref标签。</p></li><li><p><input disabled="" type="checkbox"> 注入list集合(有序可重复)</p><ul><li>同上，只要把array标签改为list</li><li>注意：注入List集合的时候使用list标签，如果List集合中是简单类型使用value标签，反之使用ref标签。</li></ul></li><li><p><input disabled="" type="checkbox"> 注入set集合(无序不可重复)</p><ul><li><p>使用<code>&lt;set&gt;</code>标签</p></li><li><p>set集合中元素是简单类型的使用value标签，反之使用ref标签。</p></li><li><p><input disabled="" type="checkbox"> 注入map集合<br>要点：</p></li><li><p>使用<code>&lt;map&gt;</code>标签</p></li><li><p>如果key是简单类型，使用 key 属性，反之使用 key-ref 属性。</p></li><li><p>如果value是简单类型，使用 value 属性，反之使用 value-ref 属性。</p></li><li><p><input disabled="" type="checkbox"> p命名空间注入</p></li></ul><p>使用p命名空间注入的前提条件包括两个：</p><ul><li><p>第一：在XML头部信息中添加p命名空间的配置信息：xmlns:p&#x3D;”<a href="http://www.springframework.org/schema/p">http://www.springframework.org/schema/p</a>“</p></li><li><p>第二：p命名空间注入是基于setter方法的，所以需要对应的属性提供setter方法。</p></li><li><p><input disabled="" type="checkbox"> c命名空间注入</p></li></ul><p>c命名空间是简化构造方法注入的。</p><ul><li><p>使用c命名空间的两个前提条件：<br>第一：需要在xml配置文件头部添加信息：xmlns:c&#x3D;”<a href="http://www.springframework.org/schema/c">http://www.springframework.org/schema/c</a>“</p></li><li><p>第二：需要提供构造方法。</p></li><li><p><input disabled="" type="checkbox"> util 命名空间</p></li><li><p>使用util命名空间可以让配置复用。</p></li></ul></li></ul><h3 id="构造注入"><a href="#构造注入" class="headerlink" title="构造注入"></a>构造注入</h3><ul><li><p><input disabled="" type="checkbox"> 通过测试得知，通过构造方法注入的时候</p></li><li><p>可以通过下标</p></li><li><p>可以通过参数名</p></li><li><p>也可以不指定下标和参数名，可以类型自动推断。</p></li><li><p>spring在装配方面做的还是比较健壮的</p></li></ul><h3 id="基于XML的自动装配-1"><a href="#基于XML的自动装配-1" class="headerlink" title="基于XML的自动装配"></a>基于XML的自动装配</h3><ul><li><p><input disabled="" type="checkbox"> 根据名称自动装配</p></li><li><p>Spring还可以完成自动化的注入，自动化注入又被称为自动装配。它可以根据名字进行自动装配，也可以根据类型进行自动装配</p></li><li><p>这说明，如果根据名称装配(byName)，底层会调用set方法进行注入。<br>例如：setAge() 对应的名字是age，setPassword()对应的名字是password，setEmail()对应的名字是email。</p></li><li><p><input disabled="" type="checkbox"> 根据类型自动装配</p></li><li><p>配置文件中某种类型的Bean必须是唯一的，不能出现多个。</p></li></ul><h3 id="spring引入外部属性配置文件"><a href="#spring引入外部属性配置文件" class="headerlink" title="spring引入外部属性配置文件"></a>spring引入外部属性配置文件</h3><h3 id="Bean的作用域-1"><a href="#Bean的作用域-1" class="headerlink" title="Bean的作用域"></a>Bean的作用域</h3><ul><li><p><input disabled="" type="checkbox"> Spring的IoC容器中，默认情况下，Bean对象是单例的</p></li><li><p><input disabled="" type="checkbox"> 默认情况下，Bean对象的创建是在初始化Spring上下文的时候就完成的</p></li><li><p><input disabled="" type="checkbox"> 如果想让Spring的Bean对象以多例的形式存在，可以在bean标签中指定scope属性的值为：prototype，<strong>这样Spring会在每一次执行getBean()方法的时候创建Bean对象</strong>，调用几次则创建几次。</p></li><li><p>scope属性的值不止两个，它一共包括8个选项：</p></li><li><p>singleton：默认的，单例。</p></li><li><p>prototype：原型。每调用一次getBean()方法则获取一个新的Bean对象。或每次注入的时候都是新对象。</p></li><li><p>request：一个请求对应一个Bean。仅限于在WEB应用中使用。</p></li><li><p>session：一个会话对应一个Bean。仅限于在WEB应用中使用。</p></li><li><p>global session：portlet应用中专用的。如果在Servlet的WEB应用中使用global session的话，和session一个效果。（portlet和servlet都是规范。servlet运行在servlet容器中，例如Tomcat。portlet运行在portlet容器中。）</p></li><li><p>application：一个应用对应一个Bean。仅限于在WEB应用中使用。</p></li><li><p>websocket：一个websocket生命周期对应一个Bean。仅限于在WEB应用中使用。</p></li><li><p>自定义scope：很少使用。</p></li></ul><h3 id="Gof-FactoryMode-工厂模式"><a href="#Gof-FactoryMode-工厂模式" class="headerlink" title="Gof FactoryMode 工厂模式"></a>Gof FactoryMode 工厂模式</h3><ul><li><input disabled="" type="checkbox"> 简单工厂模式</li></ul><blockquote><blockquote><ul><li><input disabled="" type="checkbox"> 简单工厂模式的优点：</li></ul></blockquote></blockquote><ul><li><p>客户端程序不需要关心对象的创建细节，需要哪个对象时，只需要向工厂索要即可，初步实现了责任的分离。客户端只负责“消费”，工厂负责“生产”。生产和消费分离。</p><blockquote><blockquote><ul><li><input disabled="" type="checkbox"> 简单工厂模式的缺点：</li></ul></blockquote></blockquote></li><li><p>缺点1：工厂类集中了所有产品的创造逻辑，形成一个无所不知的全能类，有人把它叫做上帝类。显然工厂类非常关键，不能出问题，一旦出问题，整个系统瘫痪。</p></li><li><p>缺点2：不符合OCP开闭原则，在进行系统扩展时，需要修改工厂类。Spring中的BeanFactory就使用了简单工厂模式。</p></li><li><p><input disabled="" type="checkbox"> 工厂方法模式</p></li></ul><blockquote><blockquote><ul><li><input disabled="" type="checkbox"> 工厂方法模式既保留了简单工厂模式的优点，同时又解决了简单工厂模式的缺点。<br>工厂方法模式的角色包括：</li></ul></blockquote></blockquote><ul><li>抽象工厂角色</li><li>具体工厂角色</li><li>抽象产品角色</li><li>具体产品角色</li></ul><h2 id="Bean的实例化方式"><a href="#Bean的实例化方式" class="headerlink" title="Bean的实例化方式"></a>Bean的实例化方式</h2><h3 id="1-构造方法"><a href="#1-构造方法" class="headerlink" title="1. 构造方法"></a>1. 构造方法</h3><ul><li><input disabled="" type="checkbox"> 在配置文件中配置类的全路径，spirng直接调用该类的无参构造方法获取bean对象</li></ul><h3 id="2-简单工厂模式"><a href="#2-简单工厂模式" class="headerlink" title="2. 简单工厂模式"></a>2. 简单工厂模式</h3><ul><li><input disabled="" type="checkbox"> 通过简单工厂模式，调用<code>工厂</code>的静态方法<code>get()</code>获取bean对象</li><li><input disabled="" type="checkbox"> 工厂类里的方法是静态方法，所以不需要spring工厂的实例</li></ul><h3 id="3-通过factory-bean实例化-本质上是工厂方法模式"><a href="#3-通过factory-bean实例化-本质上是工厂方法模式" class="headerlink" title="3. 通过factory-bean实例化(本质上是工厂方法模式)"></a>3. 通过factory-bean实例化(本质上是工厂方法模式)</h3><ul><li><input disabled="" type="checkbox"> 工厂类里的方法是非静态方法，所工厂类也必须被spring管理起来</li><li><input disabled="" type="checkbox"> 标签也要多一个 因为得告诉spring是创建哪个<code>工厂</code> 的 哪个<code>对象</code><br>所以得指定哪个对象(factory-bean)的哪个方法(factory-method)</li></ul><h3 id="4-通过FactoryBean接口实例化"><a href="#4-通过FactoryBean接口实例化" class="headerlink" title="4. 通过FactoryBean接口实例化"></a>4. 通过FactoryBean接口实例化</h3><ul><li><input disabled="" type="checkbox"> 只要实现接口和接口的抽象方法 就可以不需要指定factory-bean 和<br>factory-method。是对第三种方法的简化</li><li><input disabled="" type="checkbox"> 因为实现了接口所以直接认为你这个类的对象就是一个豆子<br>td因为实现了接口所以直接认为你这个类的对象就是一个豆子</li></ul><h3 id="BeanFactory-和-FactoryBean-的区别"><a href="#BeanFactory-和-FactoryBean-的区别" class="headerlink" title="BeanFactory 和 FactoryBean 的区别"></a>BeanFactory 和 FactoryBean 的区别</h3><ul><li><p><input disabled="" type="checkbox"> BeanFactory</p></li><li><p>Spring IoC容器的顶级对象，BeanFactory被翻译为“Bean工厂”，在Spring的IoC容器中，“Bean工厂”负责创建Bean对象。<br>BeanFactory是工厂。</p></li><li><p><input disabled="" type="checkbox"> FactoryBean</p></li><li><p>它是一个<strong>Bean</strong>，是一个能够辅助Spring实例化其它Bean对象的一个Bean。<br>在Spring中，Bean可以分为两类：<br>● 第一类：普通Bean<br>● 第二类：工厂Bean（记住：工厂Bean也是一种Bean，只不过这种Bean比较特殊，它可以辅助Spring实例化其它Bean对象。）</p></li></ul><h3 id="注入自定义-Date-工厂Bean的实际应用"><a href="#注入自定义-Date-工厂Bean的实际应用" class="headerlink" title="注入自定义 Date (工厂Bean的实际应用)"></a>注入自定义 Date (工厂Bean的实际应用)</h3><h3 id="Bean-的生命周期-可分为5步7步10步-也就是bean对象从开始创建到消亡的整个过程"><a href="#Bean-的生命周期-可分为5步7步10步-也就是bean对象从开始创建到消亡的整个过程" class="headerlink" title="Bean 的生命周期(可分为5步7步10步)(也就是bean对象从开始创建到消亡的整个过程)"></a>Bean 的生命周期(可分为5步7步10步)(也就是bean对象从开始创建到消亡的整个过程)</h3><ul><li><input disabled="" type="checkbox"> 当想在具体某个生命周期做指定操作时可以用到</li><li>第一步：实例化Bean</li><li>第二步：Bean属性赋值</li><li>第三步：初始化Bean 需要手动指定 使用init-method标签<br>** bean后处理器的before方法</li><li>第四步：使用Bean<br>** bean后处理器的after方法</li><li>第五步：销毁Bean 使用手动指定 用destory-method标签</li></ul><h3 id="Bean的作用域不同，管理方式不同"><a href="#Bean的作用域不同，管理方式不同" class="headerlink" title="Bean的作用域不同，管理方式不同"></a>Bean的作用域不同，管理方式不同</h3><ul><li>对于singleton作用域的Bean，Spring 能够精确地知道该Bean何时被创建，何时初始化完成，以及何时被销毁；</li><li>而对于 prototype 作用域的 Bean，Spring 只负责创建，当容器创建了<br>Bean 的实例后，Bean 的实例就交给客户端代码管理，Spring 容器将不再跟踪其生命周期。</li></ul><h3 id="自己new的对象可以让Spring管理"><a href="#自己new的对象可以让Spring管理" class="headerlink" title="自己new的对象可以让Spring管理"></a>自己new的对象可以让Spring管理</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RegisterBeanTest</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testBeanRegister</span><span class="params">()</span>&#123;</span><br><span class="line">      <span class="comment">// 自己new的对象</span></span><br><span class="line">      <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>();</span><br><span class="line">      System.out.println(user);</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 创建 默认可列表BeanFactory 对象</span></span><br><span class="line">      <span class="type">DefaultListableBeanFactory</span> <span class="variable">factory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DefaultListableBeanFactory</span>();</span><br><span class="line">      <span class="comment">// 注册Bean</span></span><br><span class="line">      factory.registerSingleton(<span class="string">&quot;userBean&quot;</span>, user);</span><br><span class="line">      <span class="comment">// 从spring容器中获取bean</span></span><br><span class="line">      <span class="type">User</span> <span class="variable">userBean</span> <span class="operator">=</span> factory.getBean(<span class="string">&quot;userBean&quot;</span>, User.class);</span><br><span class="line">      System.out.println(userBean);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="Bean的循环依赖问题"><a href="#Bean的循环依赖问题" class="headerlink" title="Bean的循环依赖问题"></a>Bean的循环依赖问题</h2><h3 id="singleton-set注入"><a href="#singleton-set注入" class="headerlink" title="singleton + set注入"></a><code>singleton</code> + set注入</h3><p>循环依赖没有问题,解决方法如下:</p><ul><li><input disabled="" type="checkbox"> spring容器一旦将bean创建出来就立刻进行<code>曝光</code><br>(不赋值就告诉大家我可以被使用啦！！)</li><li><input disabled="" type="checkbox"> 曝光之后再进行赋值</li></ul><h3 id="prototype-set注入"><a href="#prototype-set注入" class="headerlink" title="prototype + set注入"></a><code>prototype</code> + set注入</h3><ul><li><input disabled="" type="checkbox"> 当循环依赖的 <strong>所有</strong> Bean的scope&#x3D;”prototype”的时候，产生的循环依赖，Spring是无法解决的，会出现BeanCurrentlyInCreationException异常。<blockquote><blockquote><ul><li><input disabled="" type="checkbox"> new ClassPathApplicationContext的时候不会new对象<br>，只有在getBean的时候才会创建对象,会无限递归</li></ul></blockquote></blockquote></li><li><input disabled="" type="checkbox"> 当循环依赖的一个是单例时，就不会出现问题</li></ul><h3 id="singleton-prototype-构造注入"><a href="#singleton-prototype-构造注入" class="headerlink" title="singleton&#x2F;prototype+ 构造注入"></a><code>singleton</code>&#x2F;<code>prototype</code>+ 构造注入</h3><ul><li><input disabled="" type="checkbox"> 有异常，因为创建对象和给属性赋值是同时进行的，不给属性赋值对象就创建不出来</li></ul><h3 id="Spring解决循环依赖的机理"><a href="#Spring解决循环依赖的机理" class="headerlink" title="Spring解决循环依赖的机理"></a>Spring解决循环依赖的机理</h3><ul><li><input disabled="" type="checkbox"> Spring只能解决setter方法注入的单例bean之间的循环依赖。<br>ClassA依赖ClassB，ClassB又依赖ClassA，形成依赖闭环。<br>Spring在创建ClassA对象后，不需要等给属性赋值，直接将其曝光到bean缓存当中。在解析ClassA的属性时，又发现依赖于ClassB，再次去获取ClassB，当解析ClassB的属性时，又发现需要ClassA的属性，但此时的ClassA已经被提前曝光加入了正在创建的bean的缓存中，则无需创建新的的ClassA的实例，直接从缓存中获取即可。从而解决循环依赖问题。</li></ul><h2 id="回顾反射机制"><a href="#回顾反射机制" class="headerlink" title="回顾反射机制"></a>回顾反射机制</h2><h3 id="方法调用的四个要素"><a href="#方法调用的四个要素" class="headerlink" title="方法调用的四个要素"></a>方法调用的四个要素</h3><ul><li>哪个对象 </li><li>哪个方法 </li><li>哪个参数</li><li>返回什么值</li></ul><h2 id="全注解式开发"><a href="#全注解式开发" class="headerlink" title="全注解式开发"></a>全注解式开发</h2><h3 id="负责声明bean的注解"><a href="#负责声明bean的注解" class="headerlink" title="负责声明bean的注解"></a>负责声明bean的注解</h3><ul><li>@Component</li><li>@Controller</li><li>@Service</li><li>@Repository</li></ul><p>@Controller、@Service、@Repository这三个注解都是@Component注解的别名。其实这四个注解的功能一样，但是为了增强程序的可读性</p><ul><li>控制器类上使用：Controller</li><li>service类上使用：Service</li><li>dao类上使用：Repository</li></ul><p>他们都是只有一个value属性。value属性用来指定bean的id，也就是bean的名字。</p><h3 id="spring注解的使用"><a href="#spring注解的使用" class="headerlink" title="spring注解的使用"></a>spring注解的使用</h3><ol><li>加入AOP依赖(一般会加入spring-context依赖后会关联加入，所以这一步不用做)</li><li>配置文件中配置context命名空间</li><li>配置包扫描</li><li>Bean上使用注解</li></ol><blockquote><p>[!TIP]<br>如果注解的属性名是value，那么可以省略<br>  如果把value属性彻底去掉，spring会被Bean自动取名，并且默认名字的规律是：Bean类名首字母小写后面不变。</p></blockquote><p>如果是多个包怎么办？有两种解决方案：</p><ul><li>第一种：在配置文件中指定多个包，用逗号隔开。</li><li>第二种：指定多个包的共同父包。</li></ul><h3 id="选择性实例化Bean"><a href="#选择性实例化Bean" class="headerlink" title="选择性实例化Bean"></a>选择性实例化Bean</h3><p>假设在某个包下有很多Bean，有的Bean上标注了Component，有的标注了Controller，有的标注了Service，有的标注了Repository，现在由于某种特殊业务的需要，只允许其中所有的Controller参与Bean管理</p><ul><li>修改配置文件就行，用到再去查</li></ul><h3 id="负责注入的注解"><a href="#负责注入的注解" class="headerlink" title="负责注入的注解"></a>负责注入的注解</h3><p>@Component @Controller @Service @Repository 这四个注解是用来<strong>声明</strong>Bean的，声明后这些Bean将被实例化。接下来我们看一下，如何给Bean的属性赋值。给Bean属性<strong>赋值</strong>需要用到这些注解：</p><ul><li><p>@Value 负责注入简单类型</p><ul><li>@Value注解可以直接使用在属性上，也可以使用在setter方法上,以及构造方法的形参上。</li><li>为了简化代码，以后我们一般不提供setter方法，直接在属性上使用@Value注解完成属性赋值。</li></ul></li><li><p>@Autowired 单独使用@Autowired注解，默认根据类型装配。【默认是byType】</p><ul><li>@Autowired注解可以用来注入非简单类型。被翻译为：自动连线的，或者自动装配。单独使用@Autowired注解，默认根据类型装配。【默认是byType】</li><li>当有参数的构造方法只有一个时，@Autowired注解可以省略。如果有多个构造方法，@Autowired肯定是不能省略的。</li><li>可以直接使用在属性上，也可以使用在setter方法上,以及构造方法、构造方法参数上</li></ul></li><li><p>如一个要装配的接口有不止一个实现类，则配合@Qualified使用才能byName进行装配</p></li><li><p>@Resource注解默认根据属性名进行装配。</p><ul><li>@Resource注解也可以完成非简单类型注入。</li><li>与@Autowired注解的区别：<ul><li>@Resource注解是JDK扩展包中的，也就是说属于JDK的一部分。所以该注解是标准注解，更加具有通用性。</li><li>@Autowired注解是Spring框架自己的。</li><li>@Resource注解默认根据名称装配byName，未指定name时，使用属性名作为name。通过name找不到的话会自动启动通过类型byType装配。</li><li>@Resource注解用在属性上、setter方法上。</li><li>@Autowired注解用在属性上、setter方法上、构造方法上、构造方法参数上。</li></ul></li></ul></li></ul><h2 id="GOF代理模式"><a href="#GOF代理模式" class="headerlink" title="GOF代理模式"></a>GOF代理模式</h2><h3 id="对代理模式的理解"><a href="#对代理模式的理解" class="headerlink" title="对代理模式的理解"></a>对代理模式的理解</h3><p>代理模式中有一个非常重要的特点：对于客户端程序来说，使用代理对象时就像在使用目标对象一样。【在程序中，目标需要被保护时】</p><p>代理模式是GoF23种设计模式之一。属于结构型设计模式。</p><p>代理模式的作用是：为其他对象提供一种代理以控制对这个对象的访问。在某些情况下，一个客户不想或者不能直接引用一个对象，此时可以通过一个称之为“代理”的第三者来实现间接引用。代理对象可以在客户端和目标对象之间起到<strong>中介</strong>的作用，并且可以通过代理对象去掉客户不应该看到的内容和服务或者添加客户需要的额外服务。 通过<strong>引入一个新的对象</strong>来实现对真实对象的操作或者将新的对象作为真实对象的一个替身，这种实现机制即为代理模式，<strong>通过引入代理对象来间接访问一个对象</strong>，这就是代理模式的模式动机。<br>代理模式中的角色：</p><ul><li>代理类（代理主题）</li><li>目标类（真实主题）</li><li>代理类和目标类的公共接口（抽象主题）：客户端在使用代理类时就像在使用目标类，不被客户端所察觉，所以代理类和目标类要有共同的行为，也就是实现共同的接口。</li></ul><h3 id="动态代理"><a href="#动态代理" class="headerlink" title="动态代理"></a>动态代理</h3><p>在内存当中动态生成类的技术常见的包括：</p><ul><li>JDK动态代理技术：只能代理接口。</li><li>CGLIB动态代理技术：CGLIB(Code Generation Library)是一个开源项目。是一个强大的，高性能，高质量的Code生成类库，它可以在运行期扩展Java类与实现Java接口。它既可以代理接口，又可以代理类，底层是通过<strong>继承</strong>的方式实现的,因此被代理的目标类不能用<code>final</code>修饰。性能比JDK动态代理要好。（底层有一个小而快的字节码处理框架ASM。）</li><li>Javassist动态代理技术：Javassist是一个开源的分析、编辑和创建Java字节码的类库。是由东京工业大学的数学和计算机科学系的 Shigeru Chiba （千叶 滋）所创建的。它已加入了开放源代码JBoss 应用服务器项目，通过使用Javassist对字节码操作为JBoss实现动态”AOP”框架。</li></ul><h3 id="静态代理和动态代理的区别"><a href="#静态代理和动态代理的区别" class="headerlink" title="静态代理和动态代理的区别"></a>静态代理和动态代理的区别</h3><p>静态代理和动态代理都是在面向对象编程中常见的设计模式，它们都允许一个对象在另一个对象的基础上提供额外的功能。它们的主要区别在于代理类的创建时间和绑定方式。</p><ol><li>静态代理：<br>静态代理是在编译时就已经确定了的代理关系。在静态代理中，代理类在编译期间就已经创建好，并且代理类和被代理类的关系在编译时确定，不能动态改变。</li></ol><p>特点：<br>代理类和被代理类在编译期间确定。<br>需要为每一个被代理类编写一个对应的代理类。<br>编译时就已确定代理关系，不灵活。</p><ol start="2"><li>动态代理：<br>动态代理是在运行时创建的代理对象，代理类在程序运行时动态生成，而不是在编译期间确定。Java 中的动态代理主要是通过 java.lang.reflect.Proxy 类来实现。</li></ol><p>特点：<br>代理类是在运行时动态生成的。<br>不需要为每一个被代理类编写一个对应的代理类，可以通过反射机制动态处理。<br>在运行时可以动态改变代理关系，更加灵活。</p><p>应用场景：</p><ul><li>静态代理： 适用于被代理类较少且不需要频繁变更代理关系的情况，比如安全检查、日志记录等。</li><li>动态代理： 适用于被代理类较多或者代理关系需要经常变更的情况，比如 AOP（面向切面编程）、RPC（远程过程调用）等。</li></ul><p>总的来说，动态代理相对于静态代理更加灵活，因为它允许在运行时动态生成代理对象，而无需在编译时确定。这使得动态代理在一些需要动态管理和调整代理关系的场景下更为实用。</p><h2 id="面向切面编程的AOP-Aspect-Oriented-Programming"><a href="#面向切面编程的AOP-Aspect-Oriented-Programming" class="headerlink" title="面向切面编程的AOP(Aspect Oriented Programming)"></a>面向切面编程的AOP(Aspect Oriented Programming)</h2><ul><li>AOP底层使用的是动态代理实现</li><li>Spring的AOP使用的动态代理是：JDK动态代理 + CGLIB动态代理技术。Spring在这两种动态代理中灵活切换，如果是代理接口，会默认使用JDK动态代理，如果要代理某个类，这个类没有实现接口，就会切换使用CGLIB</li></ul><h3 id="AOP介绍"><a href="#AOP介绍" class="headerlink" title="AOP介绍"></a>AOP介绍</h3><p>一般一个系统当中都会有一些系统服务，例如：日志、事务管理、安全等。这些系统服务被称为：交叉业务</p><p>如果在每一个业务处理过程当中，都掺杂这些交叉业务代码进去的话，存在两方面问题：</p><ul><li><p>第一：交叉业务代码在多个业务流程中反复出现，显然这个交叉业务代码没有得到复用。并且修改这些交叉业务代码的话，需要修改多处。</p></li><li><p>第二：程序员无法专注核心业务代码的编写，在编写核心业务代码的同时还需要处理这些交叉业务。</p></li><li><p>用一句话总结AOP：将与核心业务无关的代码独立的抽取出来，形成一个独立的组件，然后以横向交叉的方式应用到业务流程当中的过程被称为AOP。</p></li></ul><p>AOP的优点:</p><ul><li>第一：代码复用性增强。</li><li>第二：代码易维护。</li><li>第三：使开发者更关注业务逻辑。</li></ul><h3 id="AOP七大术语"><a href="#AOP七大术语" class="headerlink" title="AOP七大术语"></a>AOP七大术语</h3><ul><li><p><input disabled="" type="checkbox"> 切面：程序中和业务逻辑没有关系的通用代码(交叉业务)</p><ul><li><p><input disabled="" type="checkbox"> 连接点 Joinpoint</p><blockquote><blockquote><ul><li><input disabled="" type="checkbox"> 在程序的整个执行流程中，可以织入切面的位置。方法的执行前后，异常抛出之后等位置。</li></ul></blockquote></blockquote></li><li><p><input disabled="" type="checkbox"> 切点 Pointcut</p><blockquote><blockquote><ul><li><input disabled="" type="checkbox"> 在程序执行流程中，真正织入切面的方法。（一个切点对应多个连接点）</li></ul></blockquote></blockquote></li><li><p><input disabled="" type="checkbox"> 通知 Advice</p><blockquote><blockquote><ul><li><input disabled="" type="checkbox"> 通知又叫增强，就是具体你要织入的代码。</li></ul></blockquote></blockquote></li><li><p><input disabled="" type="checkbox"> 切面Aspect</p><blockquote><blockquote><ul><li><input disabled="" type="checkbox"> 切点 + 通知就是切面。</li></ul></blockquote></blockquote></li><li><p><input disabled="" type="checkbox"> 织入 Weaving</p><blockquote><blockquote><ul><li><input disabled="" type="checkbox"> 把通知应用到目标对象上的过程。</li></ul></blockquote></blockquote></li><li><p><input disabled="" type="checkbox"> 代理对象 Proxy</p><blockquote><blockquote><ul><li><input disabled="" type="checkbox"> 一个目标对象被织入通知后产生的新对象。</li></ul></blockquote></blockquote></li><li><p><input disabled="" type="checkbox"> 目标对象 Target</p><blockquote><blockquote><ul><li><input disabled="" type="checkbox"> 被织入通知的对象。</li></ul></blockquote></blockquote></li></ul></li></ul><p> 切点表达式</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">execution([访问控制权限修饰符] 返回值类型 [全限定类名]方法名(形式参数列表) [异常])</span><br></pre></td></tr></table></figure><h3 id="使用Spring的AOP"><a href="#使用Spring的AOP" class="headerlink" title="使用Spring的AOP"></a>使用Spring的AOP</h3><h4 id="切面的先后顺序"><a href="#切面的先后顺序" class="headerlink" title="切面的先后顺序"></a>切面的先后顺序</h4><ul><li><input disabled="" type="checkbox"> 可以使用@Order注解来标识切面类，为@Order注解的value指定一个整数型的数字，数字越小，优先级越高。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Order(1)</span> <span class="comment">//设置优先级</span></span><br></pre></td></tr></table></figure><h4 id="通用切点"><a href="#通用切点" class="headerlink" title="通用切点"></a>通用切点</h4><ul><li>将切点表达式单独的定义出来，在需要的位置引入即可</li></ul><h4 id="连接点-Joinpoint"><a href="#连接点-Joinpoint" class="headerlink" title="连接点(Joinpoint)"></a>连接点(Joinpoint)</h4><ul><li><input disabled="" type="checkbox"> getSignature 获取目标方法的签名</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> 开始一直到&#123;&#125;之前</span><br></pre></td></tr></table></figure><h4 id="全注解开发AOP"><a href="#全注解开发AOP" class="headerlink" title="全注解开发AOP"></a>全注解开发AOP</h4><ul><li><input disabled="" type="checkbox"> 编写一个类来代替spring配置文件</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.powernode.spring6.service;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.ComponentScan;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.EnableAspectJAutoProxy;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ComponentScan(&quot;com.powernode.spring6.service&quot;)</span></span><br><span class="line"><span class="meta">@EnableAspectJAutoProxy(proxyTargetClass = true)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Spring6Configuration</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><input disabled="" type="checkbox"> 因为xml文件没了 所以生成对象的时候也要有所变化</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testAOPWithAllAnnotation</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">ApplicationContext</span> <span class="variable">applicationContext</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AnnotationConfigApplicationContext</span>(Spring6Configuration.class);</span><br><span class="line">    <span class="type">OrderService</span> <span class="variable">orderService</span> <span class="operator">=</span> applicationContext.getBean(<span class="string">&quot;orderService&quot;</span>, OrderService.class);</span><br><span class="line">    orderService.generate();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="spring-对事务的支持"><a href="#spring-对事务的支持" class="headerlink" title="spring 对事务的支持"></a>spring 对事务的支持</h2><h3 id="事务概述"><a href="#事务概述" class="headerlink" title="事务概述"></a>事务概述</h3><ul><li>什么是事务<ul><li>在一个业务流程当中，通常需要多条DML（insert delete update）语句共同联合才能完成，这多条DML语句必须同时成功，或者同时失败，这样才能保证数据的安全。</li><li>多条DML要么同时成功，要么同时失败，这叫做事务。</li><li>事务：Transaction（tx）</li></ul></li><li>事务的四个处理过程：<ul><li>第一步：开启事务 (start transaction)</li><li>第二步：执行核心业务代码</li><li>第三步：提交事务（如果核心业务处理过程中没有出现异常）(commit transaction)</li><li>第四步：回滚事务（如果核心业务处理过程中出现异常）(rollback transaction)</li></ul></li><li>事务的四个特性：<ul><li>A 原子性：事务是最小的工作单元，不可再分。</li><li>C 一致性：事务要求要么同时成功，要么同时失败。事务前和事务后的总量不变。</li><li>I 隔离性：事务和事务之间因为有隔离性，才可以保证互不干扰。</li><li>D 持久性：持久性是事务结束的标志。</li></ul></li></ul><h3 id="事务的传播行为"><a href="#事务的传播行为" class="headerlink" title="事务的传播行为"></a>事务的传播行为</h3><ul><li><input disabled="" type="checkbox"> 在service类中有a()方法和b()方法，a()方法上有事务，b()方法上也有事务，当a()方法执行过程中调用了b()方法，事务是如何传递的？合并到一个事务里？还是开启一个新的事务？这就是事务传播行为。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Transactional(propagation = Propagation.REQUIRED)</span></span><br></pre></td></tr></table></figure><p>一共有七种传播行为：</p><ul><li>REQUIRED：支持当前事务，如果不存在就新建一个(默认)【没有就新建，有就加入】</li><li>SUPPORTS：支持当前事务，如果当前没有事务，就以非事务方式执行【有就加入，没有就不管了】</li><li>MANDATORY：必须运行在一个事务中，如果当前没有事务正在发生，将抛出一个异常【有就加入，没有就抛异常】</li><li>REQUIRES_NEW：开启一个新的事务，如果一个事务已经存在，则将这个存在的事务挂起【不管有没有，直接开启一个新事务，开启的新事务和之前的事务不存在嵌套关系，之前事务被挂起】</li><li>NOT_SUPPORTED：以非事务方式运行，如果有事务存在，挂起当前事务【不支持事务，存在就挂起】</li><li>NEVER：以非事务方式运行，如果有事务存在，抛出异常【不支持事务，存在就抛异常】</li><li>NESTED：如果当前正有一个事务在进行中，则该方法应当运行在一个嵌套式事务中。被嵌套的事务可以独立于外层事务进行提交或回滚。如果外层事务不存在，行为就像REQUIRED一样。【有事务的话，就在这个事务里再嵌套一个完全独立的事务，嵌套的事务可以独立的提交和回滚。没有事务就和REQUIRED一样。】</li></ul><h3 id="事物的隔离级别"><a href="#事物的隔离级别" class="headerlink" title="事物的隔离级别"></a>事物的隔离级别</h3><ul><li>脏读：读取到没有提交到数据库的数据(缓存中的数据)，叫做脏读。</li><li>不可重复读：在同一个事务当中，第一次和第二次读取的数据不一样。</li><li>幻读：读到的数据是假的。多事务并发一定会产生幻读问题。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Transactional(isolation = Isolation.READ_COMMITTED)</span></span><br></pre></td></tr></table></figure><blockquote><blockquote><ul><li><input disabled="" type="checkbox"> 其中可以设置的隔离级别有以下四种</li></ul></blockquote></blockquote><ul><li>Default</li><li>read_uncommitted</li><li>READ_COMMITTED</li><li>repeatable_read</li><li>serializable</li></ul><h3 id="事物超时"><a href="#事物超时" class="headerlink" title="事物超时"></a>事物超时</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Transactional(timeout = 10)</span></span><br></pre></td></tr></table></figure><ul><li>以上代码表示设置事务的超时时间为10秒。</li><li>表示超过10秒如果该事务中所有的DML语句还没有执行完毕的话，最终结果会选择回滚。</li><li>默认值-1，表示没有时间限制。</li><li>这里有个坑，事务的超时时间指的是哪段时间？:在当前事务当中，最后一条DML语句执行<code>之前</code>的时间。如果最后一条DML语句后面很有很多业务逻辑，这些业务代码执行的时间不被计入超时时间。</li></ul><h3 id="只读事务"><a href="#只读事务" class="headerlink" title="只读事务"></a>只读事务</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Transactional(readOnly = true)</span></span><br></pre></td></tr></table></figure><ul><li>将当前事务设置为只读事务，在该事务执行过程中只允许select语句执行，delete insert update均不可执行。<br>该特性的作用是：启动spring的优化策略。提高select语句执行效率。<br>如果该事务中确实没有增删改操作，建议设置为只读事务。</li></ul><h3 id="设置哪些异常回滚事务"><a href="#设置哪些异常回滚事务" class="headerlink" title="设置哪些异常回滚事务"></a>设置哪些异常回滚事务</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Transactional(rollbackFor = RuntimeException.class)</span></span><br></pre></td></tr></table></figure><ul><li>表示只有发生RuntimeException异常或该异常的子类异常才回滚。</li></ul><h3 id="设置哪些异常不回滚事务"><a href="#设置哪些异常不回滚事务" class="headerlink" title="设置哪些异常不回滚事务"></a>设置哪些异常不回滚事务</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Transactional(noRollbackFor = NullPointerException.class)</span></span><br></pre></td></tr></table></figure><p>表示发生NullPointerException或该异常的子类异常不回滚，其他异常则回滚。</p><h3 id="事务的全注解开发"><a href="#事务的全注解开发" class="headerlink" title="事务的全注解开发"></a>事务的全注解开发</h3><p>编写一个类来代替配置文件</p><h2 id="Spring6整合JUnit5"><a href="#Spring6整合JUnit5" class="headerlink" title="Spring6整合JUnit5"></a>Spring6整合JUnit5</h2><h3 id="Spring对JUnit4的支持"><a href="#Spring对JUnit4的支持" class="headerlink" title="Spring对JUnit4的支持"></a>Spring对JUnit4的支持</h3><p>:wq<br>Spring提供的方便主要是这几个注解：</p><ul><li><p>@RunWith(SpringJUnit4ClassRunner.class)</p></li><li><p>@ContextConfiguration(“classpath:spring.xml”)</p></li><li><p>在单元测试类上使用这两个注解之后，在单元测试类中的属性上可以使用@Autowired。比较方便。</p></li></ul><h3 id="Spring对JUnit5的支持"><a href="#Spring对JUnit5的支持" class="headerlink" title="Spring对JUnit5的支持"></a>Spring对JUnit5的支持</h3><p>在JUnit5当中，可以使用Spring提供的以下两个注解，标注到单元测试类上，这样在类当中就可以使用@Autowired注解了。</p><ul><li>@ExtendWith(SpringExtension.class)</li><li>@ContextConfiguration(“classpath:spring.xml”)</li></ul><h2 id="Spring6集成MyBatis3-5"><a href="#Spring6集成MyBatis3-5" class="headerlink" title="Spring6集成MyBatis3.5"></a>Spring6集成MyBatis3.5</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">AccountMapper</span> &#123;</span><br><span class="line">    <span class="comment">// 接口定义的方法</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Repository</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AccountMapperImpl</span> <span class="keyword">implements</span> <span class="title class_">AccountMapper</span> &#123;</span><br><span class="line">    <span class="comment">// 实现接口定义的方法</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AccountService</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> AccountMapper accountMapper;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 类的其余部分</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li><input disabled="" type="checkbox"> 在这个例子中，AccountMapper 是一个接口，AccountMapperImpl 是实现了这个接口的类。在 AccountService 类中，通过 @Autowired 注解将 accountMapper 字段注入为 AccountMapper 接口的实现类的一个实例。</li></ul><h2 id="spring中的八大模式"><a href="#spring中的八大模式" class="headerlink" title="spring中的八大模式"></a>spring中的八大模式</h2><h3 id="简单工厂模式-1"><a href="#简单工厂模式-1" class="headerlink" title="简单工厂模式"></a>简单工厂模式</h3><p>BeanFactory的getBean()方法，通过唯一标识来获取Bean对象。是典型的简单工厂模式（静态工厂模式）；</p><h3 id="工厂方法模式"><a href="#工厂方法模式" class="headerlink" title="工厂方法模式"></a>工厂方法模式</h3><p>FactoryBean是典型的工厂方法模式。在配置文件中通过factory-method属性来指定工厂方法，该方法是一个实例方法。</p><h3 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h3><p>Spring用的是双重判断加锁的单例模式。</p><h3 id="代理模式"><a href="#代理模式" class="headerlink" title="代理模式"></a>代理模式</h3><p>Spring的AOP就是使用了动态代理实现的。</p><h3 id="装饰器模式"><a href="#装饰器模式" class="headerlink" title="装饰器模式"></a>装饰器模式</h3><p>JavaSE中的IO流是非常典型的装饰器模式。</p><p>Spring 中配置 DataSource 的时候，这些dataSource可能是各种不同类型的，比如不同的数据库：Oracle、SQL Server、MySQL等，也可能是不同的数据源：比如apache 提供的org.apache.commons.dbcp.BasicDataSource、spring提供的org.springframework.jndi.JndiObjectFactoryBean等。</p><p>这时，能否在尽可能少修改原有类代码下的情况下，做到动态切换不同的数据源？此时就可以用到装饰者模式。</p><p>Spring根据每次请求的不同，将dataSource属性设置成不同的数据源，以到达切换数据源的目的。</p><p><strong>Spring中类名中带有：Decorator和Wrapper单词的类，都是装饰器模式。</strong></p><h3 id="观察者模式"><a href="#观察者模式" class="headerlink" title="观察者模式"></a>观察者模式</h3><p>定义对象间的一对多的关系，当一个对象的状态发生改变时，所有依赖于它的对象都得到通知并自动更新。Spring中观察者模式一般用在listener的实现</p><h3 id="策略模式"><a href="#策略模式" class="headerlink" title="策略模式"></a>策略模式</h3><p>策略模式是行为性模式，调用不同的方法，适应行为的变化 ，强调父类的调用子类的特性 。</p><p>getHandler是HandlerMapping接口中的唯一方法，用于根据请求找到匹配的处理器。</p><p>比如我们自己写了AccountDao接口，然后这个接口下有不同的实现类：AccountDaoForMySQL，AccountDaoForOracle。对于service来说不需要关心底层具体的实现，只需要面向AccountDao接口调用，底层可以灵活切换实现，这就是策略模式。</p><h3 id="模板方法模式"><a href="#模板方法模式" class="headerlink" title="模板方法模式"></a>模板方法模式</h3><p>Spring中的JdbcTemplate类就是一个模板类。它就是一个模板方法设计模式的体现。在模板类的模板方法execute中编写核心算法，具体的实现步骤在子类中完成。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;[!TIP]&lt;br&gt;基于动力节点spring6总结&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;Spring启示录&quot;&gt;&lt;a href=&quot;#Spring启示录&quot; class=&quot;headerlink&quot; title=&quot;Spring启示录&quot;&gt;&lt;/a</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>测试开发学习路线</title>
    <link href="http://www.meprotoss.com/undefined/d3855f56.html"/>
    <id>http://www.meprotoss.com/undefined/d3855f56.html</id>
    <published>2024-05-06T08:34:53.000Z</published>
    <updated>2024-05-07T16:04:08.277Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、编程语言入门"><a href="#一、编程语言入门" class="headerlink" title="一、编程语言入门"></a>一、编程语言入门</h2><ul><li><input checked="" disabled="" type="checkbox"> java</li></ul><h2 id="二、基础"><a href="#二、基础" class="headerlink" title="二、基础"></a>二、基础</h2><h3 id="计算机基础"><a href="#计算机基础" class="headerlink" title="计算机基础"></a>计算机基础</h3><ul><li><input disabled="" type="checkbox"> 数据结构与算法</li><li><input disabled="" type="checkbox"> 计算机网络</li><li><input disabled="" type="checkbox"> linux</li><li><input disabled="" type="checkbox"> mysql 重点是sql语句的编写</li></ul><h3 id="测试基础"><a href="#测试基础" class="headerlink" title="测试基础"></a>测试基础</h3><ul><li><input disabled="" type="checkbox"> 测试工具</li><li><input disabled="" type="checkbox"> 功能测试基础</li></ul><h2 id="三、进阶"><a href="#三、进阶" class="headerlink" title="三、进阶"></a>三、进阶</h2><h3 id="开发"><a href="#开发" class="headerlink" title="开发"></a>开发</h3><ul><li><input disabled="" type="checkbox"> 后端web开发</li><li><input disabled="" type="checkbox"> 自动化测试</li></ul><h2 id="项目实战"><a href="#项目实战" class="headerlink" title="项目实战"></a>项目实战</h2><ul><li><input disabled="" type="checkbox"> 开发项目实战</li></ul><blockquote><p>[!TIP]<br>应届校招以准备开发项目实战为佳,而不是测试项目</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;一、编程语言入门&quot;&gt;&lt;a href=&quot;#一、编程语言入门&quot; class=&quot;headerlink&quot; title=&quot;一、编程语言入门&quot;&gt;&lt;/a&gt;一、编程语言入门&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;input checked=&quot;&quot; disabled=&quot;&quot; type=&quot;chec</summary>
      
    
    
    
    
  </entry>
  
</feed>
