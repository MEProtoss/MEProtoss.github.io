<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>CHEN先生的小站</title>
  
  <subtitle>忽有故人心上过</subtitle>
  <link href="http://www.meprotoss.com/atom.xml" rel="self"/>
  
  <link href="http://www.meprotoss.com/"/>
  <updated>2024-05-13T08:13:36.668Z</updated>
  <id>http://www.meprotoss.com/</id>
  
  <author>
    <name>Mr.Chen</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>MySql</title>
    <link href="http://www.meprotoss.com/undefined/6cac71de.html"/>
    <id>http://www.meprotoss.com/undefined/6cac71de.html</id>
    <published>2024-05-10T13:52:23.000Z</published>
    <updated>2024-05-13T08:13:36.668Z</updated>
    
    <content type="html"><![CDATA[<h2 id="单表查询"><a href="#单表查询" class="headerlink" title="单表查询"></a>单表查询</h2><h3 id="1757可回收且低脂的产品"><a href="#1757可回收且低脂的产品" class="headerlink" title="1757可回收且低脂的产品"></a>1757可回收且低脂的产品</h3><ul><li>注意要返回的是什么那么就去select什么</li></ul><h3 id="584寻找用户推荐人"><a href="#584寻找用户推荐人" class="headerlink" title="584寻找用户推荐人"></a>584寻找用户推荐人</h3><ul><li><p>MySQL是三值逻辑，分别为TRUE、FALSE和UNKNOWN，逻辑判断是如果逻辑运算符一端为NULL，则为UNKNOWN； 这段代码 referee_id &#x3D;2 为TRUE，则NOT TURE为FALSE和UNKNOWN，即&lt;&gt;2 OR 为NULL</p></li><li><p>null不可以和数值类直接比较，其结果为unkonwn</p></li><li><p>⭐️IFNULL(referee_id, 0) &lt;&gt; 2:意思是如果 referee_id 列的值为 NULL，则将其替换为 0，然后与 2 进行比较。如果 referee_id 列的值不等于 2，那么这一行将被包含在结果中</p></li></ul><h3 id="1148文章浏览-1"><a href="#1148文章浏览-1" class="headerlink" title="1148文章浏览 1"></a>1148文章浏览 1</h3><ul><li>我们可以在 SELECT 语句中使用 DISTINCT 关键字来从表 Views 中检索唯一元素</li><li>select 可以给列取别名</li></ul><h3 id="1683-无效的推文"><a href="#1683-无效的推文" class="headerlink" title="1683.无效的推文"></a>1683.无效的推文</h3><ul><li>获取某列字符长度的函数： CHAR_LENGTH ()</li></ul><h2 id="多表查询"><a href="#多表查询" class="headerlink" title="多表查询"></a>多表查询</h2><p>多表之间的业务关系主要有以下三种：</p><ol><li>一对多(部门与部门员工的关系):多的一方建立外键，指向一的一方的主键</li><li>多对多(学生与课程的关系):建立第三张中间表,中间表至少包含两个外键,分别关联两方主键</li><li>一对一(用户与用户详情的关系):在任意一方加入外键,关联另外一方的主键,并且设置外键为唯一的(UNIQUE)</li></ol><h3 id="多表查询分类"><a href="#多表查询分类" class="headerlink" title="多表查询分类"></a>多表查询分类</h3><h4 id="连接"><a href="#连接" class="headerlink" title="连接"></a>连接</h4><h5 id="内连接"><a href="#内连接" class="headerlink" title="内连接"></a>内连接</h5><p>查询两个表之间的交集</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">1). 隐式内连接</span><br><span class="line">SELECT</span><br><span class="line">字段列表</span><br><span class="line">FROM</span><br><span class="line">表1 , 表2</span><br><span class="line">WHERE</span><br><span class="line">条件 ... ;</span><br></pre></td></tr></table></figure><p>2). 显式内连接</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">SELECT</span><br><span class="line">字段列表</span><br><span class="line">FROM</span><br><span class="line">表1</span><br><span class="line">[ INNER ]</span><br><span class="line">JOIN 表2</span><br><span class="line">ON</span><br><span class="line">连接条件 ... ;</span><br></pre></td></tr></table></figure><h5 id="外连接"><a href="#外连接" class="headerlink" title="外连接"></a>外连接</h5><p>外连接将两个表按照匹配条件合成一张表</p><ul><li>左外连接：查询左表所有数据,以及两张表交集部分数据   <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">   表1</span><br><span class="line">LEFT</span><br><span class="line">[ OUTER ]</span><br><span class="line">JOIN 表2</span><br><span class="line">ON</span><br><span class="line">条件 ... ;</span><br></pre></td></tr></table></figure></li><li>右外连接：查询右表所有数据,以及两张表交集部分数据<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"> 表1</span><br><span class="line">RIGHT</span><br><span class="line">[ OUTER ]</span><br><span class="line">JOIN 表2</span><br><span class="line">ON</span><br><span class="line">条件 ... ;</span><br></pre></td></tr></table></figure></li></ul><h5 id="自连接"><a href="#自连接" class="headerlink" title="自连接"></a>自连接</h5><p>当前表与自身的连接查询,自连接必须使用表别名</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"> 表A</span><br><span class="line">别名A</span><br><span class="line">JOIN</span><br><span class="line">表A</span><br><span class="line">别名B</span><br><span class="line">ON</span><br><span class="line">条件 ... ;</span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><p>[!TIP]<br>在自连接查询中,必须要为表起别名,要不然我们不清楚所指定的条件、返回的字段,到底<br>是哪一张表的字段。</p></blockquote><h5 id="联合查询"><a href="#联合查询" class="headerlink" title="联合查询"></a>联合查询</h5><h4 id="子查询"><a href="#子查询" class="headerlink" title="子查询"></a>子查询</h4><p>指嵌套在主查询中的一个查询</p><h3 id="1378-使用唯一标识码替换员工ID"><a href="#1378-使用唯一标识码替换员工ID" class="headerlink" title="1378.使用唯一标识码替换员工ID"></a>1378.使用唯一标识码替换员工ID</h3><p>使用outer join会保留主表的全部，以及次表与主表能匹配的记录，没有匹配时返回null</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">表1 left join 表2 on 连接条件</span><br></pre></td></tr></table></figure><p>左外连接表示保留表1的所有数据，表2中没有的记录返回null</p><h3 id="产品销售分析"><a href="#产品销售分析" class="headerlink" title="产品销售分析"></a>产品销售分析</h3><h3 id=""><a href="#" class="headerlink" title=""></a></h3>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;单表查询&quot;&gt;&lt;a href=&quot;#单表查询&quot; class=&quot;headerlink&quot; title=&quot;单表查询&quot;&gt;&lt;/a&gt;单表查询&lt;/h2&gt;&lt;h3 id=&quot;1757可回收且低脂的产品&quot;&gt;&lt;a href=&quot;#1757可回收且低脂的产品&quot; class=&quot;headerlink</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>算法</title>
    <link href="http://www.meprotoss.com/undefined/b7e144d1.html"/>
    <id>http://www.meprotoss.com/undefined/b7e144d1.html</id>
    <published>2024-05-10T13:37:57.000Z</published>
    <updated>2024-05-13T08:32:49.252Z</updated>
    
    <content type="html"><![CDATA[<h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><ul><li>数组的元素在内存地址中是连续的，不能单独删除数组中的某个元素，只能覆盖。</li></ul><h3 id="leetcode27原地移除数组中的元素"><a href="#leetcode27原地移除数组中的元素" class="headerlink" title="leetcode27原地移除数组中的元素"></a>leetcode27原地移除数组中的元素</h3><p>双指针思路:</p><ul><li>快指针用于寻找”新“数组中的元素</li><li>慢指针是新数组的下标值</li><li>快指针遍历数组，当遇见不为val的数值（即新数组中的元素）则赋值给nums[slow]，遍历完就可得到新数组</li></ul><p>暴力解法要注意考虑边界条件不要角标越界</p><h3 id="977-有序数组的平方"><a href="#977-有序数组的平方" class="headerlink" title="977 有序数组的平方"></a>977 有序数组的平方</h3><ul><li>双指针秒了</li></ul><h3 id="209-长度最小的子数组"><a href="#209-长度最小的子数组" class="headerlink" title="209 长度最小的子数组"></a>209 长度最小的子数组</h3><ul><li>暴力解法显而易见</li><li>滑动窗口:</li></ul><p>所谓滑动窗口，就是不断的调节子序列的起始位置和终止位置，从而得出我们要想的结果。</p><p>滑动窗口也可以理解为双指针法的一种！只不过这种解法更像是一个窗口的移动，所以叫做滑动窗口更适合一些。</p><p>在本题中实现滑动窗口，主要确定如下三点：</p><ul><li>窗口内是什么？</li><li>如何移动窗口的起始位置？</li><li>如何移动窗口的结束位置？</li></ul><p>窗口就是 满足其和 ≥ s 的长度最小的 连续 子数组。</p><p>窗口的起始位置如何移动：如果当前窗口的值大于等于s了，窗口就要向前移动了（也就是该缩小了,此时移动左边界）。</p><p>窗口的结束位置如何移动：窗口的结束位置就是遍历数组的右指针，也就是for循环里的索引。</p><h3 id="54螺旋矩阵"><a href="#54螺旋矩阵" class="headerlink" title="54螺旋矩阵"></a>54螺旋矩阵</h3><p>我们要坚持循环不变量原则，首先模拟顺时针画矩阵的过程</p><ul><li>填充上行从左到右</li><li>填充右列从上到下</li><li>填充下行从右到左</li><li>填充左列从下到上</li></ul><p>这里一圈下来，我们要画每四条边，这四条边怎么画，<strong>每画一条边都要坚持一致的左闭右开，或者左开右闭的原则</strong>，这样这一圈才能按照统一的规则画下来。</p><h2 id="哈希表理论基础和总结"><a href="#哈希表理论基础和总结" class="headerlink" title="哈希表理论基础和总结"></a>哈希表理论基础和总结</h2><ul><li><p>需要 <strong>判断一个元素是否出现过</strong> 或者<strong>一个元素出现的频次</strong>场景应该第一时间想到哈希法。</p></li><li><p>使用哈希表的时候注意数据结构的选择</p><ul><li>数组 : 适用于元素不是太大的情况,将数据转换成哈希数组的效率较高，建议优先使用。</li><li>set :转变成set需要进行hash运算，效率较低。</li><li>map :要存放两个元素（数值和频率）（key和value）</li></ul></li><li><p>解题思路</p><ul><li>先想到用哈希表</li><li>考虑用什么存储结构</li></ul></li></ul><h3 id="有效的字母异位词"><a href="#有效的字母异位词" class="headerlink" title="有效的字母异位词"></a>有效的字母异位词</h3><ul><li>字母运算时会自动取 ASCII 码。</li></ul><h3 id="数组交集"><a href="#数组交集" class="headerlink" title="数组交集"></a>数组交集</h3><ul><li>Java 基础回顾</li></ul><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">在Java中，List是一个接口，它代表了一个有序的集合，允许重复的元素。List接口继承自Collection接口，它是集合框架中的一部分，用于存储一组元素，并且可以对这些元素进行访问、添加、删除和修改等操作。</span><br><span class="line"></span><br><span class="line">Java中常用的List实现类包括：</span><br><span class="line"></span><br><span class="line">ArrayList：基于数组实现的动态数组，支持随机访问，但在插入和删除操作时可能会涉及元素的移动。大小可以动态增长。</span><br><span class="line">LinkedList：基于链表实现的双向链表，插入和删除操作性能较好，但随机访问效率较低。</span><br><span class="line">Vector：与ArrayList类似，但是它是线程安全的，因此在多线程环境下使用较为安全，但性能相对较低。</span><br><span class="line">List接口定义了一系列方法，包括但不限于：</span><br><span class="line"></span><br><span class="line">int size()：返回列表中的元素数量。</span><br><span class="line">boolean isEmpty()：检查列表是否为空。</span><br><span class="line">boolean contains(Object o)：检查列表是否包含指定的元素。</span><br><span class="line">boolean add(E e)：将指定的元素添加到列表的末尾。</span><br><span class="line">void add(int index, E element)：将指定的元素插入到列表的指定位置。</span><br><span class="line">E remove(int index)：移除列表中指定位置的元素。</span><br><span class="line">void clear()：清空列表中的所有元素。</span><br><span class="line">E get(int index)：返回列表中指定位置的元素。</span><br><span class="line">E set(int index, E element)：将列表中指定位置的元素替换为指定的元素。</span><br></pre></td></tr></table></figure><h3 id="两数之和"><a href="#两数之和" class="headerlink" title="两数之和"></a>两数之和</h3><ul><li><p>思路：一边遍历，一边将其存入哈希表，在遍历时判断我们要找的元素之前是否出现过。</p></li><li><p>我们既要知道元素的值，还要知道元素的下标</p></li><li><p>注意：map是要存放 <strong>遍历过</strong> 的元素</p></li></ul><h3 id="四数相加"><a href="#四数相加" class="headerlink" title="四数相加"></a>四数相加</h3><ul><li>思路：前两个数组遍历相加，把所有的和存到一个数组A里，同时要记录出现的次数；后两个数组遍历相加，把所有的和存在一个数组B里,同时要记录出现的次数；遍历A看看想要的数在B中是否存在</li><li>因为既要知道数，还要统计次数，所以使用map（键值对）作为hash表的存储结构，此时key是值，value是出现的次数</li><li>注意：两两分组的复杂度是n^2, 一三分组是n^3。</li><li>每次配对成功后，count计数应该是加value里的值</li></ul><h3 id="三数相加"><a href="#三数相加" class="headerlink" title="三数相加"></a>三数相加</h3><ul><li>先排序</li><li>去重逻辑（有了再考虑去重，而不是还没有用就去考虑去重）</li><li>双指针解  i left right</li></ul><h3 id="四数之和"><a href="#四数之和" class="headerlink" title="四数之和"></a>四数之和</h3><ul><li>思路类似三数之和 i j left right</li><li>注意剪枝操作和去重操作</li></ul><h2 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h2><h3 id="反转字符串"><a href="#反转字符串" class="headerlink" title="反转字符串"></a>反转字符串</h3><p>难点就在如何去除多余的空格：这其实就是删除元素的算法，需要使用<strong>快慢指针</strong>的方法: 快指针寻找符合要求的字母（要收集的字母）、慢指针就是来表示要更新在哪里</p><p>题目要求：</p><ul><li>输入: “the sky is blue”</li><li>输出: “blue is sky the”</li><li>输入字符串可以在前面或者后面包含多余的空格，但是反转后的字符不能包括。</li><li>如果两个单词间有多余的空格，将反转后单词间的空格减少到只含一个。</li></ul><p>解题思路：</p><ul><li>将整个字符串都反转过来，那么单词的顺序指定是倒序了，只不过单词本身也倒序了，那么再把单词反转一下，单词不就正过来了。</li></ul><p>所以解题思路如下：</p><ul><li>移除多余空格</li><li>将整个字符串反转</li><li>将每个单词反转</li></ul><h3 id="KMP算法"><a href="#KMP算法" class="headerlink" title="KMP算法"></a>KMP算法</h3><ul><li>用以解决字符串匹配的问题</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;数组&quot;&gt;&lt;a href=&quot;#数组&quot; class=&quot;headerlink&quot; title=&quot;数组&quot;&gt;&lt;/a&gt;数组&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;数组的元素在内存地址中是连续的，不能单独删除数组中的某个元素，只能覆盖。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;leetcode</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Docker笔记</title>
    <link href="http://www.meprotoss.com/undefined/5c266b64.html"/>
    <id>http://www.meprotoss.com/undefined/5c266b64.html</id>
    <published>2024-05-10T03:33:55.000Z</published>
    <updated>2024-05-10T03:34:28.833Z</updated>
    
    <content type="html"><![CDATA[<h2 id="docker-是什么？"><a href="#docker-是什么？" class="headerlink" title="docker 是什么？"></a>docker 是什么？</h2><ul><li>docker 独立的容器（container），可以跨系统的运行打包好的程序</li></ul><h2 id="docker-常见命令"><a href="#docker-常见命令" class="headerlink" title="docker 常见命令"></a>docker 常见命令</h2><p><a href="https://b11et3un53m.feishu.cn/docx/Wq51d3o2koFiptxqby9cHTNznpd?openbrd=1&doc_app_id=501&blockId=FSOjd6yPIoTyvjxJFqBclOignxh&blockType=whiteboard&blockToken=RoUSwA3I5hXhLib69YScieXXnBb#FSOjd6yPIoTyvjxJFqBclOignxh">docker命令图解</a></p><h2 id="使用docker的demo"><a href="#使用docker的demo" class="headerlink" title="使用docker的demo"></a>使用docker的demo</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">从dockerhub镜像仓库拉取镜像（image）</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">第1步，去DockerHub查看nginx镜像仓库及相关信息</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">第2步，拉取Nginx镜像</span></span><br><span class="line">docker pull nginx</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">第3步，查看镜像</span></span><br><span class="line">docker images</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">结果如下：</span></span><br><span class="line">REPOSITORY   TAG       IMAGE ID       CREATED         SIZE</span><br><span class="line">nginx        latest    605c77e624dd   16 months ago   141MB</span><br><span class="line">mysql        latest    3218b38490ce   17 months ago   516MB</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">第4步，创建并运行Nginx容器</span></span><br><span class="line">docker run -d --name nginx -p 80:80 nginx</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">第5步，查看运行中容器</span></span><br><span class="line">docker ps</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">也可以加格式化方式访问，格式会更加清爽</span></span><br><span class="line">docker ps --format &quot;table &#123;&#123;.ID&#125;&#125;\t&#123;&#123;.Image&#125;&#125;\t&#123;&#123;.Ports&#125;&#125;\t&#123;&#123;.Status&#125;&#125;\t&#123;&#123;.Names&#125;&#125;&quot;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">第6步，访问网页，地址：http://虚拟机地址</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">第7步，停止容器</span></span><br><span class="line">docker stop nginx</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">第8步，查看所有容器,将还指令<span class="built_in">alias</span> 为dps 格式化查看容器</span></span><br><span class="line">docker ps -a --format &quot;table &#123;&#123;.ID&#125;&#125;\t&#123;&#123;.Image&#125;&#125;\t&#123;&#123;.Ports&#125;&#125;\t&#123;&#123;.Status&#125;&#125;\t&#123;&#123;.Names&#125;&#125;&quot;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">第9步，再次启动nginx容器</span></span><br><span class="line">docker start nginx</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">第10步，再次查看容器</span></span><br><span class="line">docker ps --format &quot;table &#123;&#123;.ID&#125;&#125;\t&#123;&#123;.Image&#125;&#125;\t&#123;&#123;.Ports&#125;&#125;\t&#123;&#123;.Status&#125;&#125;\t&#123;&#123;.Names&#125;&#125;&quot;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">第11步，查看容器详细信息</span></span><br><span class="line">docker inspect nginx</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">第12步，进入容器,查看容器内目录</span></span><br><span class="line">docker exec -it nginx bash</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">或者，可以进入MySQL</span></span><br><span class="line">docker exec -it mysql mysql -uroot -p</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">第13步，删除容器</span></span><br><span class="line">docker rm nginx</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">发现无法删除，因为容器运行中，强制删除容器</span></span><br><span class="line">docker rm -f nginx</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="挂载宿主机目录和容器内目录"><a href="#挂载宿主机目录和容器内目录" class="headerlink" title="挂载宿主机目录和容器内目录"></a>挂载宿主机目录和容器内目录</h2><h3 id="方法1-通过数据卷间接挂载（较为繁琐-不常用）"><a href="#方法1-通过数据卷间接挂载（较为繁琐-不常用）" class="headerlink" title="方法1:通过数据卷间接挂载（较为繁琐 不常用）"></a>方法1:通过数据卷间接挂载（较为繁琐 不常用）</h3><ul><li>数据卷（volume）是一个虚拟目录，是容器内目录与宿主机目录之间映射的桥梁。</li><li>容器与数据卷的挂载要在创建容器时配置，对于创建好的容器，是不能设置数据卷的。而且创建容器的过程中，数据卷会自动创建。</li></ul><h4 id="demo"><a href="#demo" class="headerlink" title="demo"></a>demo</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">1.首先创建容器并指定数据卷，注意通过 -v 参数来指定数据卷</span></span><br><span class="line">docker run -d --name nginx -p 80:80 -v html:/usr/share/nginx/html nginx</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">2.然后查看数据卷</span></span><br><span class="line">docker volume ls</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">结果</span></span><br><span class="line">DRIVER    VOLUME NAME</span><br><span class="line">local     29524ff09715d3688eae3f99803a2796558dbd00ca584a25a4bbc193ca82459f</span><br><span class="line">local     html</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">3.查看数据卷详情</span></span><br><span class="line">docker volume inspect html</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">结果</span></span><br><span class="line">[</span><br><span class="line">&#123;</span><br><span class="line">  &quot;CreatedAt&quot;: &quot;2024-05-17T19:57:08+08:00&quot;,</span><br><span class="line">    &quot;Driver&quot;: &quot;local&quot;,</span><br><span class="line">    &quot;Labels&quot;: null,</span><br><span class="line">    &quot;Mountpoint&quot;: &quot;/var/lib/docker/volumes/html/_data&quot;,</span><br><span class="line">    &quot;Name&quot;: &quot;html&quot;,</span><br><span class="line">    &quot;Options&quot;: null,</span><br><span class="line">    &quot;Scope&quot;: &quot;local&quot;</span><br><span class="line">&#125;</span><br><span class="line">]</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">4.查看/var/lib/docker/volumes/html/_data目录</span></span><br><span class="line">ll /var/lib/docker/volumes/html/_data</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">可以看到与nginx的html目录内容一样，结果如下：</span></span><br><span class="line">总用量 8</span><br><span class="line">-rw-r--r--. 1 root root 497 12月 28 2021 50x.html</span><br><span class="line">-rw-r--r--. 1 root root 615 12月 28 2021 index.html</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">5.进入该目录，并随意修改index.html内容</span></span><br><span class="line">cd /var/lib/docker/volumes/html/_data</span><br><span class="line">vi index.html</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">6.打开页面，查看效果</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">7.进入容器内部，查看/usr/share/nginx/html目录内的文件是否变化</span></span><br><span class="line">docker exec -it nginx bash</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="法二：不通过数据卷直接挂载"><a href="#法二：不通过数据卷直接挂载" class="headerlink" title="法二：不通过数据卷直接挂载"></a>法二：不通过数据卷直接挂载</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">挂载本地目录</span></span><br><span class="line">-v 本地目录:容器内目录</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">挂载本地文件</span></span><br><span class="line">-v 本地文件:容器内文件</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="构建docker镜像"><a href="#构建docker镜像" class="headerlink" title="构建docker镜像"></a>构建docker镜像</h2><ol><li>编写<code>Dockerfile</code> 文件，其对应的语法可以参考官方文档：<a href="https://docs.docker.com/engine/reference/builder/">官方文档</a></li><li>构建镜像</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 进入镜像目录</span></span><br><span class="line"><span class="built_in">cd</span> /root/demo</span><br><span class="line"><span class="comment"># 开始构建</span></span><br><span class="line">docker build -t [镜像名称]:[TAG(不写默认为latest)] [Dockerfile所在目录]</span><br></pre></td></tr></table></figure><h2 id="Docker自定义网络"><a href="#Docker自定义网络" class="headerlink" title="Docker自定义网络"></a>Docker自定义网络</h2><p>自定义网络，在同一个网络中的容器可以互联</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 1.首先通过命令创建一个网络</span></span><br><span class="line">docker network create hmall</span><br><span class="line"></span><br><span class="line"><span class="comment"># 2.然后查看网络</span></span><br><span class="line">docker network <span class="built_in">ls</span></span><br><span class="line"><span class="comment"># 结果：</span></span><br><span class="line">NETWORK ID     NAME      DRIVER    SCOPE</span><br><span class="line">639bc44d0a87   bridge    bridge    <span class="built_in">local</span></span><br><span class="line">403f16ec62a2   hmall     bridge    <span class="built_in">local</span></span><br><span class="line">0dc0f72a0fbb   host      host      <span class="built_in">local</span></span><br><span class="line">cd8d3e8df47b   none      null      <span class="built_in">local</span></span><br><span class="line"><span class="comment"># 其中，除了hmall以外，其它都是默认的网络</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 3.让dd和mysql都加入该网络，注意，在加入网络时可以通过--alias给容器起别名</span></span><br><span class="line"><span class="comment"># 这样该网络内的其它容器可以用别名互相访问！</span></span><br><span class="line"><span class="comment"># 3.1.mysql容器，指定别名为db，另外每一个容器都有一个别名是容器名</span></span><br><span class="line">docker network connect hmall mysql --<span class="built_in">alias</span> db</span><br><span class="line"><span class="comment"># 3.2.db容器，也就是我们的java项目</span></span><br><span class="line">docker network connect hmall <span class="built_in">dd</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 4.进入dd容器，尝试利用别名访问db</span></span><br><span class="line"><span class="comment"># 4.1.进入容器</span></span><br><span class="line">docker <span class="built_in">exec</span> -it <span class="built_in">dd</span> bash</span><br><span class="line"><span class="comment"># 4.2.用db别名访问</span></span><br><span class="line">ping db</span><br><span class="line"><span class="comment"># 结果</span></span><br><span class="line">PING db (172.18.0.2) 56(84) bytes of data.</span><br><span class="line">64 bytes from mysql.hmall (172.18.0.2): icmp_seq=1 ttl=64 time=0.070 ms</span><br><span class="line">64 bytes from mysql.hmall (172.18.0.2): icmp_seq=2 ttl=64 time=0.056 ms</span><br><span class="line"><span class="comment"># 4.3.用容器名访问</span></span><br><span class="line">ping mysql</span><br><span class="line"><span class="comment"># 结果：</span></span><br><span class="line">PING mysql (172.18.0.2) 56(84) bytes of data.</span><br><span class="line">64 bytes from mysql.hmall (172.18.0.2): icmp_seq=1 ttl=64 time=0.044 ms</span><br><span class="line">64 bytes from mysql.hmall (172.18.0.2): icmp_seq=2 ttl=64 time=0.054 ms</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;docker-是什么？&quot;&gt;&lt;a href=&quot;#docker-是什么？&quot; class=&quot;headerlink&quot; title=&quot;docker 是什么？&quot;&gt;&lt;/a&gt;docker 是什么？&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;docker 独立的容器（container），可以跨系</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Java新特性</title>
    <link href="http://www.meprotoss.com/undefined/9ac696fa.html"/>
    <id>http://www.meprotoss.com/undefined/9ac696fa.html</id>
    <published>2024-05-08T14:54:02.000Z</published>
    <updated>2024-05-08T16:09:44.776Z</updated>
    
    <content type="html"><![CDATA[<h2 id="函数式接口-functional-interface"><a href="#函数式接口-functional-interface" class="headerlink" title="函数式接口(functional interface)"></a>函数式接口(functional interface)</h2><p>定义：也称 SAM 接口，即 Single Abstract Method interfaces，有且只有一个抽象方法，但可以有多个非抽象方法的接口。</p><p>在 java 8 中专门有一个包放函数式接口java.util.function，该包下的所有接口都有 @FunctionalInterface 注解，提供函数式编程。在其他包中也有函数式接口，其中一些没有@FunctionalInterface 注解，但是只要符合函数式接口的定义就是函数式接口，与是否有@FunctionalInterface注解无关，注解只是在编译时起到强制规范定义的作用。其在 Lambda 表达式中有广泛的应用。</p><p>基本上，函数式编程是一种编程风格，它将计算看作为是数学函数的求值。</p><p>在数学中，函数是将输入集与输出集相关联的表达式。函数的输出仅取决于其输入。我们也可以将两个或多个函数组合在一起得到一个新函数</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;函数式接口-functional-interface&quot;&gt;&lt;a href=&quot;#函数式接口-functional-interface&quot; class=&quot;headerlink&quot; title=&quot;函数式接口(functional interface)&quot;&gt;&lt;/a&gt;函数式接口(f</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Linux系统疑难杂症</title>
    <link href="http://www.meprotoss.com/undefined/c66bafdb.html"/>
    <id>http://www.meprotoss.com/undefined/c66bafdb.html</id>
    <published>2024-05-07T01:36:08.000Z</published>
    <updated>2024-05-07T14:09:10.937Z</updated>
    
    <content type="html"><![CDATA[<h2 id="ideaVim中英文输入法切换问题"><a href="#ideaVim中英文输入法切换问题" class="headerlink" title="ideaVim中英文输入法切换问题"></a>ideaVim中英文输入法切换问题</h2><ol><li>安装ideaVimExtension 插件</li><li>.ideavimrc中开启</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">set keep-english-in-normal</span><br><span class="line">set keep-english-in-normal-and-restore-in-insert</span><br></pre></td></tr></table></figure><h2 id="idea中输入法不跟随鼠标的问题"><a href="#idea中输入法不跟随鼠标的问题" class="headerlink" title="idea中输入法不跟随鼠标的问题"></a>idea中输入法不跟随鼠标的问题</h2><h3 id="问题原因"><a href="#问题原因" class="headerlink" title="问题原因"></a>问题原因</h3><p>具体问题官方其实七年前就有了（参考 <a href="https://youtrack.jetbrains.com/issue/JBR-2460%EF%BC%89%EF%BC%8C%E4%BD%86%E6%98%AF%E6%AF%94%E8%BE%83%E5%9D%91%E7%9A%84%E6%98%AF%E5%AE%98%E6%96%B9%E4%B9%9F%E4%B8%80%E7%9B%B4%E6%B2%A1%E6%9C%89%E8%A7%A3%E5%86%B3%E8%BF%99%E4%B8%AA%E9%97%AE%E9%A2%98%F0%9F%90%B6%EF%BC%88%E6%AD%A4%E5%A4%84%E5%BF%8D%E4%B8%8D%E4%BD%8F%E5%90%90%E6%A7%BD%E4%B8%80%E4%B8%8B%E5%93%88%EF%BC%89%E3%80%82%E7%AE%80%E5%8D%95%E6%9D%A5%E8%AF%B4%E5%B0%B1%E6%98%AF">https://youtrack.jetbrains.com/issue/JBR-2460），但是比较坑的是官方也一直没有解决这个问题🐶（此处忍不住吐槽一下哈）。简单来说就是</a> Idea 的 jre 运行环境一个 bug，导致输入法无法定位到鼠标位置。因此，我们要解决该问题必须要修改 JetBrainsRuntime 的运行代码。</p><h3 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h3><ul><li>下载已经修改好的 JRE 环境<br><a href="https://www.jianguoyun.com/p/De33XAgQ89jhCRjDh8EFIAA%EF%BC%9A">下载地址</a></li><li>替换idea目录的JRE</li></ul><h2 id="无法识别移动硬盘和U盘"><a href="#无法识别移动硬盘和U盘" class="headerlink" title="无法识别移动硬盘和U盘"></a>无法识别移动硬盘和U盘</h2><h3 id="问题原因-1"><a href="#问题原因-1" class="headerlink" title="问题原因"></a>问题原因</h3><p>文件系统不兼容</p><h3 id="解决方法-1"><a href="#解决方法-1" class="headerlink" title="解决方法"></a>解决方法</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo pacman -S ntfs-3g</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;ideaVim中英文输入法切换问题&quot;&gt;&lt;a href=&quot;#ideaVim中英文输入法切换问题&quot; class=&quot;headerlink&quot; title=&quot;ideaVim中英文输入法切换问题&quot;&gt;&lt;/a&gt;ideaVim中英文输入法切换问题&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;安装id</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Java常见面试题总结</title>
    <link href="http://www.meprotoss.com/undefined/ec262441.html"/>
    <id>http://www.meprotoss.com/undefined/ec262441.html</id>
    <published>2024-05-06T10:05:37.000Z</published>
    <updated>2024-05-13T13:49:50.240Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h2><h3 id="Java基础概念和知识"><a href="#Java基础概念和知识" class="headerlink" title="Java基础概念和知识"></a>Java基础概念和知识</h3><h4 id="Java语言的特点"><a href="#Java语言的特点" class="headerlink" title="Java语言的特点"></a>Java语言的特点</h4><h4 id="Java-SE-Standard-Edition-VS-Java-EE-Enterprise-Edition"><a href="#Java-SE-Standard-Edition-VS-Java-EE-Enterprise-Edition" class="headerlink" title="Java SE(Standard Edition) VS Java EE(Enterprise Edition)"></a>Java SE(Standard Edition) VS Java EE(Enterprise Edition)</h4><p>简单来说，Java SE 是 Java 的基础版本，Java EE 是 Java 的高级版本。Java SE 更适合开发桌面应用程序或简单的服务器应用程序，Java EE 更适合开发复杂的企业级应用程序或 Web 应用程序。</p><h4 id="JVM-vs-JDK-vs-JRE"><a href="#JVM-vs-JDK-vs-JRE" class="headerlink" title="JVM vs JDK vs JRE"></a>JVM vs JDK vs JRE</h4><ul><li><p>JVM(Java Virtual Machine) Java虚拟机是运行java字节码的虚拟机，是Java的核心，提供了Java的跨平台特性。</p></li><li><p>JDK(Java Development Kit) Java开发工具包，是Java的开发工具包，提供了Java的开发环境。它包含了 JRE，同时还包含了编译 java 源码的编译器 javac 以及一些其他工具比如 javadoc（文档注释工具）、jdb（调试器）、jconsole（基于 JMX 的可视化监控⼯具）、javap（反编译工具）等等。</p></li><li><p>JRE(Java Runtime Environment) Java运行时环境，是Java程序的运行环境，包含了JVM和一些核心类库。</p></li></ul><p>总结：JDK 包含了 JRE 和开发工具，JRE 包含了 JVM 和核心类库。</p><h4 id="字节码是什么？字节码的好处是什么？"><a href="#字节码是什么？字节码的好处是什么？" class="headerlink" title="字节码是什么？字节码的好处是什么？"></a>字节码是什么？字节码的好处是什么？</h4><p>在 Java 中，JVM 可以理解的代码就叫做字节码（即扩展名为 .class 的文件）</p><p>Java 语言通过字节码的方式，在一定程度上解决了传统解释型语言执行效率低的问题，同时又保留了解释型语言可移植的特点。</p><p>而且，由于字节码并不针对一种特定的机器，因此，Java 程序无须重新编译便可在多种不同操作系统的计算机上运行。</p><p>Java程序从源码到运行的过程：.java -&gt; javac编译 -&gt; .class（字节码） -&gt; 解释器&amp;JIT编译器 -&gt; 机器码</p><p>补充：我们需要格外注意的是 .class-&gt;机器码 这一步。在这一步 JVM 类加载器首先加载字节码文件，然后通过解释器逐行解释执行，这种方式的执行速度会相对比较慢。而且，有些方法和代码块是经常需要被调用的(也就是所谓的热点代码)，所以后面引进了 JIT（Just in Time Compilation） 编译器，而 JIT 属于<strong>运行时编译</strong>。当 JIT 编译器完成第一次编译后，其会将字节码对应的机器码保存下来，下次可以直接使用。而我们知道，机器码的运行效率肯定是高于 Java 解释器的。这也解释了我们为什么经常会说 Java 是编译与解释共存的语言 。</p><h4 id="为什么说-Java-语言“编译与解释并存”？"><a href="#为什么说-Java-语言“编译与解释并存”？" class="headerlink" title="为什么说 Java 语言“编译与解释并存”？"></a>为什么说 Java 语言“编译与解释并存”？</h4><p>高级编程语言按照程序的执行方式分为两种:</p><p>编译型：编译型语言 会通过<strong>编译器</strong>将源代码一次性翻译成可被该平台执行的机器码。一般情况下，编译语言的执行速度比较快，开发效率比较低。常见的编译性语言有 C、C++、Go、Rust 等等。</p><p>解释型：解释型语言会通过<strong>解释器</strong>一句一句的将代码解释（interpret）为机器代码后再执行。解释型语言开发效率比较快，执行速度比较慢。常见的解释性语言有 Python、JavaScript、PHP 等等。</p><p>为什么说 Java 语言“编译与解释并存”？</p><p>这是因为 Java 语言既具有编译型语言的特征，也具有解释型语言的特征。因为 Java 程序要经过先编译，后解释两个步骤，由 Java 编写的程序需要先经过编译步骤，生成字节码（.class 文件），这种字节码必须由 Java 解释器来解释执行。</p><h4 id="AOT-有什么优点？为什么不全部使用-AOT-呢？"><a href="#AOT-有什么优点？为什么不全部使用-AOT-呢？" class="headerlink" title="AOT 有什么优点？为什么不全部使用 AOT 呢？"></a>AOT 有什么优点？为什么不全部使用 AOT 呢？</h4><p>JDK 9 引入了一种新的编译模式 AOT(Ahead of Time Compilation) 。和 JIT 不同的是，这种编译模式会在程序<strong>被执行前</strong>就将其编译成机器码，属于静态编译（C、 C++，Rust，Go 等语言就是静态编译）。</p><p>然而，AOP编译无法支持 Java 的一些动态特性，如反射、动态代理、动态加载、JNI（Java Native Interface）等</p><h4 id="Java-和-C-的区别"><a href="#Java-和-C-的区别" class="headerlink" title="Java 和 C++ 的区别?"></a>Java 和 C++ 的区别?</h4><p>Java 和 C++ 都是面向对象的语言，都支持封装、继承和多态，但是，它们还是有挺多不相同的地方：</p><ul><li>Java 不提供指针来直接访问内存，程序内存更加安全</li><li>Java 的类是单继承的，C++ 支持多重继承；虽然 Java 的类不可以多继承，但是接口可以多继承。</li><li>Java 有自动内存管理垃圾回收机制(GC)，不需要程序员手动释放无用内存。</li><li>C++同时支持方法重载和操作符重载，但是 Java 只支持方法重载（操作符重载增加了复杂性，这与 Java 最初的设计思想不符）。</li></ul><h3 id="Java基本语法"><a href="#Java基本语法" class="headerlink" title="Java基本语法"></a>Java基本语法</h3><h4 id="标识符和关键字的区别是什么？"><a href="#标识符和关键字的区别是什么？" class="headerlink" title="标识符和关键字的区别是什么？"></a>标识符和关键字的区别是什么？</h4><p>在我们编写程序的时候，需要大量地为程序、类、变量、方法等取名字，于是就有了标识符 。简单来说，标识符就是程序员在开发的时候自己起的一个名字 。</p><p>有一些标识符，Java 语言已经赋予了其特殊的含义，只能用于特定的地方，这些特殊的标识符就是 关键字 。简单来说，关键字是被Java语言赋予特殊含义的标识符 。</p><h4 id="自增资减运算符"><a href="#自增资减运算符" class="headerlink" title="自增资减运算符"></a>自增资减运算符</h4><p>移位运算符是最基本的运算符之一，几乎每种编程语言都包含这一运算符。<strong>移位操作中，被操作的数据被视为二进制数，移位就是将其向左或向右移动若干位的运算</strong>。</p><p>在 Java 代码里使用 &lt;&lt;、 &gt;&gt; 和&gt;&gt;&gt;转换成的指令码运行起来会更高效些。</p><p>Java 中有三种移位运算符：</p><ul><li>&lt;&lt; :左移运算符，向左移若干位，高位丢弃，低位补零。x &lt;&lt; 1,相当于 x 乘以 2(不溢出的情况下)。</li><li><blockquote><blockquote><p>:带符号右移，向右移若干位，高位补符号位，低位丢弃。正数高位补 0,负数高位补 1。x &gt;&gt; 1,相当于 x 除以 2。</p></blockquote></blockquote></li><li><blockquote><blockquote><blockquote><p>:无符号右移，忽略符号位，空位都以 0 补齐。</p></blockquote></blockquote></blockquote></li></ul><p>注意：由于 double，float 在二进制中的表现比较特殊，因此不能来进行移位操作。</p><h5 id="如果移位的位数超过数值所占有的位数会怎样？"><a href="#如果移位的位数超过数值所占有的位数会怎样？" class="headerlink" title="如果移位的位数超过数值所占有的位数会怎样？"></a>如果移位的位数超过数值所占有的位数会怎样？</h5><p>当 int 类型左移&#x2F;右移位数大于等于 32 位操作时，会先求余（%）后再进行左移&#x2F;右移操作。也就是说左移&#x2F;右移 32 位相当于不进行移位操作（32%32&#x3D;0）。左移&#x2F;右移 42 位相当于左移&#x2F;右移 10 位（42%32&#x3D;10）。当 long 类型进行左移&#x2F;右移操作时，由于 long 对应的二进制是 64 位，因此求余操作的基数也变成了 64。</p><h4 id="continue、break-和-return-的区别是什么？"><a href="#continue、break-和-return-的区别是什么？" class="headerlink" title="continue、break 和 return 的区别是什么？"></a>continue、break 和 return 的区别是什么？</h4><p>需要在循环的过程中，当发生了某种条件之后 ，提前终止循环，这就需要用到下面几个关键词：</p><ul><li>continue：指跳出当前的这一次循环，继续下一次循环。</li><li>break：指跳出整个循环体，继续执行循环下面的语句。</li></ul><p>return 用于跳出所在方法，结束该方法的运行。<br>return 一般有两种用法：</p><ol><li>return;：直接使用 return 结束方法执行，用于没有返回值函数的方法</li><li>return value;：return 一个特定值，用于有返回值函数的方法</li></ol><h3 id="基本数据类型"><a href="#基本数据类型" class="headerlink" title="基本数据类型"></a>基本数据类型</h3><p>Java中有8种基本数据类型，分别是：</p><ul><li>6种数字类型：<ul><li>4种整形：byte short int long(位数依次为8 16 32 64)</li><li>2种浮点型：float double(位数依次为32 64)</li></ul></li><li>1种字符型：char</li><li>1种布尔型：boolean</li></ul><p>二进制补码表示法中，最高位是用来表示符号的（0 表示正数，1 表示负数），其余位表示数值部分。</p><p>注意：</p><ul><li><p>Java 里使用 long 类型的数据一定要在数值后面加上 L，否则将作为整型解析。</p></li><li><p>char a &#x3D; ‘h’char :单引号，String a &#x3D; “hello” :双引号。这八种基本类型都有对应的包装类分别为：Byte、Short、Integer、Long、Float、Double、Character、Boolean 。</p></li></ul><h4 id="基本类型和包装类型的区别？"><a href="#基本类型和包装类型的区别？" class="headerlink" title="基本类型和包装类型的区别？"></a>基本类型和包装类型的区别？</h4><p>基本数据类型是”数”，包装类型是”对象”。</p><ul><li>用途：除了定义一些常量和局部变量之外，我们在其他地方比如方法参数、对象属性中很少会使用基本类型来定义变量。并且，包装类型可用于泛型，而基本类型不可以。</li><li>存储方式：基本数据类型的局部变量存放在 Java 虚拟机栈中的局部变量表中，基本数据类型的成员变量（未被 static 修饰 ）存放在 Java 虚拟机的堆中。包装类型属于对象类型，我们知道几乎所有对象实例都存在于堆中。</li><li>占用空间：相比于包装类型（对象类型）， 基本数据类型占用的空间往往非常小。默认值：成员变量包装类型不赋值就是 null ，而基本类型有默认值且不是 null。</li><li>比较方式：对于基本数据类型来说，&#x3D;&#x3D; 比较的是值。对于包装数据类型来说，&#x3D;&#x3D; 比较的是对象的内存地址。<br>所有整型包装类对象之间值的比较，全部使用 equals() 方法。\</li></ul><p>⚠️ 注意：基本数据类型存放在栈中是一个常见的误区！ 基本数据类型的存储位置取决于它们的作用域和声明方式。如果它们是局部变量，那么它们会存放在栈中；如果它们是成员变量，那么它们会存放在堆中。</p><h4 id="自动装箱和拆箱"><a href="#自动装箱和拆箱" class="headerlink" title="自动装箱和拆箱"></a>自动装箱和拆箱</h4><p>什么是自动拆装箱？</p><ul><li>装箱：将基本数据类型转换为包装类型。</li><li>拆箱：将包装类型转换为基本数据类型。</li></ul><p>注意：如果频繁拆装箱的话，也会严重影响系统的性能。我们应该尽量避免不必要的拆装箱操作。</p><h4 id="为什么浮点数运算的时候会有精度丢失的风险？"><a href="#为什么浮点数运算的时候会有精度丢失的风险？" class="headerlink" title="为什么浮点数运算的时候会有精度丢失的风险？"></a>为什么浮点数运算的时候会有精度丢失的风险？</h4><p>计算机是二进制的，在标识一个数字的时候宽度是有限的，所以浮点数的精度是有限的，在表示无限不循环小数到时候，只能被截断。这也就是解释了为什么浮点数没有办法用二进制精确表示。</p><h4 id="如何解决浮点数运算的精度丢失问题？"><a href="#如何解决浮点数运算的精度丢失问题？" class="headerlink" title="如何解决浮点数运算的精度丢失问题？"></a>如何解决浮点数运算的精度丢失问题？</h4><p>BigDecimal 可以实现对浮点数的运算，不会造成精度丢失。通常情况下，大部分需要浮点数精确运算结果的业务场景（比如涉及到钱的场景）都是通过 BigDecimal 来做的。</p><h4 id="超过-long-整型的数据应该如何表示？"><a href="#超过-long-整型的数据应该如何表示？" class="headerlink" title="超过 long 整型的数据应该如何表示？"></a>超过 long 整型的数据应该如何表示？</h4><p>BigInteger 内部使用 int[] 数组来存储任意大小的整形数据。</p><p>相对于常规整数类型的运算来说，BigInteger 运算的效率会相对较低。</p><h3 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h3><h4 id="局部变量和成员变量的区别？"><a href="#局部变量和成员变量的区别？" class="headerlink" title="局部变量和成员变量的区别？"></a>局部变量和成员变量的区别？</h4><ul><li>语法形式：从语法形式上看，成员变量是属于类的，而局部变量是在代码块或方法中定义的变量或是方法的参数；成员变量可以被 public,private,static 等修饰符所修饰，而局部变量不能被访问控制修饰符及 static 所修饰；但是，成员变量和局部变量都能被 final 所修饰。</li><li>存储方式：从变量在内存中的存储方式来看，如果成员变量是使用 static 修饰的，那么这个成员变量是属于类的，如果没有使用 static 修饰，这个成员变量是属于实例的。而对象存在于堆内存，局部变量则存在于栈内存。</li><li>生存时间：从变量在内存中的生存时间上看，成员变量是<strong>对象</strong>的一部分，它随着对象的创建而存在，而局部变量随着<strong>方法</strong>的调用而自动生成，随着方法的调用结束而消亡。</li><li>默认值：从变量是否有默认值来看，成员变量如果没有被赋初始值，则会自动以类型的默认值而赋值（一种情况例外:被 final 修饰的成员变量也必须显式地赋值），而局部变量则不会自动赋值。</li></ul><h4 id="静态变量有什么作用？"><a href="#静态变量有什么作用？" class="headerlink" title="静态变量有什么作用？"></a>静态变量有什么作用？</h4><p>静态变量也就是被 static 关键字修饰的变量。它可以被类的所有实例共享，无论一个类创建了多少个对象，它们都共享同一份静态变量。也就是说，静态变量只会被分配一次内存，即使创建多个对象，这样可以节省内存。</p><h4 id="字符型常量和字符串常量的区别"><a href="#字符型常量和字符串常量的区别" class="headerlink" title="字符型常量和字符串常量的区别?"></a>字符型常量和字符串常量的区别?</h4><ul><li>形式 : 字符常量是<strong>单引号</strong>引起的一个字符，字符串常量是<strong>双引号</strong>引起的 0 个或若干个字符。</li><li>⭐️含义 : 字符常量相当于一个<strong>整型值</strong>( ASCII 值),可以参加表达式运算; 字符串常量代表一个<strong>地址值</strong>(该字符串在内存中存放位置)。占内存大小：字符常量只占 2 个字节; 字符串常量占若干个字节。</li></ul><h3 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h3><h4 id="静态方法为什么不能调用非静态成员"><a href="#静态方法为什么不能调用非静态成员" class="headerlink" title="静态方法为什么不能调用非静态成员"></a>静态方法为什么不能调用非静态成员</h4><p>这个需要结合 JVM 的相关知识，主要原因如下：</p><ol><li>静态方法是属于类的，在类加载的时候就会分配内存，可以通过类名直接访问。而非静态成员属于实例对象，只有在对象实例化之后才存在，需要通过类的实例对象去访问。</li><li>在类的非静态成员不存在的时候静态方法就已经存在了，此时调用在内存中还不存在的非静态成员，属于非法操作。</li></ol><p>简言之，静态方法先类加载时就有了，而非静态成员得创建对象实例之后才有，所以静态方法不能直接调用非静态成员。</p><h4 id="静态方法和实例方法的区别？"><a href="#静态方法和实例方法的区别？" class="headerlink" title="静态方法和实例方法的区别？"></a>静态方法和实例方法的区别？</h4><ol><li><p>调用方式<br>在外部调用静态方法时，可以使用 类名.方法名 的方式，也可以使用 对象.方法名 的方式(但一般使用前者，因为静态方法是属于类的)，而实例方法只有后面这种方式。也就是说，调用静态方法可以无需创建对象 。</p></li><li><p>访问类成员限制<br>静态方法在访问本类的成员时，只允许访问静态成员（即静态成员变量和静态方法），不允许访问实例成员（即实例成员变量和实例方法），而实例方法不存在这个限制。</p></li></ol><h4 id="方法的重载和重写有什么区别？"><a href="#方法的重载和重写有什么区别？" class="headerlink" title="方法的重载和重写有什么区别？"></a>方法的重载和重写有什么区别？</h4><ul><li><p>重载就是同样的一个方法能够根据输入数据的不同，做出不同的处理.(同一个方法名，但是有不同输入数据类型)重载就是同一个类中多个同名方法根据不同的传参来执行不同的逻辑处理。</p></li><li><p>重写就是当子类继承自父类的相同方法，输入数据一样，但要做出有别于父类的响应时，你就要覆盖父类方法(重写发生在运行期，是子类对父类的<strong>允许访问的方法</strong>的实现过程进行重新编写。)重写就是子类对父类方法的重新改造，外部样子不能改变，内部逻辑可以改变。</p></li></ul><h4 id="什么是可变长参数"><a href="#什么是可变长参数" class="headerlink" title="什么是可变长参数"></a>什么是可变长参数</h4><p>所谓可变长参数就是允许在调用方法时传入不定长度的参数。就比如下面这个方法就可以接受 0 个或者多个参数。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">method1</span><span class="params">(String... args)</span> &#123;</span><br><span class="line">   <span class="comment">//......</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当存在重载方法时，可变长参数的方法会被当做最后的选择。</p><h3 id="面向对象基础"><a href="#面向对象基础" class="headerlink" title="面向对象基础"></a>面向对象基础</h3><h4 id="面向对象和面向过程的区别"><a href="#面向对象和面向过程的区别" class="headerlink" title="面向对象和面向过程的区别"></a>面向对象和面向过程的区别</h4><ul><li>一步步</li><li>对象执行方法</li></ul><h4 id="对象实体与对象引用有何不同"><a href="#对象实体与对象引用有何不同" class="headerlink" title="对象实体与对象引用有何不同?"></a>对象实体与对象引用有何不同?</h4><p>new 创建对象实例（对象实例在堆内存中），对象引用指向对象实例（对象引用存放在栈内存中）。</p><ul><li>一个对象引用可以指向 0 个或 1 个对象（一根绳子可以不系气球，也可以系一个气球）；</li><li>一个对象可以有 n 个引用指向它（可以用 n 条绳子系住一个气球）。</li></ul><h4 id="如果一个类没有声明构造方法，该程序能正确执行吗"><a href="#如果一个类没有声明构造方法，该程序能正确执行吗" class="headerlink" title="如果一个类没有声明构造方法，该程序能正确执行吗?"></a>如果一个类没有声明构造方法，该程序能正确执行吗?</h4><p>可以执行！因为一个类即使没有声明构造方法也会有默认的不带参数的构造方法。如果我们自己添加了类的构造方法（无论是否有参），Java 就不会添加默认的无参数的构造方法了。</p><h4 id="构造方法是否可被-override"><a href="#构造方法是否可被-override" class="headerlink" title="构造方法是否可被 override?"></a>构造方法是否可被 override?</h4><p>构造方法不能被 override（重写）,但是可以 overload（重载）,所以你可以看到一个类中有多个构造函数的情况。</p><h4 id="面向对象的三大特征"><a href="#面向对象的三大特征" class="headerlink" title="面向对象的三大特征"></a>面向对象的三大特征</h4><ul><li>封装</li></ul><p>封装是指把一个对象的状态信息（也就是属性）隐藏在对象内部，不允许外部对象直接访问对象的内部信息</p><ul><li>继承</li></ul><p>关于继承如下 3 点请记住：</p><ol><li>子类拥有父类对象所有的属性和方法（包括私有属性和私有方法），但是父类中的私有属性和方法子类是无法访问，只是拥有。</li><li>子类可以拥有自己属性和方法，即子类可以对父类进行扩展。</li><li>子类可以用自己的方式实现父类的方法。</li></ol><ul><li>多态:多态，顾名思义，表示一个对象具有多种的状态，具体表现为父类的引用指向子类的实例。</li></ul><p>多态的特点:</p><ol><li>对象类型和引用类型之间具有继承（类）&#x2F;实现（接口）的关系；</li><li>引用类型变量发出的方法调用的到底是哪个类中的方法，必须在程序运行期间才能确定；</li><li>多态不能调用“只在子类存在但在父类不存在”的方法；</li><li>如果子类重写了父类的方法，真正执行的是子类重写的方法，如果子类没有重写父类的方法，执行的是父类的方法。(就近)</li></ol><h4 id="接口和抽象类有什么共同点和区别？"><a href="#接口和抽象类有什么共同点和区别？" class="headerlink" title="接口和抽象类有什么共同点和区别？"></a>接口和抽象类有什么共同点和区别？</h4><p>共同点：</p><ul><li>都不能被实例化。</li><li>能可包含抽象方法</li><li>都可以有默认实现方法</li></ul><p>不同点:</p><ul><li>接口主要用于对类的行为进行约束，你实现了某个接口就具有了对应的行为。(接口是一种规范);抽象类主要用于代码复用，强调的是所属关系。</li><li>一个类只能继承一个类，但是可以实现多个接口</li><li>接口中的成员变量只能是 public static final 类型的，不能被修改且必须有初始值，而抽象类的成员变量默认 default，可在子类中被重新定义，也可被重新赋值。</li></ul><h4 id="深拷贝和浅拷贝区别了解吗？什么是引用拷贝？"><a href="#深拷贝和浅拷贝区别了解吗？什么是引用拷贝？" class="headerlink" title="深拷贝和浅拷贝区别了解吗？什么是引用拷贝？"></a>深拷贝和浅拷贝区别了解吗？什么是引用拷贝？</h4><ul><li>浅拷贝：浅拷贝会在堆上创建一个新的对象（区别于引用拷贝的一点）;<br>不过，如果原对象内部的属性是引用类型的话，浅拷贝会直接复制内部对象的引用地址，也就是说拷贝对象和原对象<strong>共用同一个内部对象</strong>。<br>总结：会在堆上创建一个新对象，但是对象内部的引用类型的对象不拷贝对象本身，而是只拷贝地址引用。</li><li>深拷贝：深拷贝会<strong>完全复制整个对象</strong>，包括这个对象所包含的内部对象。</li></ul><h3 id="Object"><a href="#Object" class="headerlink" title="Object"></a>Object</h3><p>Object类是一个特殊的类，是所有类的父类</p><h4 id="和-equals-的区别是什么？"><a href="#和-equals-的区别是什么？" class="headerlink" title="&#x3D;&#x3D; 和 equals() 的区别是什么？"></a>&#x3D;&#x3D; 和 equals() 的区别是什么？</h4><p>&#x3D;&#x3D; 对于基本类型和引用类型的作用效果是不同的(本质比较的是值)：</p><ul><li>对于基本数据类型来说，&#x3D;&#x3D; 比较的是值。</li><li>对于引用数据类型来说，&#x3D;&#x3D; 比较的是对象的内存地址。</li></ul><p>因为 Java 只有值传递，所以，对于 &#x3D;&#x3D; 来说，不管是比较基本数据类型，还是引用数据类型的变量，其本质比较的都是值，只是引用类型变量存的值是对象的地址。</p><p>equals() 不能用于判断基本数据类型的变量，只能用来判断两个<strong>对象</strong>是否相等。</p><p>equals() 方法存在两种使用情况：</p><ul><li>类没有重写 equals()方法：通过equals()比较该类的两个对象时，等价于通过“&#x3D;&#x3D;”比较这两个对象，使用的默认是 Object类equals()方法。</li><li>类重写了 equals()方法：一般我们都重写 equals()方法来比较两个对象中的属性是否相等；若它们的属性相等，则返回 true(即，认为这两个对象相等)。</li></ul><h4 id="hashCode-有什么用？"><a href="#hashCode-有什么用？" class="headerlink" title="hashCode() 有什么用？"></a>hashCode() 有什么用？</h4><p>hashCode() 的作用是获取哈希码（int 整数），也称为散列码。这个哈希码的作用是确定该对象在哈希表中的索引位置。散列表存储的是键值对(key-value)，它的特点是：能根据“键”快速的检索出对应的“值”。这其中就利用到了散列码！（可以快速找到所需要的对象）</p><h4 id="为什么要有-hashCode？"><a href="#为什么要有-hashCode？" class="headerlink" title="为什么要有 hashCode？"></a>为什么要有 hashCode？</h4><p>当你把对象加入 HashSet 时，HashSet 会先计算对象的 hashCode 值来判断对象加入的位置，同时也会与其他已经加入的对象的 hashCode 值作比较，如果没有相符的 hashCode，HashSet 会假设对象没有重复出现。<br>但是如果发现有相同 hashCode 值的对象，这时会调用 equals() 方法来检查 hashCode 相等的对象是否真的相同。<br>如果两者相同，HashSet 就不会让其加入操作成功。如果不同的话，就会重新散列到其他位置。这样我们就大大减少了 equals 的次数，相应就大大提高了执行速度。</p><p>本质山， hashCode() 和 equals()都是用于比较两个对象是否相等。</p><h5 id="那为什么-JDK-还要同时提供这两个方法呢？"><a href="#那为什么-JDK-还要同时提供这两个方法呢？" class="headerlink" title="那为什么 JDK 还要同时提供这两个方法呢？"></a>那为什么 JDK 还要同时提供这两个方法呢？</h5><p>hashCode 在一些容器中(如HashSet HashyMap)中的判断元素是否在对应容器中的效率更高</p><h5 id="那为什么不只提供-hashCode-方法呢？"><a href="#那为什么不只提供-hashCode-方法呢？" class="headerlink" title="那为什么不只提供 hashCode() 方法呢？"></a>那为什么不只提供 hashCode() 方法呢？</h5><p>两个对象的hashCode值相等不代表两个对象就一定相等</p><h5 id="那为什么两个对象有相同的-hashCode-值，它们也不一定是相等的？"><a href="#那为什么两个对象有相同的-hashCode-值，它们也不一定是相等的？" class="headerlink" title="那为什么两个对象有相同的 hashCode 值，它们也不一定是相等的？"></a>那为什么两个对象有相同的 hashCode 值，它们也不一定是相等的？</h5><p>因为 hashCode() 所使用的哈希算法也许刚好会让多个对象传回相同的哈希值。越糟糕的哈希算法越容易碰撞，但这也与数据值域分布的特性有关（所谓哈希碰撞也就是指的是不同的对象得到相同的 hashCode )。</p><p>总结下来就是:</p><ul><li>如果两个对象的hashCode 值相等，那这两个对象不一定相等（哈希碰撞）。</li><li>如果两个对象的hashCode 值相等并且equals()方法也返回 true，我们才认为这两个对象相等。如果两个对象的hashCode 值不相等，我们就可以直接认为这两个对象不相等。<br>(hashCode相等是两个对象相等的必要不充分条件)</li></ul><h4 id="为什么重写-equals-时必须重写-hashCode-方法？"><a href="#为什么重写-equals-时必须重写-hashCode-方法？" class="headerlink" title="为什么重写 equals() 时必须重写 hashCode() 方法？"></a>为什么重写 equals() 时必须重写 hashCode() 方法？</h4><p>为什么重写 equals() 时必须重写 hashCode() 方法？因为两个相等的对象的 hashCode 值必须是相等。也就是说如果 equals 方法判断两个对象是相等的，那这两个对象的 hashCode 值也要相等。如果重写 equals() 时没有重写 hashCode() 方法的话就可能会导致 equals 方法判断是相等的两个对象，hashCode 值却不相等。</p><h3 id="String"><a href="#String" class="headerlink" title="String"></a>String</h3><h4 id="String、StringBuffer、StringBuilder-的区别？"><a href="#String、StringBuffer、StringBuilder-的区别？" class="headerlink" title="String、StringBuffer、StringBuilder 的区别？"></a>String、StringBuffer、StringBuilder 的区别？</h4><ul><li><p>可变性:<br>String是不可变的。而StringBuilder 与 StringBuffer 都继承自 AbstractStringBuilder 类，在 AbstractStringBuilder 中也是使用字符数组保存字符串，不过没有使用 final 和 private 关键字修饰，最关键的是这个 AbstractStringBuilder 类还提供了很多修改字符串的方法比如 append 方法。</p></li><li><p>线程安全性:<br>String 中的对象是不可变的，也就可以理解为常量，线程安全。<br>AbstractStringBuilder 是 StringBuilder 与 StringBuffer 的公共父类，定义了一些字符串的基本操作，如 expandCapacity、append、insert、indexOf 等公共方法。<br>StringBuffer 对方法加了同步锁或者对调用的方法加了同步锁，所以是线程安全的。<br>StringBuilder 并没有对方法进行加同步锁，所以是非线程安全的。</p></li><li><p>性能:<br>每次对 String 类型进行改变的时候，都会生成一个新的 String 对象，然后将指针指向新的 String 对象。<br>StringBuffer 每次都会对 StringBuffer 对象本身进行操作，而不是生成新的对象并改变对象引用。<br>相同情况下使用 StringBuilder 相比使用 StringBuffer 仅能获得 10%~15% 左右的性能提升，但却要冒多线程不安全的风险。</p></li><li><p>对于三者的使用</p></li><li><p>操作少量的数据: 适用 String</p></li><li><p>单线程操作字符串缓冲区下操作大量数据: 适用 StringBuilder</p></li><li><p>多线程操作字符串缓冲区下操作大量数据: 适用 StringBuffer</p></li></ul><h4 id="String为什么是不可变的"><a href="#String为什么是不可变的" class="headerlink" title="String为什么是不可变的"></a>String为什么是不可变的</h4><p>String 类中使用 final 关键字修饰字符数组</p><h4 id="String-equals-和-Object-equals-有何区别？"><a href="#String-equals-和-Object-equals-有何区别？" class="headerlink" title="String#equals() 和 Object#equals() 有何区别？"></a>String#equals() 和 Object#equals() 有何区别？</h4><p>String 中的 equals 方法是被重写过的，比较的是 String 字符串的值是否相等。 Object 的 equals 方法是比较的对象的内存地址。</p><h4 id="字符串常量池的作用"><a href="#字符串常量池的作用" class="headerlink" title="字符串常量池的作用"></a>字符串常量池的作用</h4><p>字符串常量池 是 JVM 为了提升性能和减少内存消耗针对字符串（String 类）专门开辟的一块区域，主要目的是为了避免字符串的重复创建。</p><h4 id="String-s1-new-String-“abc”-这句话创建了几个字符串对象？"><a href="#String-s1-new-String-“abc”-这句话创建了几个字符串对象？" class="headerlink" title="String s1 &#x3D; new String(“abc”);这句话创建了几个字符串对象？"></a>String s1 &#x3D; new String(“abc”);这句话创建了几个字符串对象？</h4><p>这句话包含了两个对象 字符串常量对象”abc”和字符串对象s1</p><p>字符串对象s1一定会创建在堆里(看见了new则一定会在堆中创建对象)</p><p>如果 字符串常量池中 不存在字符串对象“abc”的引用，那么它会在堆上创建两个字符串对象，其中一个字符串对象的引用会被保存在字符串常量池中。<br>如果字符串常量池中已存在字符串对象“abc”的引用，则只会在堆中创建 1 个字符串对象“abc”。</p><h4 id="String-intern-方法有什么作用"><a href="#String-intern-方法有什么作用" class="headerlink" title="String#intern 方法有什么作用?"></a>String#intern 方法有什么作用?</h4><p>String.intern() 是一个 native（本地）方法，其作用是将指定的字符串对象的引用保存在字符串常量池中，可以简单分为两种情况：</p><ul><li>如果字符串常量池中保存了对应的字符串对象的引用，就直接返回该引用。</li><li>如果字符串常量池中没有保存了对应的字符串对象的引用，那就在常量池中创建一个指向该字符串对象的引用并返</li></ul><h3 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h3><h4 id="Java中exception和error有什么区别"><a href="#Java中exception和error有什么区别" class="headerlink" title="Java中exception和error有什么区别"></a>Java中exception和error有什么区别</h4><p>在 Java 中，所有的异常都有一个共同的祖先 java.lang 包中的 Throwable 类。Throwable 类有两个重要的子类:</p><ul><li>Exception :程序本身可以处理的异常，可以通过 catch 来进行捕获。Exception 又可以分为 Checked Exception (受检查异常，必须处理) 和 Unchecked Exception (不受检查异常，可以不处理)。</li><li>Error：Error 属于程序无法处理的错误 ，我们没办法通过 catch 来进行捕获不建议通过catch捕获 。例如 Java 虚拟机运行错误（Virtual MachineError）、虚拟机内存不够错误(OutOfMemoryError)、类定义错误（NoClassDefFoundError）等 。这些异常发生时，Java 虚拟机（JVM）一般会选择线程终止。</li></ul><h4 id="受检异常-checked-exception-和未受检异常-Unchecked-exception-有什么区别"><a href="#受检异常-checked-exception-和未受检异常-Unchecked-exception-有什么区别" class="headerlink" title="受检异常(checked exception)和未受检异常(Unchecked exception)有什么区别"></a>受检异常(checked exception)和未受检异常(Unchecked exception)有什么区别</h4><ul><li>Checked Exception 即受检查异常 ，Java 代码在编译过程中，如果受检查异常没有被 catch或者throws 关键字处理的话，就没办法通过编译。<br>除了RuntimeException及其子类以外，其他的Exception类及其子类都属于受检查异常 。常见的受检查异常有：IO 相关的异常、ClassNotFoundException、SQLException…。</li><li>Unchecked Exception 即 不受检查异常 ，Java 代码在编译过程中 ，我们即使不处理不受检查异常也可以正常通过编译。<br>RuntimeException 及其子类都统称为非受检查异常，常见的有：</li><li>NullPointerException(空指针错误)</li><li>IllegalArgumentException(参数错误比如方法入参类型错误)</li><li>NumberFormatException（字符串转换为数字格式错误，IllegalArgumentException的子类）</li><li>ArrayIndexOutOfBoundsException（数组越界错误）</li><li>ClassCastException（类型转换错误）</li><li>ArithmeticException（算术错误）</li><li>SecurityException （安全错误比如权限不够）</li><li>UnsupportedOperationException(不支持的操作错误比如重复创建同一用户)</li><li>…</li></ul><h4 id="Throwable-类常用方法有哪些？"><a href="#Throwable-类常用方法有哪些？" class="headerlink" title="Throwable 类常用方法有哪些？"></a>Throwable 类常用方法有哪些？</h4><ul><li>String getMessage(): 返回异常发生时的简要描述</li><li>String toString(): 返回异常发生时的详细信息</li><li>String getLocalizedMessage(): 返回异常对象的本地化信息。使用 Throwable 的子类覆盖这个方法，可以生成本地化信息。如果子类没有覆盖该方法，则该方法返回的信息与 getMessage()返回的结果相同</li><li>void printStackTrace(): 在控制台上打印 Throwable 对象封装的异常信息</li></ul><h4 id="try-catch-finally-如何使用？"><a href="#try-catch-finally-如何使用？" class="headerlink" title="try-catch-finally 如何使用？"></a>try-catch-finally 如何使用？</h4><ul><li>try:用于捕获异常。后面可跟一个或多个catch，如果没有catch则必须跟一个finally</li><li>catch:用于处理try捕获的异常</li><li>finally：无论是否捕获或处理异常，finally 块里的语句都会被执行。<br>当在 try 块或 catch 块中遇到 return 语句时，finally 语句块将在方法返回之前被执行。</li></ul><p>⚠️注意：不要在 finally 语句块中使用 return! 当 try 语句和 finally 语句中都有 return 语句时，try 语句块中的 return 语句会被忽略。这是因为 try 语句中的 return 返回值会先被暂存在一个本地变量中，当执行到 finally 语句中的 return 之后，这个本地变量的值就变为了 finally 语句中的 return 返回值。</p><h4 id="finally-中的代码一定会执行吗？"><a href="#finally-中的代码一定会执行吗？" class="headerlink" title="finally 中的代码一定会执行吗？"></a>finally 中的代码一定会执行吗？</h4><p>不一定，finally 之前虚拟机被终止运行的话(例如System.exit(1)，finally 中的代码就不会被执行。</p><p>另外，在以下 2 种特殊情况下，finally 块的代码也不会被执行：</p><ul><li>程序所在的线程死亡。</li><li>关闭 CPU。</li></ul><h4 id="如何使用-try-with-resources-代替try-catch-finally？"><a href="#如何使用-try-with-resources-代替try-catch-finally？" class="headerlink" title="如何使用 try-with-resources 代替try-catch-finally？"></a>如何使用 try-with-resources 代替try-catch-finally？</h4><p>适用范围（资源的定义）： 任何实现 java.lang.AutoCloseable或者 java.io.Closeable 的对象关闭资源和 finally 块的执行顺序： 在 try-with-resources 语句中，任何 catch 或 finally 块在声明的资源关闭后运行</p><p>简单来说，当有类似于InputStream、OutputStream、Scanner、PrintWriter等的资源都需要我们调用close()方法来手动关闭时，可以用try-with-resources来代码让更简短，更清晰，产生的异常对我们也更有用</p><h4 id="异常使用有哪些需要注意的地方？"><a href="#异常使用有哪些需要注意的地方？" class="headerlink" title="异常使用有哪些需要注意的地方？"></a>异常使用有哪些需要注意的地方？</h4><ul><li>每次手动抛出异常，我们都需要手动 new 一个异常对象抛出。</li><li>抛出的异常信息一定要有意义。</li><li>建议抛出更加具体的异常</li></ul><h3 id="泛型-Generics"><a href="#泛型-Generics" class="headerlink" title="泛型(Generics)"></a>泛型(Generics)</h3><h4 id="泛型的使用方式有几种？"><a href="#泛型的使用方式有几种？" class="headerlink" title="泛型的使用方式有几种？"></a>泛型的使用方式有几种？</h4><ul><li>泛型类</li><li>泛型接口</li><li>泛型方法</li></ul><h4 id="项目中哪里遇到了泛型"><a href="#项目中哪里遇到了泛型" class="headerlink" title="项目中哪里遇到了泛型?"></a>项目中哪里遇到了泛型?</h4><ul><li><input disabled="" type="checkbox"> </li><li>自定义接口通用返回结果 CommonResult<T> 通过参数 T 可根据具体的返回类型动态指定结果的数据类型</li><li>定义 Excel 处理类 ExcelUtil<T> 用于动态指定 Excel 导出的数据类型</li><li>构建集合工具类（参考 Collections 中的 sort, binarySearch 方法）。……</li></ul><h3 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h3><h4 id="什么是反射？"><a href="#什么是反射？" class="headerlink" title="什么是反射？"></a>什么是反射？</h4><p>反射赋予了我们在运行时分析类以及执行类中方法的能力。<br>通过反射可以获取任意一个类的所有属性和方法，你还可以调用这些方法和属性。</p><h4 id="反射的优缺点？"><a href="#反射的优缺点？" class="headerlink" title="反射的优缺点？"></a>反射的优缺点？</h4><p>优点：</p><ul><li>反射可以让我们的代码更加灵活、为各种框架提供开箱即用的功能提供了便利。</li></ul><p>缺点：</p><ul><li>安全问题，比如可以无视泛型参数的安全检查（泛型参数的安全检查发生在编译时）</li><li>性能也要稍差点</li></ul><h4 id="反射的应用场景？"><a href="#反射的应用场景？" class="headerlink" title="反射的应用场景？"></a>反射的应用场景？</h4><ul><li>框架中大量使用了动态代理，而动态代理的实现也依赖反射。</li><li>注解的实现也用到了反射。</li></ul><h3 id="注解-Annotation"><a href="#注解-Annotation" class="headerlink" title="注解(Annotation)"></a>注解(Annotation)</h3><h4 id="注解是什么"><a href="#注解是什么" class="headerlink" title="注解是什么"></a>注解是什么</h4><p>可以看作是一种特殊的注释，主要用于修饰类、方法或者变量，提供某些信息供程序在编译或者运行时使用。</p><h4 id="注解的解析方法有哪几种？"><a href="#注解的解析方法有哪几种？" class="headerlink" title="注解的解析方法有哪几种？"></a>注解的解析方法有哪几种？</h4><ul><li>编译期直接扫描：编译器在编译 Java 代码的时候扫描对应的注解并处理，比如某个方法使用@Override 注解，编译器在编译的时候就会检测当前的方法是否重写了父类对应的方法。</li><li>运行期通过反射处理：像框架中自带的注解(比如 Spring 框架的 @Value、@Component)都是通过反射来进行处理的。</li></ul><h3 id="SPI-Service-Provider-Interface"><a href="#SPI-Service-Provider-Interface" class="headerlink" title="SPI(Service Provider Interface)"></a>SPI(Service Provider Interface)</h3><h4 id="什么是SPI"><a href="#什么是SPI" class="headerlink" title="什么是SPI"></a>什么是SPI</h4><p>专门提供给服务提供者或者扩展框架功能的开发者去使用的一个接口。SPI 将服务接口和具体的服务实现分离开来，将服务调用方和服务实现者解耦，能够提升程序的扩展性、可维护性。</p><h4 id="SPI-和-API-有什么区别？"><a href="#SPI-和-API-有什么区别？" class="headerlink" title="SPI 和 API 有什么区别？"></a>SPI 和 API 有什么区别？</h4><p>广义上来说它们都属于接口,API是接口存在于实现方，SPI是接口存在于调用方</p><h4 id="SPI-的优缺点？"><a href="#SPI-的优缺点？" class="headerlink" title="SPI 的优缺点？"></a>SPI 的优缺点？</h4><ul><li>通过 SPI 机制能够大大地提高接口设计的灵活性，<br>但是 SPI 机制也存在一些缺点，比如：</li><li>需要遍历加载所有的实现类，不能做到按需加载，这样效率还是相对较低的。</li><li>当多个 ServiceLoader 同时 load 时，会有并发问题。</li></ul><h3 id="序列化和反序列化"><a href="#序列化和反序列化" class="headerlink" title="序列化和反序列化"></a>序列化和反序列化</h3><h4 id="什么是序列化-什么是反序列化"><a href="#什么是序列化-什么是反序列化" class="headerlink" title="什么是序列化?什么是反序列化?"></a>什么是序列化?什么是反序列化?</h4><p>简单来说：</p><ul><li>序列化：将数据结构或对象转换成二进制字节流的过程</li><li>反序列化：将在序列化过程中所生成的二进制字节流转换成数据结构或者对象的过程</li></ul><p>序列化的主要目的是通过网络传输对象或者说是将对象存储到文件系统、数据库、内存中。</p><p>序列化协议对应于 TCP&#x2F;IP 4 层模型的哪一层？</p><p>OSI 七层协议模型中，表示层做的事情主要就是对应用层的用户数据进行处理转换为二进制流。反过来的话，就是将二进制流转换成应用层的用户数据，就对应的是序列化和反序列化么</p><p>又因为OSI 七层协议模型中的应用层、表示层和会话层对应的都是 TCP&#x2F;IP 四层模型中的应用层，所以序列化协议属于 TCP&#x2F;IP 协议<strong>应用层</strong>的一部分。</p><h4 id="如果有些字段不想进行序列化怎么办？"><a href="#如果有些字段不想进行序列化怎么办？" class="headerlink" title="如果有些字段不想进行序列化怎么办？"></a>如果有些字段不想进行序列化怎么办？</h4><p>使用transient关键字<br>transient 关键字的作用是：阻止实例中那些用此关键字修饰的的变量序列化；当对象被反序列化时，被 transient 修饰的变量值不会被持久化和恢复。</p><h4 id="为什么不推荐使用-JDK-自带的序列化？"><a href="#为什么不推荐使用-JDK-自带的序列化？" class="headerlink" title="为什么不推荐使用 JDK 自带的序列化？"></a>为什么不推荐使用 JDK 自带的序列化？</h4><ul><li>不支持跨语言调用</li><li>性能差</li><li>存在安全问题:输入的反序列化的数据可被用户控制，那么攻击者即可通过构造恶意输入，让反序列化产生非预期的对象，在此过程中执行构造的任意代码</li></ul><h3 id="IO"><a href="#IO" class="headerlink" title="IO"></a>IO</h3><h4 id="Java-IO-流了解吗？"><a href="#Java-IO-流了解吗？" class="headerlink" title="Java IO 流了解吗？"></a>Java IO 流了解吗？</h4><p>数据输入到计算机内存的过程即输入，反之输出到外部存储（比如数据库，文件，远程主机）的过程即输出</p><p>数据传输过程类似于水流，因此称为 IO 流</p><p>IO 流在 Java 中分为输入流和输出流，而根据数据的处理方式又分为字节流和字符流。</p><p>Java IO 流的 40 多个类都是从如下 4 个抽象类基类中派生出来的:</p><p>InputStream&#x2F;Reader:前者是字节输入流，后者是字符输入流。<br>OutputStream&#x2F;Writer:前者是字节输出流，后者是字符输出流。</p><h4 id="Java-IO-中的设计模式有哪些？"><a href="#Java-IO-中的设计模式有哪些？" class="headerlink" title="Java IO 中的设计模式有哪些？"></a>Java IO 中的设计模式有哪些？</h4><ul><li><input disabled="" type="checkbox"> </li></ul><h4 id="BIO、NIO-和-AIO-的区别？"><a href="#BIO、NIO-和-AIO-的区别？" class="headerlink" title="BIO、NIO 和 AIO 的区别？"></a>BIO、NIO 和 AIO 的区别？</h4><ul><li><input disabled="" type="checkbox"> </li></ul><h3 id="语法糖"><a href="#语法糖" class="headerlink" title="语法糖"></a>语法糖</h3><h4 id="什么是语法糖"><a href="#什么是语法糖" class="headerlink" title="什么是语法糖"></a>什么是语法糖</h4><p>语法糖（Syntactic sugar） 代指的是编程语言为了方便程序员开发程序而设计的一种特殊语法，这种语法对编程语言的功能并没有影响。实现相同的功能，基于语法糖写出来的代码往往更简单简洁且更易阅读。</p><p>不过，JVM 其实并不能识别语法糖，Java 语法糖要想被正确执行，需要先通过编译器进行解糖，也就是在程序编译阶段将其转换成 JVM 认识的基本语法</p><h4 id="Java中常见的语法糖有哪些？"><a href="#Java中常见的语法糖有哪些？" class="headerlink" title="Java中常见的语法糖有哪些？"></a>Java中常见的语法糖有哪些？</h4><h3 id="⭐️基础重要知识点"><a href="#⭐️基础重要知识点" class="headerlink" title="⭐️基础重要知识点"></a>⭐️基础重要知识点</h3><h4 id="Java中的值传递详解"><a href="#Java中的值传递详解" class="headerlink" title="Java中的值传递详解"></a>Java中的值传递详解</h4><h5 id="形参vs实参"><a href="#形参vs实参" class="headerlink" title="形参vs实参"></a>形参vs实参</h5><p>参数在程序设计语言中可分为：</p><ul><li>实参:Arguments,用于传递给函数或方法的参数，必须要有确定的值</li><li>形参:Parameters,用于定义函数&#x2F;方法，接受实参</li></ul><h4 id="值传递vs引用传递"><a href="#值传递vs引用传递" class="headerlink" title="值传递vs引用传递"></a>值传递vs引用传递</h4><p>程序设计语言将<code>实参</code>传递给方法的方法有两种：</p><ul><li>引用传递：方法接受的是实参所引用的对象在<code>堆</code>中的地址，对<code>形参</code>的修改会影响到实参</li><li>值传递：方法接受的是实际参数的<code>拷贝副本</code></li></ul><p>Java中只有值传递</p><ul><li>一个方法使不能改变一个基本数据类型的参数的</li><li>对于引用类型的数据,也是传递的值，但是引用类型（如数组对象)看似传递的是地址，实则还是值，因为引用类型存储的值就是实参的地址</li></ul><h4 id="Java中的序列化"><a href="#Java中的序列化" class="headerlink" title="Java中的序列化"></a>Java中的序列化</h4><h4 id="泛型和通配符"><a href="#泛型和通配符" class="headerlink" title="泛型和通配符"></a>泛型和通配符</h4><h4 id="反射机制"><a href="#反射机制" class="headerlink" title="反射机制"></a>反射机制</h4><h4 id="代理模式"><a href="#代理模式" class="headerlink" title="代理模式"></a>代理模式</h4><h4 id="BigDecimal"><a href="#BigDecimal" class="headerlink" title="BigDecimal"></a>BigDecimal</h4><h4 id="Java魔法类Unsafe"><a href="#Java魔法类Unsafe" class="headerlink" title="Java魔法类Unsafe"></a>Java魔法类Unsafe</h4><h4 id="Java-SPI-机制"><a href="#Java-SPI-机制" class="headerlink" title="Java SPI 机制"></a>Java SPI 机制</h4><h4 id="语法糖-1"><a href="#语法糖-1" class="headerlink" title="语法糖"></a>语法糖</h4><h3 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h3><h3 id="并发编程"><a href="#并发编程" class="headerlink" title="并发编程"></a>并发编程</h3><h4 id="ThreadLocal"><a href="#ThreadLocal" class="headerlink" title="ThreadLocal"></a>ThreadLocal</h4><h5 id="ThreadLocal有什么用？"><a href="#ThreadLocal有什么用？" class="headerlink" title="ThreadLocal有什么用？"></a>ThreadLocal有什么用？</h5><p>通常情况下，我们创建的变量是可以被任何一个线程访问并修改的。<br>如果想实现每一个线程都有自己的专属本地变量该如何解决呢？</p><p>DK 中自带的ThreadLocal类正是为了解决这样的问题。 ThreadLocal类主要解决的就是让每个线程绑定自己的值，可以将ThreadLocal类形象的比喻成存放数据的盒子，盒子中可以存储每个线程的私有数据。</p><p>如果你创建了一个ThreadLocal变量，那么访问这个变量的每个线程都会有这个变量的本地副本，这也是ThreadLocal变量名的由来。他们可以使用 get() 和 set() 方法来获取默认值或将其值更改为当前线程所存的副本的值，从而避免了线程安全问题。</p><h5 id="ThreadLocal内存泄露问题是怎么倒置的？"><a href="#ThreadLocal内存泄露问题是怎么倒置的？" class="headerlink" title="ThreadLocal内存泄露问题是怎么倒置的？"></a>ThreadLocal内存泄露问题是怎么倒置的？</h5><blockquote><p>[!TIP]<br>待施工</p></blockquote><h4 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h4><p>线程池就是管理一系列线程的资源池。<br>当有任务要处理时，直接从线程池中获取线程来处理，处理完之后线程并不会立即被销毁，而是等待下一个任务。</p><h5 id="为什么要用线程池？"><a href="#为什么要用线程池？" class="headerlink" title="为什么要用线程池？"></a>为什么要用线程池？</h5><p>池化技术想必大家已经屡见不鲜了，线程池、数据库连接池、HTTP 连接池等等都是对这个思想的应用。池化技术的思想主要是为了减少每次获取资源的消耗，提高对资源的利用率。</p><p>使用线程池的好处：</p><ul><li>降低资源消耗。通过重复利用已创建的线程降低线程创建和销毁造成的消耗。</li><li>提高响应速度。当任务到达时，任务可以不需要等到线程创建就能立即执行。</li><li>提高线程的可管理性。线程是稀缺资源，如果无限制的创建，不仅会消耗系统资源，还会降低系统的稳定性，使用线程池可以进行统一的分配，调优和监控。</li></ul><h5 id="如何创建线程池"><a href="#如何创建线程池" class="headerlink" title="如何创建线程池"></a>如何创建线程池</h5><p>法一：通过ThreadPoolExecutor构造函数来创建（推荐）。</p><p>法二：通过 Executor 框架的工具类 Executors 来创建。</p><p>Executors工具类可以创建多种类型的线程池，包括：</p><ul><li>FixedThreadPool：固定线程数量的线程池。该线程池中的线程数量始终不变。当有一个新的任务提交时，线程池中若有空闲线程，则立即执行。若没有，则新的任务会被暂存在一个任务队列中，待有线程空闲时，便处理在任务队列中的任务。</li><li>SingleThreadExecutor： 只有一个线程的线程池。若多余一个任务被提交到该线程池，任务会被保存在一个任务队列中，待线程空闲，按先入先出(队列)的顺序执行队列中的任务。</li><li>CachedThreadPool： 可根据实际情况调整线程数量的线程池。线程池的线程数量不确定，但若有空闲线程可以复用，则会优先使用可复用的线程。若所有线程均在工作，又有新的任务提交，则会创建新的线程处理任务。所有线程在当前任务执行完毕后，将返回线程池进行复用。</li><li>ScheduledThreadPool：给定的延迟后运行任务或者定期执行任务的线程池。</li></ul><h5 id="为什么不推荐使用内置线程池"><a href="#为什么不推荐使用内置线程池" class="headerlink" title="为什么不推荐使用内置线程池"></a>为什么不推荐使用内置线程池</h5><p>《阿里巴巴 Java 开发手册》“并发处理”这一章节，明确指出线程资源必须通过线程池提供，不允许在应用中自行显式创建线程。</p><ul><li>使用线程池的好处是减少在创建和销毁线程上所消耗的时间以及系统资源开销，解决资源不足的问题。如果不使用线程池，有可能会造成系统创建大量同类线程而导致消耗完内存或者“过度切换”的问题。</li></ul><p>另外，《阿里巴巴 Java 开发手册》中强制线程池不允许使用 Executors 去创建，而是通过 ThreadPoolExecutor 构造函数的方式，因为<code>Executors</code>容易导致OOM(out of memory)问题</p><h5 id="线程池常见参数"><a href="#线程池常见参数" class="headerlink" title="线程池常见参数"></a>线程池常见参数</h5><h5 id="线程池的拒绝策略有哪些？"><a href="#线程池的拒绝策略有哪些？" class="headerlink" title="线程池的拒绝策略有哪些？"></a>线程池的拒绝策略有哪些？</h5><h5 id="如果不允许丢弃任务任务，应该选择哪个拒绝策略？"><a href="#如果不允许丢弃任务任务，应该选择哪个拒绝策略？" class="headerlink" title="如果不允许丢弃任务任务，应该选择哪个拒绝策略？"></a>如果不允许丢弃任务任务，应该选择哪个拒绝策略？</h5><h5 id="CallerRunsPolicy-拒绝策略有什么风险？如何解决？"><a href="#CallerRunsPolicy-拒绝策略有什么风险？如何解决？" class="headerlink" title="CallerRunsPolicy 拒绝策略有什么风险？如何解决？"></a>CallerRunsPolicy 拒绝策略有什么风险？如何解决？</h5><h5 id="线程池常用的阻塞队列有哪些？"><a href="#线程池常用的阻塞队列有哪些？" class="headerlink" title="线程池常用的阻塞队列有哪些？"></a>线程池常用的阻塞队列有哪些？</h5><h5 id="线程池处理任务的流程"><a href="#线程池处理任务的流程" class="headerlink" title="线程池处理任务的流程"></a>线程池处理任务的流程</h5><h5 id="如何给线程池命名？"><a href="#如何给线程池命名？" class="headerlink" title="如何给线程池命名？"></a>如何给线程池命名？</h5><h5 id="如何设定线程池的大小？"><a href="#如何设定线程池的大小？" class="headerlink" title="如何设定线程池的大小？"></a>如何设定线程池的大小？</h5><h5 id="如何动态修改线程池的参数？"><a href="#如何动态修改线程池的参数？" class="headerlink" title="如何动态修改线程池的参数？"></a>如何动态修改线程池的参数？</h5><h5 id="如何设计一个能够根据任务的优先级来执行的线程池？"><a href="#如何设计一个能够根据任务的优先级来执行的线程池？" class="headerlink" title="如何设计一个能够根据任务的优先级来执行的线程池？"></a>如何设计一个能够根据任务的优先级来执行的线程池？</h5><blockquote><p>[!TIP]<br>待施工</p></blockquote><h3 id="IO-1"><a href="#IO-1" class="headerlink" title="&gt; IO"></a>&gt; IO</h3><h3 id="JVM"><a href="#JVM" class="headerlink" title="JVM"></a>JVM</h3><h3 id="新特性"><a href="#新特性" class="headerlink" title="新特性"></a>新特性</h3><h2 id="计算机基础"><a href="#计算机基础" class="headerlink" title="计算机基础"></a>计算机基础</h2><h3 id="计算机网络"><a href="#计算机网络" class="headerlink" title="计算机网络"></a>计算机网络</h3><h3 id="操作系统"><a href="#操作系统" class="headerlink" title="操作系统"></a>操作系统</h3><h3 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h3><h3 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h3><h2 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h2><h2 id="常用框架"><a href="#常用框架" class="headerlink" title="常用框架"></a>常用框架</h2><h2 id="系统设计"><a href="#系统设计" class="headerlink" title="系统设计"></a>系统设计</h2><h2 id="分布式"><a href="#分布式" class="headerlink" title="分布式"></a>分布式</h2><h2 id="高性能"><a href="#高性能" class="headerlink" title="高性能"></a>高性能</h2><h2 id="高可用"><a href="#高可用" class="headerlink" title="高可用"></a>高可用</h2><h3 id="前端"><a href="#前端" class="headerlink" title="前端"></a>前端</h3><h4 id="Axios"><a href="#Axios" class="headerlink" title="Axios"></a>Axios</h4><p>Axios 是一个流行的基于 Promise 的 HTTP 客户端，用于浏览器和 Node.js 环境。它使得在 JavaScript 中发送 AJAX 请求变得更加简单和便捷。<br>使用 Axios，你可以轻松地执行各种 HTTP 请求，例如 GET、POST 等，并处理响应数据。</p><h4 id="Java中session和cookie的使用"><a href="#Java中session和cookie的使用" class="headerlink" title="Java中session和cookie的使用"></a>Java中session和cookie的使用</h4><h5 id="Session简单介绍"><a href="#Session简单介绍" class="headerlink" title="Session简单介绍"></a>Session简单介绍</h5><blockquote><p>[!TIP]<br>session通常是基于cookie实现的,每一个session都会有一个sessionid保存在浏览器的cookie中</p></blockquote><p>session和cookie都是Java开发中实现会话跟踪的技术。</p><p>在WEB开发中，服务器可以为每个用户浏览器创建一个会话对象（session对象），注意：一个浏览器独占一个session对象(默认情况下)。</p><p>因此，在需要保存用户数据时，服务器程序可以把用户数据写到用户浏览器独占的session中，当用户使用浏览器访问其它程序时，其它程序可以从用户的session中取出该用户的数据，为用户服务。</p><h5 id="Cookie简单介绍"><a href="#Cookie简单介绍" class="headerlink" title="Cookie简单介绍"></a>Cookie简单介绍</h5><p>浏览器与WEB服务器之间是使用HTTP协议进行通信的，当某个用户发出页面请求时，WEB服务器只是简单的进行响应，然后就关闭与该用户的连接。<br>因此当一个请求发送到WEB服务器时，无论其是否是第一次来访，服务器都会把它当作第一次来对待，这样的不好之处可想而知。为了弥补这个缺陷，Netscape开发出了cookie这个有效的工具来保存某个用户的识别信息，因此人们昵称为“小甜饼”。</p><p>cookies是一种WEB服务器通过浏览器在访问者的硬盘上存储信息的手段：Netscape Navigator使用一个名为cookies.txt本地文件保存从所有站点接收的Cookie信息；而IE浏览器把Cookie信息保存在类似于C:\windows\cookies的目录下。当用户再次访问某个站点时，服务端将要求浏览器查找并返回先前发送的Cookie信息，来识别这个用户。</p><h5 id="⭐️Session和Cookie的主要区别"><a href="#⭐️Session和Cookie的主要区别" class="headerlink" title="⭐️Session和Cookie的主要区别"></a>⭐️Session和Cookie的主要区别</h5><p>Cookie 和 Session 都是用来跟踪浏览器用户身份的会话方式，但是两者的应用场景不太一样。</p><p>Cookie一般用来保存用户信息</p><ol><li><p>我们在 Cookie 中保存已经登录过得用户信息，下次访问网站的时候页面可以自动帮你登录的一些基本信息给填了</p></li><li><p>一般的网站都会有保持登录也就是说下次你再访问网站的时候就不需要重新登录了<br>这是因为用户登录的时候我们可以存放了一个 Token 在 Cookie 中，下次登录的时候只需要根据 Token 值来查找用户即可<br>(为了安全考虑，重新登录一般要将 Token 重写)</p></li><li><p>登录一次网站后访问网站其他页面不需要重新登录。Session 的主要作用就是通过服务端记录用户的状态。<br>典型的场景是购物车，当你要添加商品到购物车的时候，系统不知道是哪个用户操作的，因为 HTTP 协议是无状态的。<br>服务端给特定的用户创建特定的 Session 之后就可以标识这个用户并且跟踪这个用户了。</p></li></ol><p>Cookie 数据保存在客户端(浏览器端)，Session 数据保存在服务器端。</p><p>Cookie 存储在客户端中，而 Session 存储在服务器上，相对来说 Session 安全性更高。<br>如果使用 Cookie 的一些敏感信息不要写入 Cookie 中，最好能将 Cookie 信息加密然后使用到的时候再去服务器端解密。</p><h5 id="Session实现原理"><a href="#Session实现原理" class="headerlink" title="Session实现原理"></a>Session实现原理</h5><p>服务器创建session出来后，会把session的id号，以cookie的形式回写给客户机。<br>这样，只要客户机的浏览器不关，再去访问服务器时，都会带着session的id号去，服务器发现客户机浏览器带session id过来了，就会使用内存中与之对应的session为之服务。</p><h5 id="Session的创建和销毁时机"><a href="#Session的创建和销毁时机" class="headerlink" title="Session的创建和销毁时机"></a>Session的创建和销毁时机</h5><ul><li>session对象的创建</li></ul><p>在程序中第一次调用request.getSession()方法时就会创建一个新的Session，可以用isNew()方法来判断Session是不是新创建的</p><ul><li>session对象的销毁</li></ul><p>session对象默认30分钟没有使用，则服务器会自动销毁session，在web.xml文件中可以手工配置session的失效时间</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;Java&quot;&gt;&lt;a href=&quot;#Java&quot; class=&quot;headerlink&quot; title=&quot;Java&quot;&gt;&lt;/a&gt;Java&lt;/h2&gt;&lt;h3 id=&quot;Java基础概念和知识&quot;&gt;&lt;a href=&quot;#Java基础概念和知识&quot; class=&quot;headerlink&quot; ti</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>黑马点评项目记录</title>
    <link href="http://www.meprotoss.com/undefined/c6c80d57.html"/>
    <id>http://www.meprotoss.com/undefined/c6c80d57.html</id>
    <published>2024-05-06T09:17:22.000Z</published>
    <updated>2024-05-13T07:26:18.432Z</updated>
    
    <content type="html"><![CDATA[<h2 id="基于-Session-短信登录"><a href="#基于-Session-短信登录" class="headerlink" title="基于 Session 短信登录"></a>基于 Session 短信登录</h2><h3 id="发送短信验证码"><a href="#发送短信验证码" class="headerlink" title="发送短信验证码"></a>发送短信验证码</h3><p>用户提交手机号，服务器生成验证码并保存到session,然后将验证码发给用户</p><h3 id="短信验证码登录和注册"><a href="#短信验证码登录和注册" class="headerlink" title="短信验证码登录和注册"></a>短信验证码登录和注册</h3><p>用户提交手机号和验证码，服务器先校验验证码，然后根据手机号去数据库查询用户，若不存在，则创建新用户，然后保存用户信息到session</p><ul><li>前台发送的数据格式是json的样式 后台要用@RequestBody注解 实现用LoginFormDTO实体类接收</li><li>登录成功之后要把用户信息存储到session中。</li></ul><h3 id="登录校验-验证登录状态"><a href="#登录校验-验证登录状态" class="headerlink" title="登录校验(验证登录状态)"></a>登录校验(验证登录状态)</h3><p>用户请求(request)中携带cookie(cookie中带有sessionid,而登录的凭证就是sessionid就保存在cookie中)</p><p>服务器从session中获取用户 获取到之后将用户缓存到<code>ThreadLocal</code>中,方便后续的使用</p><blockquote><p>[!TIP]<br>在业务中用户的每个请求都是一个独立的线程，所以不能将用户信息保存到本地变量中，这样会出现多线程并发修改的安全问题，因此要使用ThreadLocal技术</p></blockquote><h4 id="登录拦截校验功能"><a href="#登录拦截校验功能" class="headerlink" title="登录拦截校验功能"></a>登录拦截校验功能</h4><ul><li>⚠️有有很多controller(业务)都需要校验登录状态，不能在每一个controller中都写一遍校验登录状态的业务代码，所以引入spiringmvc中的拦截器，拦截器可以在所有controller执行之前执行，将校验用户登录的流程都统一放在拦截器中</li><li>同时要注意将拦截到的用户信息传递给每一个controller的时候不能出现线程安全问题，所以用到<code>ThreadLocal</code>,让用户的每一个请求都拥有独立的线程。然后每个controller都从对应的<code>ThreadLocal</code>中取出用户即可。</li></ul><h4 id="隐藏用户敏感信息"><a href="#隐藏用户敏感信息" class="headerlink" title="隐藏用户敏感信息"></a>隐藏用户敏感信息</h4><p>在<code>/me</code>中,是从UserHolder中获取的用户信息直接返回，而UserHolder是从拦截器session中取出来的，</p><p>而session中的信息是在登录业务中存入的</p><p>这里会有两个问题：</p><p>session是tomcat的内存空间,存太多信息也会增加服务器的负担</p><p>登录校验返回的信息有些太多了，时间密码等敏感信息不需要返回。</p><ul><li>所以定义UserDTO类来简化存入session的用户信息，即在登录业务的时候将User转为UserDTO</li></ul><h4 id="基于session登录的集群的session共享问题"><a href="#基于session登录的集群的session共享问题" class="headerlink" title="基于session登录的集群的session共享问题"></a>基于session登录的集群的session共享问题</h4><p>问题：为了服务器的负载均衡，通常会配置多个tomcat服务器进行轮循访问，而多台tomcat不共享session的存储空间(每个tomcat有独立的session)，当请求切换到不同的tomcat服务器的时候会导致用户登录数据的丢失</p><p>解决方法：让session共享,且应满足：</p><ol><li>数据共享(让任何一台tomcat访问)</li><li>内存存储</li><li>key，value结构</li></ol><p>(即使用Redis代替session)</p><h4 id="Redis代替session"><a href="#Redis代替session" class="headerlink" title="Redis代替session"></a>Redis代替session</h4><h5 id="发送短信验证码业务"><a href="#发送短信验证码业务" class="headerlink" title="发送短信验证码业务"></a>发送短信验证码业务</h5><p>保存验证码到Redis，且要设置一个有效期</p><ul><li>以手机号为key(为了确保每一个手机号都有不一样的key,且有助于后面根据手机号获取验证码) 验证码为value</li></ul><h5 id="短信验证码登录、注册业务"><a href="#短信验证码登录、注册业务" class="headerlink" title="短信验证码登录、注册业务"></a>短信验证码登录、注册业务</h5><ul><li>保存用户信息到redis,key用随机token(使用UUID生成)</li><li>value是用户对象,保存对象可以使用string结构(将java对象序列化为json字符串,优点是比较直观)或hash结构(再次将value分为key和value两个部分，将对象中的每个字段独立存储,优点是可以针对单个字段做crud，且内存占用更少),所以优先推荐使用hash结构</li><li>然后需要将token作为登录凭证(使用手机号作为key的话有泄露的风险)，登录之后需要手动把生成的token返回给前端</li></ul><h5 id="token有效期的设置"><a href="#token有效期的设置" class="headerlink" title="token有效期的设置"></a>token有效期的设置</h5><ul><li>更新校验登录状态的代码（写在拦截器中），在里面设置token的更新逻辑</li></ul><h5 id="登录拦截器的优化"><a href="#登录拦截器的优化" class="headerlink" title="登录拦截器的优化"></a>登录拦截器的优化</h5><ul><li>问题1： 此时的拦截器只拦截了部分请求，所以并不是所有请求都能刷新token有效期</li></ul><p>solution：在现在的拦截器之前再加一个拦截器，在这个拦截器中拦截一切路径，但只做刷新token和保存用户信息的工作，第二个用户才做登录拦截</p><ul><li>问题2: 控制拦截器的先后顺序</li></ul><p>solution：在注册拦截器的时候添加.order</p><h2 id="商户查询缓存"><a href="#商户查询缓存" class="headerlink" title="商户查询缓存"></a>商户查询缓存</h2><h3 id="什么是缓存？-cache"><a href="#什么是缓存？-cache" class="headerlink" title="什么是缓存？(cache)"></a>什么是缓存？(cache)</h3><p>缓存就是数据交换的缓冲区，是存储数据的临时的地方，读写性能较高</p><h4 id="如何使用缓存？"><a href="#如何使用缓存？" class="headerlink" title="如何使用缓存？"></a>如何使用缓存？</h4><p>实际开发中,会构筑多级缓存来使系统运行速度进一步提升,例如:本地缓存与redis中的缓存并发使用</p><p><strong>浏览器缓存</strong>：主要是存在于浏览器端的缓存</p><p><strong>应用层缓存</strong>: 可以分为tomcat本地缓存，比如之前提到的map，或者是使用redis作为缓存</p><p><strong>数据库缓存</strong>: 在数据库中有一片空间是 buffer pool，增改查数据都会先加载到mysql的缓存中</p><p><strong>CPU缓存</strong>: 当代计算机最大的问题是 cpu性能提升了，但内存读写速度没有跟上，所以为了适应当下的情况，增加了cpu的L1，L2，L3级的缓存</p><h4 id="缓存的成本"><a href="#缓存的成本" class="headerlink" title="缓存的成本"></a>缓存的成本</h4><ul><li>数据一致性</li><li>代码维护</li><li>运维成本</li><li>硬件成本</li></ul><h3 id="添加商户缓存"><a href="#添加商户缓存" class="headerlink" title="添加商户缓存"></a>添加商户缓存</h3><h4 id="缓存模型和思路"><a href="#缓存模型和思路" class="headerlink" title="缓存模型和思路"></a>缓存模型和思路</h4><p>标准的操作方式就是查询数据库之前先查询缓存</p><p>如果缓存数据存在，则直接从缓存中返回</p><p>如果缓存数据不存在，再查询数据库，然后将数据存入redis,然后将信息返回</p><h3 id="缓存更新策略"><a href="#缓存更新策略" class="headerlink" title="缓存更新策略"></a>缓存更新策略</h3><p>缓存更新是redis为了节约内存而设计出来的一个东西，主要是因为内存数据宝贵，当我们向redis插入太多数据，此时就可能会导致缓存中的数据过多，所以redis会对部分数据进行更新，或者把他叫为淘汰更合适</p><p>常见的几个策略如下：</p><p><strong>内存淘汰：</strong>redis自动进行，当redis内存达到咱们设定的max-memery的时候，会自动触发淘汰机制，淘汰掉一些不重要的数据(可以自己设置策略方式),一致性比较差,无维护成本。</p><p><strong>超时剔除：</strong>当我们给redis设置了过期时间ttl之后，redis会将超时的数据进行删除，方便咱们继续使用缓存。一致性的强弱取决于ttl时间，一致性一般，低维护成本(只要在缓存逻辑上添加一个超时)。</p><p><strong>主动更新：</strong>我们可以手动调用方法把缓存删掉，通常用于解决缓存和数据库不一致问题。一致性好，维护成本较高。</p><p>具体选哪个方法主要看业务场景。</p><h3 id="数据库缓存不一致解决方案"><a href="#数据库缓存不一致解决方案" class="headerlink" title="数据库缓存不一致解决方案"></a>数据库缓存不一致解决方案</h3><p>由于我们的<strong>缓存的数据源来自于数据库</strong>,而数据库的<strong>数据是会发生变化的</strong>,因此,如果当数据库中<strong>数据发生变化,而缓存却没有同步</strong>,此时就会有<strong>一致性问题存在</strong>,其后果是:</p><p>用户使用缓存中的过时数据,就会产生类似多线程数据安全问题,从而影响业务,产品口碑等;怎么解决呢？有如下几种方案</p><p>Cache Aside Pattern（旁路缓存） 人工编码方式：缓存调用者在更新完数据库后再去更新缓存，也称之为双写方案✅</p><p>Read&#x2F;Write Through Pattern : 由系统本身完成，数据库与缓存的问题交由系统本身去处理</p><p>Write Behind Caching Pattern ：调用者只操作缓存，其他线程去异步处理数据库，实现最终一致</p><h3 id="数据库和缓存不一致采用什么方案"><a href="#数据库和缓存不一致采用什么方案" class="headerlink" title="数据库和缓存不一致采用什么方案"></a>数据库和缓存不一致采用什么方案</h3><p>综合考虑使用方案一，但是方案一调用者如何处理呢？这里有几个问题</p><p>操作缓存和数据库时有三个问题需要考虑：</p><p>如果采用第一个方案，那么假设我们每次操作数据库后，都操作缓存，但是中间如果没有人查询，那么这个更新动作实际上只有最后一次生效(发生了写远大于读的操作,则无效写的操作很多)，中间的更新动作意义并不大，我们可以把缓存删除，等待再次查询时，将缓存中的数据加载出来</p><ul><li><p>删除缓存还是更新缓存？</p><ul><li>更新缓存：每次更新数据库都更新缓存，无效写操作较多❎</li><li>删除缓存：更新数据库时让缓存失效，查询时再更新缓存✅</li></ul></li><li><p>如何保证缓存与数据库的操作的<strong>同时</strong>成功或失败？（保证事务的原子性）</p><ul><li>单体系统，将缓存与数据库操作放在一个事务</li><li>分布式系统，利用<code>TCC</code>(微服务内容)等分布式事务方案</li></ul></li></ul><blockquote><p>[!TIP]<br>事务的原子性是指事务中的所有操作要么全部执行成功，要么全部执行失败回滚，没有中间状态。原子性保证了事务的完整性和一致性，即事务中的所有操作要么都生效，要么都不生效，不会出现部分操作生效而部分操作失败的情况。</p></blockquote><p>应该具体操作缓存还是操作数据库，我们应当是先操作数据库，再删除缓存，原因在于，如果你选择第一种方案，在两个线程并发来访问时，假设线程1先来，他先把缓存删了，此时线程2过来，他查询缓存数据并不存在，此时他写入缓存，当他写入缓存后，线程1再执行更新动作时，实际上写入的就是旧的数据，新的数据被旧数据覆盖了。</p><ul><li>先操作缓存还是先操作数据库？(线程安全性问题)<ul><li>先删除缓存，再操作数据库</li><li>先操作数据库，再删除缓存✅(该方案的出现问题的可能性较低，因为操作数据库的时间要远长于操作缓存)</li></ul></li></ul><h3 id="缓存更新策略方案的最佳实践总结"><a href="#缓存更新策略方案的最佳实践总结" class="headerlink" title="缓存更新策略方案的最佳实践总结"></a>缓存更新策略方案的最佳实践总结</h3><h4 id="低一致性需求"><a href="#低一致性需求" class="headerlink" title="低一致性需求"></a>低一致性需求</h4><ul><li>使用Redis自带的内存淘汰机制</li></ul><h4 id="高一致性需求：主动更新，并以超时剔除作为兜底方案"><a href="#高一致性需求：主动更新，并以超时剔除作为兜底方案" class="headerlink" title="高一致性需求：主动更新，并以超时剔除作为兜底方案"></a>高一致性需求：主动更新，并以超时剔除作为兜底方案</h4><ul><li>读操作：<ul><li>缓存命中则直接返回</li><li>缓存未命中则查询数据库，并写入缓存，设定超时时间</li></ul></li><li>写操作：<ul><li>先写数据库，然后再删除缓存</li><li>要确保数据库与缓存操作的原子性</li></ul></li></ul><h3 id="缓存穿透"><a href="#缓存穿透" class="headerlink" title="缓存穿透"></a>缓存穿透</h3><p>缓存穿透 ：缓存穿透是指客户端请求的数据在缓存中和数据库中都不存在，这样缓存永远不会生效，这些请求都会打到数据库。(只要有请求那么一定会到达数据库)</p><h4 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h4><p>常见的解决方案有两种：</p><ul><li>缓存空对象<ul><li>优点：实现简单，维护方便</li><li>缺点：<ul><li>额外的内存消耗</li><li>可能造成短期的不一致</li></ul></li></ul></li><li>布隆过滤<ul><li>优点：内存占用较少，没有多余key</li><li>缺点：<ul><li>实现复杂</li><li>存在误判可能</li></ul></li></ul></li></ul><p><strong>缓存空对象思路分析：</strong>当我们客户端访问不存在的数据时，先请求redis，但是此时redis中没有数据，此时会访问到数据库，但是数据库中也没有数据，这个数据穿透了缓存，直击数据库，我们都知道数据库能够承载的并发不如redis这么高，如果大量的请求同时过来访问这种不存在的数据，这些请求就都会访问到数据库，简单的解决方案就是哪怕这个数据在数据库中也不存在，我们也把这个数据存入到redis中去，这样，下次用户过来访问这个不存在的数据，那么在redis中也能找到这个数据就不会进入到缓存了</p><p><strong>布隆过滤器：</strong>在客户端和缓存之间再添加一层布隆过滤器的拦截，请求来了之后让布隆过滤器判断这个数据是否存在，若不存在则直接返回,若存在则放行到缓存，后续的流程不变</p><p>这种方式优点在于节约内存空间，存在误判，误判原因在于：布隆过滤器是哈希思想，只要哈希思想，就可能存在哈希冲突</p><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>缓存穿透产生的原因是什么？</p><ul><li>用户请求的数据在缓存中和数据库中都不存在，不断发起这样的请求，给数据库带来巨大压力</li></ul><p>缓存穿透的解决方案有哪些？</p><p>被动方案（亡羊补牢）:</p><ul><li>缓存null值</li><li>布隆过滤</li></ul><p>主动方案（未雨绸缪）:</p><ul><li>增强id的复杂度，避免被猜测id规律</li><li>做好数据的基础格式校验</li><li>加强用户权限校验</li><li>做好热点参数的限流</li></ul><h3 id="缓存雪崩"><a href="#缓存雪崩" class="headerlink" title="缓存雪崩"></a>缓存雪崩</h3><p>缓存雪崩：缓存中的大量key同时失效或者缓存服务器Redis突然宕机，导致大量请求到达数据库，给服务器带来巨大压力</p><h4 id="解决思路"><a href="#解决思路" class="headerlink" title="解决思路"></a>解决思路</h4><ul><li>给不同的Key的TTL添加随机值(解决key同时失效)</li><li>利用Redis集群提高服务的可用性(解决Redis宕机)</li><li>给缓存业务添加降级限流策略</li><li>给业务添加多级缓存(可以在反向代理nginx等等部分也建立缓存，类似于多层防弹衣)</li></ul><h3 id="缓存击穿-热点key问题"><a href="#缓存击穿-热点key问题" class="headerlink" title="缓存击穿(热点key问题)"></a>缓存击穿(热点key问题)</h3><p>缓存击穿问题也叫热点Key问题，就是一个被高并发访问并且缓存重建业务较复杂的key突然失效了，无数的请求访问会在瞬间给数据库带来巨大的冲击(大量线程同时缓存重建)。</p><p>常见的解决方案:</p><ul><li><p>互斥锁(排队依次重建)</p></li><li><p>逻辑过期(不是真的过期 而是由程序员判断是否真的过期,本质上是设置热点key永久有效)</p></li></ul><p>方案分析：我们之所以会出现这个缓存击穿问题，<strong>主要原因是在于我们对key设置了过期时间</strong>，假设我们不设置过期时间，其实就不会有缓存击穿的问题，但是不设置过期时间，这样数据不就一直占用我们内存了吗，我们可以采用逻辑过期方案。</p><p>我们把过期时间设置在redis热点key的value中，注意：这个过期时间并不会直接作用于redis，而是我们后续通过逻辑去处理。实际流程如下:</p><p>假设线程1去查询缓存，然后从value中判断当前的数据是否过期(如果直接在缓存中未命中，则直接返回空)</p><p>如果未过期，那么直接返回信息。</p><p>如果过期了，此时线程1去尝试获得互斥锁<br>  如果获取失败了，那么代表以及有线程在缓存重建，线程1直接返回旧信息<br>  如果获取成功了，那么线程1会开启另外一个独立线程2去执行缓存重建，自己依旧返回旧信息。</p><p>假设现在线程3过来访问，由于线程线程2持有着锁，所以线程3无法获得锁，线程3也直接返回数据，只有等到新开的线程2把重建数据构建完后，其他线程才能走返回正确的数据。</p><p>这种方案巧妙在于，异步的构建缓存，缺点在于在构建完缓存之前，返回的都是脏数据。</p><h4 id="两种方案的对比"><a href="#两种方案的对比" class="headerlink" title="两种方案的对比"></a>两种方案的对比</h4><p>两种方案都是在解决缓存重建过程中的并发问题</p><p><strong>互斥锁方案：</strong> 强调一致性</p><p>由于保证了互斥性，所以数据一致，且实现简单，因为仅仅只需要加一把锁而已，也没其他的事情需要操心，所以没有额外的内存消耗，</p><p>缺点在于有锁就有死锁问题的发生，且只能串行执行性能肯定受到影响</p><p><strong>逻辑过期方案：</strong> 强调可用性</p><p>线程读取过程中不需要等，性能好，有一个额外的线程持有锁去进行重构数据，</p><p>但是在重构数据完成前，其他的线程只能返回之前的数据，且实现起来麻烦</p><h3 id="利用互斥锁解决缓存击穿问题"><a href="#利用互斥锁解决缓存击穿问题" class="headerlink" title="利用互斥锁解决缓存击穿问题"></a>利用互斥锁解决缓存击穿问题</h3><p>核心思路：相较于原来从缓存中查询不到数据后直接查询数据库而言，现在的方案是进行查询之后，如果从缓存没有查询到数据，则进行互斥锁的获取，获取互斥锁后，判断是否获得到了锁，如果没有获得到，则休眠，过一会再进行尝试，直到获取到锁为止，才能进行查询。</p><p><strong>操作锁的代码：</strong></p><p>核心思路就是利用redis的setnx方法来表示获取锁（锁其实就是redis中存储的一个key），<br>该方法含义是redis中如果没有这个key，则插入成功，返回1，在stringRedisTemplate中返回true，、如果有这个key则插入失败，则返回0，<br>在stringRedisTemplate返回false，我们可以通过true，或者是false，来表示是否有线程成功插入key，成功插入的key的线程我们认为他就是获得到锁的线程。</p><h3 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h3><p>在 Java 中，Boolean 是一个包装类，用于封装基本数据类型 boolean 的值。<br>当使用 Boolean 类型进行自动拆箱（Unboxing）时，如果 Boolean 对象的值为 null，就会触发 NullPointerException 异常。</p><p>例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Boolean</span> <span class="variable">boolObj</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"><span class="type">boolean</span> <span class="variable">boolPrimitive</span> <span class="operator">=</span> boolObj; <span class="comment">// 自动拆箱，触发 NullPointerException</span></span><br></pre></td></tr></table></figure><p>在上面的例子中，当试图将 null 的 Boolean 对象自动拆箱为基本数据类型 boolean 时，会导致 NullPointerException 异常。</p><p>为了避免这种情况，应该在进行自动拆箱之前先检查 Boolean 对象是否为 null，或者使用条件语句处理可能为 null 的情况。</p><h3 id="利用逻辑过期解决缓存击穿问题"><a href="#利用逻辑过期解决缓存击穿问题" class="headerlink" title="利用逻辑过期解决缓存击穿问题"></a>利用逻辑过期解决缓存击穿问题</h3><ul><li>添加过期时间</li></ul><p>因为现在redis中存储的数据的value需要带上过期时间，此时要么你去修改原来的实体类，但是这个方案修改了原来的代码，不符合代码的ocp(开闭原则)。</p><p>因此我们选择新建一个实体类，此时又有两种选择，一个是继承原来的shop类，优点是较为简单，但是依然需要对原来的代码进行少量修改；而另一种方案是在该类中新建一个存储数据的对象。</p><ul><li>开启缓存重建的线程的时候调用线程池</li></ul><h3 id="缓存工具封装-⭐️"><a href="#缓存工具封装-⭐️" class="headerlink" title="缓存工具封装(⭐️)"></a>缓存工具封装(⭐️)</h3><p>基于StringRedisTemplate封装一个缓存工具类，满足下列需求：</p><p>存：</p><ul><li>方法1：将<strong>任意Java对象</strong>序列化为json并存储在string类型的key中，并且可以<strong>设置TTL过期时间</strong>(往redis中存数据)</li><li>方法2：将任意Java对象序列化为json并存储在string类型的key中，并且可以<strong>设置逻辑过期时间</strong>，用于处理缓存击穿问题</li></ul><p>取：</p><ul><li>方法3：根据指定的key查询缓存，并反序列化为指定类型，利用缓存空值的方式解决缓存穿透问题</li><li>方法4：根据指定的key查询缓存，并反序列化为指定类型，需要利用逻辑过期解决缓存击穿问题</li></ul><p>方法1、3用来解决普通缓存问题；方法2、4是用来解决热点key问题的</p><h2 id="优惠券秒杀"><a href="#优惠券秒杀" class="headerlink" title="优惠券秒杀"></a>优惠券秒杀</h2><h3 id="全局唯一ID"><a href="#全局唯一ID" class="headerlink" title="全局唯一ID"></a>全局唯一ID</h3><p><strong>全局ID生成器</strong>，是一种在分布式系统下用来生成全局唯一ID的工具，一般要满足下列特性：</p><ul><li>唯一性</li><li>高可用</li><li>高性能</li><li>递增性</li><li>安全性</li></ul><h3 id="Redis实现全局唯一ID"><a href="#Redis实现全局唯一ID" class="headerlink" title="Redis实现全局唯一ID"></a>Redis实现全局唯一ID</h3><p>为了增加ID的安全性，我们可以不直接使用Redis自增的数值，而是拼接一些其它信息：</p><p>ID的组成部分(⭐️)：</p><ul><li><p>符号位：1bit，永远为0</p></li><li><p>时间戳：31bit，以秒为单位，可以使用69年</p></li><li><p>序列号：32bit，秒内的计数器，支持每秒产生2^32个不同ID</p></li></ul><p>在序列号上添加日期部分(每天一个key)可以避免序列号数量超过redis的存储上限（2^64,其实此处最多只能达到2^32，其次还可以便于基于日期部分统计每一天的下单量。)</p><h3 id="全局唯一ID的生成策略"><a href="#全局唯一ID的生成策略" class="headerlink" title="全局唯一ID的生成策略"></a>全局唯一ID的生成策略</h3><ul><li>UUID</li><li>Redis自增</li><li>snowflake(雪花)算法</li><li>数据库自增(用一张额外的表来专门实现自增)</li></ul><h3 id="优惠券-这一块细节很多，可以作为项目的难点"><a href="#优惠券-这一块细节很多，可以作为项目的难点" class="headerlink" title="优惠券(这一块细节很多，可以作为项目的难点)"></a>优惠券(这一块细节很多，可以作为项目的难点)</h3><h4 id="普通券和秒杀券"><a href="#普通券和秒杀券" class="headerlink" title="普通券和秒杀券"></a>普通券和秒杀券</h4><h4 id="库存超卖问题"><a href="#库存超卖问题" class="headerlink" title="库存超卖问题"></a>库存超卖问题</h4><h5 id="问题原因"><a href="#问题原因" class="headerlink" title="问题原因"></a>问题原因</h5><p>假设线程1过来查询库存，判断出来库存大于1，正准备去扣减库存，但是还没有来得及去扣减，此时线程2过来，线程2也去查询库存，发现这个数量一定也大于1，那么这两个线程都会去扣减库存，最终多个线程相当于一起去扣减库存，此时就会出现库存的超卖问题。</p><h5 id="解决方法-1"><a href="#解决方法-1" class="headerlink" title="解决方法"></a>解决方法</h5><p>悲观锁：认为线程安全问题一定会发生，因此在操作数据之前一定要先获取锁，确保线程串行执行</p><p>乐观锁：认为线程安全问题不一定会发生，因此不加所锁，只是在数据更新时才去判断有没有别的线程对数据进行了修改。</p><ul><li>如果没有修改则认为是安全的,自己更新数据</li><li>如果已被其他线程修改过说明发生了安全问题，此时可以重试或异常</li></ul><h5 id="乐观锁CAS法解决超卖问题"><a href="#乐观锁CAS法解决超卖问题" class="headerlink" title="乐观锁CAS法解决超卖问题"></a>乐观锁CAS法解决超卖问题</h5><p>乐观锁的关键是判断之前查询的数据是否被修改过，常见的方法有两种</p><ul><li>版本号法:简单来说就是给数据添加一个版本号字段，一旦执行修改数据的操作，那么同时就要修改版本号，修改的之前要确认此时的版本号和查询数据库的时候的版本号是否一致，一致则说明在查询和修改的这段时间内没有其他线程修改过数据,不一致则不执行操作</li><li>CAS法(compare and switch):版本号法的简化，由于每次查询和修改的时候版本号和数据数量都做了修改，那么就不用多此一举多设置一个版本号，只要在修改之前再一次比较一下当前的数量是否和查询时的数量一致即可。</li></ul><h4 id="一人一单问题"><a href="#一人一单问题" class="headerlink" title="一人一单问题"></a>一人一单问题</h4><p>只需要在秒杀业务中添加一个判断：在判断库存是否足够之后再根据优惠卷id和用户id查询是否已经下过这个订单，如果下过这个订单，则不再下单，否则进行下单。</p><p>也会出现高并发问题,需要给减库存操作和创建订单操作添加悲观锁,要注意因为是一人一单，所以只要对userid加锁，而不用对整个方法加锁；这里还有一个细节，在判断userid前后是否一致的时候，由于是一个字符串对象，所以必须要对该对象调用.intern()方法才能到字符串常量池中去找原先的对象，否则就会new一个新的对象，导致即使数值一致，但判断依然是不一致（因为是两个不同的对象）</p><h3 id="集群环境下的并发问题-syn锁失效"><a href="#集群环境下的并发问题-syn锁失效" class="headerlink" title="集群环境下的并发问题(syn锁失效)"></a>集群环境下的并发问题(syn锁失效)</h3><p>通过加锁可以解决在单机情况下的一人一单安全问题，但是在集群模式下就不行了。</p><p><strong>有关锁失效原因分析</strong>:</p><p>由于现在我们部署了多个tomcat，每个tomcat都有一个属于自己的jvm，那么假设在服务器A的tomcat内部，有两个线程，这两个线程由于使用的是同一份代码，那么他们的锁对象是同一个，是可以实现互斥的，但是如果现在是服务器B的tomcat内部，又有两个线程，但是他们的锁对象写的虽然和服务器A一样，但是锁对象却不是同一个，所以线程3和线程4可以实现互斥，但是却无法和线程1和线程2实现互斥，这就是 集群环境下，syn锁失效的原因，在这种情况下，我们就需要使用分布式锁来解决这个问题。</p><h2 id="分布式锁"><a href="#分布式锁" class="headerlink" title="分布式锁"></a>分布式锁</h2><h3 id="基本原理和实现方式"><a href="#基本原理和实现方式" class="headerlink" title="基本原理和实现方式"></a>基本原理和实现方式</h3><p>分布式锁：满足分布式系统或集群模式下<strong>多进程可见并且互斥的锁</strong>。</p><p>分布式锁的核心思想就是让大家都使用同一把锁，只要大家使用的是同一把锁，那么我们就能锁住线程，不让线程进行，让程序串行执行，这就是分布式锁的核心思路。</p><p>那么分布式锁他应该满足一些什么样的条件呢？</p><p>可见性：多个线程都能看到相同的结果，注意：这个地方说的可见性并不是并发编程中指的内存可见性，只是说多个进程之间都能感知到变化的意思</p><p>互斥：互斥是分布式锁的最基本的条件，使得程序串行执行</p><p>高可用：程序不易崩溃，时时刻刻都保证较高的可用性</p><p>高性能：由于加锁本身就让性能降低，所有对于分布式锁本身需要他就较高的加锁性能和释放锁性能</p><p>安全性：安全也是程序中必不可少的一环</p><p>常见的分布式锁有三种</p><p>Mysql：mysql本身就带有锁机制，但是由于mysql性能本身一般，所以采用分布式锁的情况下，其实使用mysql作为分布式锁比较少见</p><p>Redis：redis作为分布式锁是非常常见的一种使用方式，现在企业级开发中基本都使用redis或者zookeeper作为分布式锁，利用setnx(当我们尝试往数据库中set一个数据的时候，只有数据不存在才能set成功)这个方法，如果插入key成功，则表示获得到了锁，如果有人插入成功，其他人插入失败则表示无法获得到锁，利用这套逻辑来实现分布式锁</p><p>Zookeeper：zookeeper也是企业级开发中较好的一个实现分布式锁的方案，由于本套视频并不讲解zookeeper的原理和分布式锁的实现，所以不过多阐述</p><h3 id="Redis分布式锁的实现核心思路"><a href="#Redis分布式锁的实现核心思路" class="headerlink" title="### Redis分布式锁的实现核心思路"></a>### Redis分布式锁的实现核心思路</h3><p>实现分布式锁时需要实现的两个基本方法：</p><ul><li><p>获取锁：</p><ul><li>互斥：确保只能有一个线程获取锁</li><li>非阻塞：<strong>尝试一次</strong>，成功返回true，失败返回false</li></ul></li><li><p>释放锁：</p><ul><li>手动释放</li><li>超时释放：获取锁时添加一个超时时间,如果服务器发生了宕机或者别的意外，锁始终会自动释放，从而避免了死锁的发生</li></ul></li></ul><p>核心思路：</p><p>我们利用redis 的setNx 方法，当有多个线程进入时，我们就利用该方法，第一个线程进入时，redis 中就有这个key 了，返回了1，如果结果是1，则表示他抢到了锁，那么他去执行业务，然后再删除锁，退出锁逻辑，没有抢到锁的哥们，等待一定时间后重试即可</p><blockquote><p>[!TIP]<br>在使用自动拆箱的时候一定要记得考虑发生空指针异常的可能性。</p></blockquote><h3 id="实现分布式锁"><a href="#实现分布式锁" class="headerlink" title="实现分布式锁"></a>实现分布式锁</h3><h4 id="加锁逻辑"><a href="#加锁逻辑" class="headerlink" title="加锁逻辑"></a>加锁逻辑</h4><ul><li><p>利用setnx方法进行加锁，同时增加过期时间，防止死锁，此方法可以保证加锁和增加过期时间具有原子性</p></li><li><p>获取锁的时候还需要存入线程标识（可以用UUID表示）</p></li></ul><h4 id="释放锁的逻辑"><a href="#释放锁的逻辑" class="headerlink" title="释放锁的逻辑"></a>释放锁的逻辑</h4><ul><li>释放锁的时候要确认锁的线程标识，判断是否与当前线程标示一致,如果一致则释放锁，如果不一致则不释放</li></ul><h3 id="分布式锁的原子性问题"><a href="#分布式锁的原子性问题" class="headerlink" title="分布式锁的原子性问题"></a>分布式锁的原子性问题</h3><p>线程1现在持有锁之后，在执行业务逻辑过程中，他正准备删除锁，而且已经走到了条件判断的过程中，比如他已经拿到了当前这把锁确实是属于他自己的，正准备删除锁，但是此时他的锁到期了(发生了阻塞或其他原因导致超时自动释放)，那么此时线程2进来，但是线程1他会接着往后执行，当他卡顿结束后，他直接就会执行删除锁那行代码，相当于条件判断并没有起到作用，这就是删锁时的原子性问题，之所以有这个问题，是因为线程1的拿锁，比锁，删锁，实际上并不是原子性(一起执行，中间没有间隔)的，我们要防止刚才的情况发生，</p><h3 id="Lua脚本解决多条命令原子性问题"><a href="#Lua脚本解决多条命令原子性问题" class="headerlink" title="Lua脚本解决多条命令原子性问题"></a>Lua脚本解决多条命令原子性问题</h3><p>Redis提供了Lua脚本功能，在一个脚本中编写多条Redis命令，确保多条命令执行时的原子性。</p><p>这里重点介绍Redis提供的调用函数，语法如下：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redis.call(<span class="string">&#x27;命令名称&#x27;</span>, <span class="string">&#x27;key&#x27;</span>, <span class="string">&#x27;其它参数&#x27;</span>, ...)␍</span><br></pre></td></tr></table></figure><p>我们可以使用lua去操作redis，又能保证他的原子性，这样就可以实现拿锁比锁删锁是一个原子性动作了，作为Java程序员这一块并不作一个简单要求，并不需要大家过于精通，只需要知道他有什么作用即可。</p><h3 id="利用Java代码调用Lua脚本改造分布式锁"><a href="#利用Java代码调用Lua脚本改造分布式锁" class="headerlink" title="利用Java代码调用Lua脚本改造分布式锁"></a>利用Java代码调用Lua脚本改造分布式锁</h3><p>接下来我们来回一下我们释放锁的逻辑：</p><p>释放锁的业务流程是这样的:</p><ol><li>获取锁中的线程标示</li><li>判断是否与指定的标示（当前线程标示）一致</li><li>如果一致则释放锁（删除）</li><li>如果不一致则什么都不做</li></ol><p>最终我们操作redis的拿锁比锁删锁的lua脚本就会变成这样:</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 这里的 KEYS[1] 就是锁的key，这里的ARGV[1] 就是当前线程标示</span></span><br><span class="line"><span class="comment">-- 获取锁中的标示，判断是否与当前线程标示一致</span></span><br><span class="line"><span class="keyword">if</span> (redis.call(<span class="string">&#x27;GET&#x27;</span>, KEYS[<span class="number">1</span>]) == ARGV[<span class="number">1</span>]) <span class="keyword">then</span></span><br><span class="line">  <span class="comment">-- 一致，则删除锁</span></span><br><span class="line">  <span class="keyword">return</span> redis.call(<span class="string">&#x27;DEL&#x27;</span>, KEYS[<span class="number">1</span>])</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="comment">-- 不一致，则直接返回</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span></span><br></pre></td></tr></table></figure><p><strong>Java代码</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> DefaultRedisScript&lt;Long&gt; UNLOCK_SCRIPT;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        UNLOCK_SCRIPT = <span class="keyword">new</span> <span class="title class_">DefaultRedisScript</span>&lt;&gt;();</span><br><span class="line">        UNLOCK_SCRIPT.setLocation(<span class="keyword">new</span> <span class="title class_">ClassPathResource</span>(<span class="string">&quot;unlock.lua&quot;</span>));</span><br><span class="line">        UNLOCK_SCRIPT.setResultType(Long.class);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">unlock</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 调用lua脚本</span></span><br><span class="line">    stringRedisTemplate.execute(</span><br><span class="line">            UNLOCK_SCRIPT,</span><br><span class="line">            Collections.singletonList(KEY_PREFIX + name),</span><br><span class="line">            ID_PREFIX + Thread.currentThread().getId());</span><br><span class="line">&#125;</span><br><span class="line">经过以上代码改造后，我们就能够实现 拿锁比锁删锁的原子性动作了</span><br></pre></td></tr></table></figure><p>小总结：</p><p>基于Redis的分布式锁实现思路：</p><ul><li>利用set nx ex获取锁，并设置过期时间，保存线程标示</li><li>释放锁时先判断线程标示是否与自己一致，一致则删除锁<ul><li>特性：<ul><li>利用set nx满足互斥性</li><li>利用set ex保证故障时锁依然能释放，避免死锁，提高安全性</li><li>利用Redis集群保证高可用和高并发特性</li></ul></li></ul></li></ul><p>笔者总结：我们一路走来，利用添加过期时间，防止死锁问题的发生，但是有了过期时间之后，可能出现误删别人锁的问题，这个问题我们开始是利用删之前 通过拿锁，比锁，删锁这个逻辑来解决的，也就是删之前判断一下当前这把锁是否是属于自己的，但是现在还有原子性问题，也就是我们没法保证拿锁比锁删锁是一个原子性的动作，最后通过lua表达式来解决这个问题</p><p>但是目前还剩下一个问题锁不住，什么是锁不住呢，你想一想，如果当过期时间到了之后，我们可以给他续期一下，比如续个30s，就好像是网吧上网， 网费到了之后，然后说，来，网管，再给我来10块的，是不是后边的问题都不会发生了，那么续期问题怎么解决呢，可以依赖于我们接下来要学习redission啦</p><p><strong>测试逻辑：</strong></p><p>第一个线程进来，得到了锁，手动删除锁，模拟锁超时了，其他线程会执行lua来抢锁，当第一天线程利用lua删除锁时，lua能保证他不能删除他的锁，第二个线程删除锁时，利用lua同样可以保证不会删除别人的锁，同时还能保证原子性。</p><h2 id="分布式锁redisson"><a href="#分布式锁redisson" class="headerlink" title="分布式锁redisson"></a>分布式锁redisson</h2><p>Redisson是一个在Redis的基础上实现的Java驻内存数据网格（In-Memory Data Grid）。它不仅提供了一系列的分布式的Java常用对象，还提供了许多分布式服务，其中就包含了各种分布式锁的实现。</p><h3 id="分布式锁-redisson功能介绍"><a href="#分布式锁-redisson功能介绍" class="headerlink" title="分布式锁-redisson功能介绍"></a>分布式锁-redisson功能介绍</h3><p>基于setnx实现的分布式锁存在下面的问题：</p><p><strong>重入问题</strong>：重入问题是指获得锁的线程可以再次进入到相同的锁的代码块中，可重入锁的意义在于防止死锁，比如HashTable这样的代码中，他的方法都是使用synchronized修饰的，假如他在一个方法内，调用另一个方法，那么此时如果是不可重入的，不就死锁了吗？所以可重入锁他的主要意义是防止死锁，我们的synchronized和Lock锁都是可重入的。</p><p><strong>不可重试</strong>：是指目前的分布式只能尝试一次，我们认为合理的情况是：当线程在获得锁失败后，他应该能再次尝试获得锁。</p><p><strong>超时释放：</strong>我们在加锁时增加了过期时间，这样的我们可以防止死锁，但是如果卡顿的时间超长，虽然我们采用了lua表达式防止删锁的时候，误删别人的锁，但是毕竟没有锁住，有安全隐患</p><p><strong>主从一致性：</strong> (可简单理解为读写分离模式,主节点和从节点可能分别负责写和读的操作,这样就可以同时在多个节点上进行写和读的操作,如果主节点宕机了，那么还可以从分节点中挑一个继续作为主节点,但是主从节点之间的同步是有延迟的)如果Redis提供了主从集群(一个主节点和多个分节点)，当我们向集群写数据时，主机需要异步的将数据同步给从机，而万一在同步过去之前，主机宕机了，就会出现死锁问题。</p><h3 id="redisson-入门"><a href="#redisson-入门" class="headerlink" title="redisson 入门"></a>redisson 入门</h3><ol><li>引入依赖</li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.redisson<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>redisson<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>3.13.6<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br></pre></td></tr></table></figure><ol start="2"><li>配置Redisson客户端</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RedissonConfig</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> RedissonClient <span class="title function_">redissonClient</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">// 配置</span></span><br><span class="line">        <span class="type">Config</span> <span class="variable">config</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Config</span>();</span><br><span class="line">        config.useSingleServer().setAddress(<span class="string">&quot;redis://192.168.150.101:6379&quot;</span>)</span><br><span class="line">            .setPassword(<span class="string">&quot;123321&quot;</span>);</span><br><span class="line">        <span class="comment">// 创建RedissonClient对象</span></span><br><span class="line">        <span class="keyword">return</span> Redisson.create(config);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="number">3.</span> 使用Redisson的分布式锁</span><br><span class="line">```java</span><br><span class="line"><span class="meta">@Resource</span></span><br><span class="line"><span class="keyword">private</span> RedissionClient redissonClient;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">testRedisson</span><span class="params">()</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line">    <span class="comment">//获取锁(可重入)，指定锁的名称</span></span><br><span class="line">    <span class="type">RLock</span> <span class="variable">lock</span> <span class="operator">=</span> redissonClient.getLock(<span class="string">&quot;anyLock&quot;</span>);</span><br><span class="line">    <span class="comment">//尝试获取锁，参数分别是：获取锁的最大等待时间(期间会重试)，锁自动释放时间，时间单位</span></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">isLock</span> <span class="operator">=</span> lock.tryLock(<span class="number">1</span>,<span class="number">10</span>,TimeUnit.SECONDS);</span><br><span class="line">    <span class="comment">//判断获取锁成功</span></span><br><span class="line">    <span class="keyword">if</span>(isLock)&#123;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;执行业务&quot;</span>);          </span><br><span class="line">        &#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">            <span class="comment">//释放锁</span></span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="redisson可重入锁的原理"><a href="#redisson可重入锁的原理" class="headerlink" title="redisson可重入锁的原理"></a>redisson可重入锁的原理</h3><p>在尝试获取锁的时候，如果发现现在的锁已经被人持有，会去再判断一下持有锁的人是不是自己,如果是，那么也会获取锁，同时也会设置一个计数器来计算获取锁的次数</p><p>在Lock锁中，他是借助于底层的一个voaltile的一个state变量来记录重入的状态的，比如当前没有人持有这把锁，那么state&#x3D;0，假如有人持有这把锁，那么state&#x3D;1，如果持有这把锁的人再次持有这把锁，那么state就会+1 ，如果是对于synchronized而言，他在c语言代码中会有一个count，原理和state类似，也是重入一次就加一，释放一次就-1 ，直到减少成0 时，表示当前这把锁没有被人持有。</p><h3 id="redisson锁重试和watchdog机制"><a href="#redisson锁重试和watchdog机制" class="headerlink" title="redisson锁重试和watchdog机制"></a>redisson锁重试和watchdog机制</h3><p>看门狗机制是用来在获取锁的时候更新锁的失效时间的</p><p>为了解决基于setnx实现的分布式锁的不可重入、不可重试、超时释放和主从一致性的问题,redisson分布式锁的解决方案</p><ul><li><p>可重入：利用hash结构记录线程id和重入次数</p></li><li><p>可重试：利用信号量和PubSub功能实现等待(等待释放锁的消息)、唤醒，获取锁失败的重试机制</p></li><li><p>超时续约：利用watchDog，每隔一段时间（releaseTime &#x2F; 3），重置超时时间</p></li></ul><h3 id="redisson锁的mutilock原理"><a href="#redisson锁的mutilock原理" class="headerlink" title="redisson锁的mutilock原理"></a>redisson锁的mutilock原理</h3><p>为了提高redis的可用性，我们会搭建集群或者主从，现在以主从为例</p><p>此时我们去写命令，写在主机上， 主机会将数据同步给从机，但是假设在主机还没有来得及把数据写入到从机去的时候，此时主机宕机，哨兵会发现主机宕机，并且选举一个slave变成master，而此时新的master中实际上并没有锁信息，此时锁信息就已经丢掉了</p><p>为了解决这个问题，redission提出来了MutiLock锁，使用这把锁咱们就不使用主从了，<strong>每个节点的地位都是一样的</strong>， 这把锁加锁的逻辑需要写入到每一个主丛节点上，只有 <strong>所有的服务器都写入成功，此时才是加锁成功</strong>，假设现在某个节点挂了，那么他去获得锁的时候，只要有一个节点拿不到，都不能算是加锁成功，就保证了加锁的可靠性。</p><p>所谓的联锁，就是多个独立的锁，而每一个独立的锁就和前面的锁完全一样</p><h3 id="redisson分布式锁原理总结"><a href="#redisson分布式锁原理总结" class="headerlink" title="redisson分布式锁原理总结"></a>redisson分布式锁原理总结</h3><p>1）不可重入Redis分布式锁：</p><p>原理：利用setnx的互斥性；利用ex避免死锁；释放锁时判断线程标示</p><p>缺陷：不可重入、无法重试、锁超时失效</p><p>2）可重入的Redis分布式锁：</p><p>原理：利用hash结构，记录线程标示和重入次数；利用watchDog延续锁时间；利用信号量控制锁重试等待</p><p>缺陷：redis宕机引起锁失效问题</p><p>3）Redisson的multiLock(可看作多个可重入式锁的集合)：</p><p>原理：多个独立的Redis节点，必须在所有节点都获取重入锁，才算获取锁成功</p><p>缺陷：运维成本高、实现复杂</p><h2 id="Redis优化秒杀"><a href="#Redis优化秒杀" class="headerlink" title="Redis优化秒杀"></a>Redis优化秒杀</h2><h3 id="秒杀优化-异步秒杀思路"><a href="#秒杀优化-异步秒杀思路" class="headerlink" title="秒杀优化-异步秒杀思路"></a>秒杀优化-<strong>异步秒杀</strong>思路</h3><p>当用户发起请求，此时会请求nginx，nginx会访问到tomcat，而tomcat中的程序，会进行串行操作，分成如下几个步骤：</p><ol><li><p>查询优惠卷</p></li><li><p>判断秒杀库存是否足够</p></li><li><p>查询订单</p></li><li><p>校验是否是一人一单</p></li><li><p>扣减库存</p></li><li><p>创建订单</p></li></ol><p>优化方案：<br>们将耗时比较短的逻辑判断放入到redis中，比如是否库存足够，比如是否一人一单，这样的操作，只要这种逻辑可以完成，就意味着我们是一定可以下单完成的，我们只需要进行快速的逻辑判断，根本就不用等下单逻辑走完，我们直接给用户返回成功， 再在后台开一个线程，后台线程<strong>慢慢</strong>的去执行queue里边的消息，这样程序不就超级快了吗？而且也不用担心线程池消耗殆尽的问题，因为这里我们的程序中并没有手动使用任何线程池，当然这里边有两个难点:</p><p>第一个难点是我们怎么在redis中去快速校验一人一单，还有库存判断</p><p>第二个难点是由于我们校验和tomct下单是两个线程，那么我们如何知道到底哪个单他最后是否成功，或者是下单完成，为了完成这件事我们在redis操作完之后，我们会将一些信息返回给前端，同时也会把这些信息丢到<strong>异步queue</strong>中去，后续操作中，可以通过这个id来查询我们tomcat中的下单逻辑是否完成了</p><h3 id="redis完成秒杀资格判断"><a href="#redis完成秒杀资格判断" class="headerlink" title="redis完成秒杀资格判断"></a>redis完成秒杀资格判断</h3><h3 id="基于阻塞队列实现秒杀优化"><a href="#基于阻塞队列实现秒杀优化" class="headerlink" title="基于阻塞队列实现秒杀优化"></a>基于阻塞队列实现秒杀优化</h3><p>阻塞队列：当一个线程从队列中获取元素的时候，如果队列中有元素会返回,如果队列中没有元素则会被阻塞，直到队列中有元素才会被唤醒去获取元素。</p><blockquote><p>[!TIP]<br>@PostConstruct注解：在 Java 中，@PostConstruct 注解用于指定一个方法在构造函数执行之后、依赖注入完成之后执行。它标识了一个初始化方法，该方法会在对象的所有依赖项都注入完成后自动被调用。</p></blockquote><p>使用 @PostConstruct 注解的方法必须满足以下条件：</p><p>方法不应该有任何参数。<br>方法的返回类型应该为 void。<br>方法不能是静态的。</p><p>总结：</p><p>秒杀优化的思路：</p><ul><li>改同步下单为异步下单,将业务分为两部分，利用Redis完成下单资格(库存余量、一人一单)的判断，及时响应</li><li>具体下单的业务则放入阻塞队列,开启独立线程慢慢完成。</li></ul><p>基于阻塞队列的异步秒杀有什么问题？</p><ul><li>内存限制问题<br>  现在使用的是jdk的阻塞队列，使用的是jdk的内存，在该并发的情况下可能会有无数的订单被创建放进阻塞队列里，可能导致内存溢出的问题(OOM),虽然在创建阻塞的队列时候设置了上限,但是如果队列满了，那么有新的订单来的时候就存不进去了。</li><li>数据安全问题<br>  现在是基于内存来保存订单信息的，但是如果服务器突然宕机了，那么内存中的所有订单信息就会消失。<br>  有一个线程从队列中取出了一个订单要去执行，此时突然发生异常导致该任务执行失败，由于任务从队列中取出来就没有了，那么该任务以后再也不会被执行，导致任务丢失。</li></ul><h2 id="Redis消息队列（Message-Queue）实现异步秒杀"><a href="#Redis消息队列（Message-Queue）实现异步秒杀" class="headerlink" title="Redis消息队列（Message Queue）实现异步秒杀"></a>Redis消息队列（Message Queue）实现异步秒杀</h2><h3 id="认识消息队列"><a href="#认识消息队列" class="headerlink" title="认识消息队列"></a>认识消息队列</h3><p>什么是消息队列：字面意思就是存放消息的队列。最简单的消息队列模型包括3个角色：</p><ul><li>消息队列：存储和管理消息，也被称为消息代理（Message Broker</li><li>生产者：发送消息到消息队列</li><li>消费者：从消息队列获取消息并处理消息</li></ul><p>使用队列的好处在于 <strong>解耦：</strong>所谓解耦，举一个生活中的例子就是：快递员(生产者)把快递放到快递柜里边(Message Queue)去，我们(消费者)从快递柜里边去拿东西，这就是一个异步，如果耦合，那么这个快递员相当于直接把快递交给你，这事固然好，但是万一你不在家，那么快递员就会一直等你，这就浪费了快递员的时间，所以这种思想在我们日常开发中，是非常有必要的。</p><p>这里我们可以使用一些现成的mq，比如kafka，rabbitmq等等，但是呢，如果没有安装mq，我们也可以直接使用redis提供的mq方案，降低我们的部署和学习成本。</p><h3 id="redis-消息队列"><a href="#redis-消息队列" class="headerlink" title="redis 消息队列"></a>redis 消息队列</h3><h4 id="基于List结构模拟消息队列"><a href="#基于List结构模拟消息队列" class="headerlink" title="基于List结构模拟消息队列"></a>基于List结构模拟消息队列</h4><p>双向链表很容易模拟出队列的效果</p><p>不过要注意的是，当队列中没有消息时RPOP或LPOP操作会返回null，并不像JVM的阻塞队列那样会阻塞并等待消息。因此这里应该使用<strong>BRPOP</strong>或者<strong>BLPOP</strong>来实现阻塞效果。</p><p>基于List的消息队列有哪些优缺点？<br>优点：</p><ul><li>利用Redis存储，不受限于JVM内存上限</li><li>基于Redis的持久化机制，数据安全性有保证</li><li>可以满足消息有序性</li></ul><p>缺点</p><ul><li>无法避免消息丢失</li><li>只支持单消费者</li></ul><h4 id="基于PubSub-发布订阅-的消息队列"><a href="#基于PubSub-发布订阅-的消息队列" class="headerlink" title="基于PubSub(发布订阅)的消息队列"></a>基于PubSub(发布订阅)的消息队列</h4><p>顾名思义，消费者可以订阅一个或多个channel，生产者向对应channel发送消息后，所有订阅者都能收到相关消息。与基于list 结构的消息队列相比最大的改进就是能支持多个消费者,但是不支持数据持久化。</p><p> SUBSCRIBE channel [channel] ：订阅一个或多个频道</p><p> PUBLISH channel msg ：向一个频道发送消息</p><p> PSUBSCRIBE pattern[pattern] ：订阅与pattern(通配符)格式匹配的所有频道</p><p>基于PubSub的消息队列有哪些优缺点？<br>优点：</p><ul><li>采用发布订阅模型，支持多生产、多消费</li></ul><p>缺点：</p><ul><li>不支持数据持久化</li><li>无法避免消息丢失</li><li>消息堆积有上限，超出时数据丢失(消息不在内存中保存，当发布消息的时候，如果有消费者监听，那么消息会放在消费者客户端的缓存区域，如果在消费者处理的时间段内，又来了很多消息，那么就会导致消费者缓存区域的堆积，超出数据会丢失)</li></ul><h3 id="基于Stream的消息队列"><a href="#基于Stream的消息队列" class="headerlink" title="基于Stream的消息队列"></a>基于Stream的消息队列</h3><p>Stream 是 Redis 5.0 引入的一种新<strong>数据类型</strong>，可以实现一个功能非常完善的消息队列。</p><p>STREAM类型消息队列的XREAD命令特点：</p><ul><li>消息可回溯</li><li>一个消息可以被多个消费者读取</li><li>可以阻塞读取</li><li>有消息漏读的风险</li></ul><h3 id="基于stream的消息队列-消费者组-XREADGROUP"><a href="#基于stream的消息队列-消费者组-XREADGROUP" class="headerlink" title="基于stream的消息队列-消费者组(XREADGROUP)"></a>基于stream的消息队列-消费者组(XREADGROUP)</h3><p>STREAM类型消息队列的XREADGROUP命令特点：</p><ul><li>消息可回溯</li><li>可以多消费者争抢消息，加快消费速度</li><li>可以阻塞读取</li><li>没有消息漏读的风险</li><li>有消息确认机制，保证消息至少被消费一次</li></ul><h3 id="总结redis在秒杀场景的应用"><a href="#总结redis在秒杀场景的应用" class="headerlink" title="总结redis在秒杀场景的应用"></a>总结redis在秒杀场景的应用</h3><ul><li>缓存</li><li>分布式锁</li><li>超卖问题</li><li>lua脚本</li><li>Redis 消息队列</li></ul><h2 id="达人探店"><a href="#达人探店" class="headerlink" title="达人探店"></a>达人探店</h2><h3 id="发布探店笔记"><a href="#发布探店笔记" class="headerlink" title="发布探店笔记"></a>发布探店笔记</h3><h3 id="查看探店笔记"><a href="#查看探店笔记" class="headerlink" title="查看探店笔记"></a>查看探店笔记</h3><h3 id="点赞功能"><a href="#点赞功能" class="headerlink" title="点赞功能"></a>点赞功能</h3><p>完善点赞功能</p><p>需求：</p><ul><li>同一个用户只能点赞一次，再次点击则取消点赞</li><li>如果当前用户已经点赞，则点赞按钮高亮显示（前端已实现，判断字段Blog类的isLike属性）</li></ul><p>实现步骤：</p><ul><li>给Blog类中添加一个isLike字段，标示是否被当前用户点赞</li><li>修改点赞功能，利用Redis的set集合判断是否点赞过，未点赞过则点赞数+1，已点赞过则点赞数-1</li><li>修改根据id查询Blog的业务，判断当前登录用户是否点赞过，赋值给isLike字段</li><li>修改分页查询Blog业务，判断当前登录用户是否点赞过，赋值给isLike字段</li></ul><p>为什么采用set集合：</p><p>因为我们的数据是不能重复的。</p><h3 id="点赞排行榜-展示最先给笔记点赞的几个人"><a href="#点赞排行榜-展示最先给笔记点赞的几个人" class="headerlink" title="点赞排行榜(展示最先给笔记点赞的几个人)"></a>点赞排行榜(展示最先给笔记点赞的几个人)</h3><p>之前的点赞是放到set集合，但是set集合是不能排序的，所以这个时候，咱们可以采用一个可以排序的set集合，就是咱们的<strong>sortedSet</strong></p><p>我们接下来来对比一下这些集合的区别是什么</p><p>所有点赞的人，需要是唯一的，所以我们应当使用set或者是sortedSet</p><p>其次我们需要排序，就可以直接锁定使用sortedSet</p><h2 id="好友关注功能"><a href="#好友关注功能" class="headerlink" title="好友关注功能"></a>好友关注功能</h2><h3 id="关注和区关"><a href="#关注和区关" class="headerlink" title="关注和区关"></a>关注和区关</h3><p>针对用户的操作：可以对用户进行关注和取消关注功能。</p><p>实现思路：</p><p>需求：基于该表数据结构，实现两个接口：</p><ul><li>关注和取关接口</li><li>判断是否关注的接口</li></ul><ul><li>用户与用户之间关注的关系是一种多对多的关系，所以在数据库中专门创建一张表，设计博主id和粉丝id，用插入和删除来表示关注和取关，存在则关注，不存在则没关注。</li></ul><h3 id="共同关注"><a href="#共同关注" class="headerlink" title="共同关注"></a>共同关注</h3><p>需求：利用Redis中恰当的数据结构，实现共同关注功能。在博主个人页面展示出当前用户与博主的共同关注呢。</p><p>当然是使用我们之前学习过的set集合咯，在set集合中，有交集并集补集的api，我们可以把两人的关注的人分别放入到一个set集合中，然后再通过api去查看这两个set集合中的交集数据。</p><h3 id="关注推送"><a href="#关注推送" class="headerlink" title="关注推送"></a>关注推送</h3><p>当我们关注了用户后，这个用户发了动态，那么我们应该把这些数据推送给用户，这个需求，其实我们又把他叫做Feed流，关注推送也叫做Feed流，直译为投喂。为用户持续的提供“沉浸式”的体验，通过无限下拉刷新获取新的信息。</p><p>对于传统的模式的内容解锁：我们是需要用户去通过搜索引擎或者是其他的方式去解锁想要看的内容</p><p>对于新型的Feed流的的效果：不需要我们用户再去推送信息，而是系统分析用户到底想要什么，然后直接把内容推送给用户，从而使用户能够更加的节约时间，不用主动去寻找</p><p>Feed流的实现有两种模式：</p><p>Feed流产品有两种常见模式：<br>Timeline：不做内容筛选，简单的按照内容发布时间排序，常用于好友或关注。例如朋友圈␍</p><ul><li>优点：信息全面，不会有缺失。并且实现也相对简单</li><li>缺点：信息噪音较多，用户不一定感兴趣，内容获取效率低</li></ul><p>智能排序：利用智能算法屏蔽掉违规的、用户不感兴趣的内容。推送用户感兴趣信息来吸引用户</p><ul><li>优点：投喂用户感兴趣信息，用户粘度很高，容易沉迷␍</li><li>缺点：如果算法不精准，可能起到反作用␍<br>本例中的个人页面，是基于关注的好友来做Feed流，因此采用Timeline的模式。该模式的实现方案有三种：</li></ul><p>我们本次针对好友的操作，采用的就是Timeline的方式，只需要拿到我们关注用户的信息，然后按照时间排序即可</p><p>因此采用Timeline的模式。该模式的实现方案有三种：</p><ul><li>拉模式</li><li>推模式</li><li>推拉结合</li></ul><p><strong>拉模式</strong>：也叫做读扩散</p><p>该模式的核心含义就是：当张三和李四和王五发了消息后，都会保存在自己的邮箱中，假设赵六要读取信息，那么他会从他关注的所人的发件箱中的读取到他自己的收件箱,再进行排序</p><p>优点：比较节约空间，因为赵六在读信息时，并没有重复读取，而且读取完之后可以把他的收件箱进行清楚。</p><p>缺点：比较延迟，当用户读取数据时才去关注的人里边去读取数据，假设用户关注了大量的用户，那么此时就会拉取海量的内容，对服务器压力巨大。</p><p><strong>推模式</strong>：也叫做写扩散。(群发)</p><p>推模式是没有写邮箱的，当张三写了一个内容，此时会主动的把张三写的内容发送到他的粉丝收件箱中去，假设此时李四再来读取，就不用再去临时拉取了</p><p>优点：时效快，不用临时拉取␍</p><p>缺点：内存压力大，假设一个大V写信息，很多人关注他， 就会写很多分数据到粉丝那边去</p><p><strong>推拉结合模式</strong>：也叫做读写混合，兼具推和拉两种模式的优点。(粉丝多的用主要用拉模式，但是会主动推到活跃粉丝，粉丝少的用推模式)</p><p>推拉模式是一个折中的方案，站在发件人这一段，如果是个普通的人，那么我们采用写扩散的方式，直接把数据写入到他的粉丝中去，因为普通的人他的粉丝关注量比较小，所以这样做没有压力，如果是大V，那么他是直接将数据先写入到一份到发件箱里边去，然后再直接写一份到活跃粉丝收件箱里边去，现在站在收件人这端来看，如果是活跃粉丝，那么大V和普通的人发的都会直接写入到自己收件箱里边来，而如果是普通的粉丝，由于他们上线不是很频繁，所以等他们上线时，再从发件箱里边去拉信息。</p><h3 id="推送到粉丝收件箱"><a href="#推送到粉丝收件箱" class="headerlink" title="推送到粉丝收件箱"></a>推送到粉丝收件箱</h3><p>需求：</p><ul><li>修改新增探店笔记的业务，在保存blog到数据库的同时，推送到粉丝的收件箱</li><li>收件箱满足可以根据时间戳排序，必须用Redis的数据结构实现</li><li>查询收件箱数据时，可以实现分页查询</li></ul><p>Feed流中的数据会不断更新，所以数据的角标也在变化，因此不能采用传统的分页模式。</p><p>传统了分页在feed流是不适用的，因为我们的数据会随时发生变化</p><p>假设在t1 时刻，我们去读取第一页，此时page &#x3D; 1 ，size &#x3D; 5 ，那么我们拿到的就是10 ~ 6 这几条记录，假设现在t2时候又发布了一条记录，此时t3 时刻，我们来读取第二页，读取第二页传入的参数是page&#x3D;2 ，size&#x3D;5 ，那么此时读取到的第二页实际上是从6 开始，然后是6~2 ，那么我们就读取到了重复的数据，所以feed流的分页，不能采用原始方案来做</p><p>Feed流的滚动分页</p><p><strong>我们需要记录每次操作的最后一条，然后从这个位置开始去读取数据</strong></p><p>举个例子：我们从t1时刻开始，拿第一页数据，拿到了10~6，然后记录下当前最后一次拿取的记录，就是6，t2时刻发布了新的记录，此时这个11放到最顶上，但是不会影响我们之前记录的6，此时t3时刻来拿第二页，第二页这个时候拿数据，还是从6后一点的5去拿，就拿到了5-1的记录。我们这个地方可以采用sortedSet来做，可以进行范围查询，并且还可以记录当前获取数据时间戳最小值，就可以实现滚动分页了</p><blockquote><p>[!TIP]<br>如果在数据会发生变化的情况下，不要用list，用sortedSet</p></blockquote><h3 id="实现分页查询邮箱"><a href="#实现分页查询邮箱" class="headerlink" title="实现分页查询邮箱"></a>实现分页查询邮箱</h3><ul><li>首先不能按照角标查，必须按照score滚动分页(最大值，最小值，偏移量(第一次0 ，以后取决于上一次查询的最小值的个数)，查询的数量)</li></ul><h2 id="附近商户的功能"><a href="#附近商户的功能" class="headerlink" title="附近商户的功能"></a>附近商户的功能</h2><h3 id="GEO数据结构的基本用法"><a href="#GEO数据结构的基本用法" class="headerlink" title="GEO数据结构的基本用法"></a>GEO数据结构的基本用法</h3><p>GEO就是Geolocation的简写形式，代表地理坐标。Redis在3.2版本中加入了对GEO的支持，允许存储地理坐标信息，帮助我们根据经纬度来检索数据。常见的命令有：</p><ul><li>GEOADD：添加一个地理空间信息，包含：经度（longitude）、纬度（latitude）、值（member）</li><li>GEODIST：计算指定的两个点之间的距离并返回</li><li>GEOHASH：将指定member的坐标转为hash字符串形式并返回</li><li>GEOPOS：返回指定member的坐标</li><li>GEORADIUS：指定圆心、半径，找到该圆内包含的所有member，并按照与圆心之间的距离排序后返回。6.以后已废弃</li><li>GEOSEARCH：在指定范围内搜索member，并按照与指定点之间的距离排序后返回。范围可以是圆形或矩形。6.2.新功能</li><li>GEOSEARCHSTORE：与GEOSEARCH功能一致，不过可以把结果存储到一个指定的key。 6.2.新功能</li></ul><h3 id="将数据库中的店铺信息导入到Redis中的Geolocation"><a href="#将数据库中的店铺信息导入到Redis中的Geolocation" class="headerlink" title="将数据库中的店铺信息导入到Redis中的Geolocation"></a>将数据库中的店铺信息导入到Redis中的Geolocation</h3><p>将数据库表中的数据导入到redis中去，redis中的GEO，GEO在redis中就一个menber和一个经纬度，我们把x和y轴传入到redis做的经纬度位置去，但我们不能把所有的数据都放入到menber中去，毕竟作为redis是一个内存级数据库，如果存海量数据，redis还是力不从心，所以我们在这个地方存储他的id即可。</p><p>但是这个时候还有一个问题，就是在redis中并没有存储type，所以我们无法根据type来对数据进行筛选，<br>所以我们可以按照商户类型做分组，<strong>类型相同的商户作为同一组</strong>，<br>以typeId为key存入同一个GEO集合中</p><h2 id="用户签到功能"><a href="#用户签到功能" class="headerlink" title="用户签到功能"></a>用户签到功能</h2><h3 id="BitMap"><a href="#BitMap" class="headerlink" title="BitMap"></a>BitMap</h3><p>把每一个bit位对应当月的每一天，形成了映射关系。用0和1标示业务状态，这种思路就称为位图（BitMap）。</p><p>Redis中是利用string类型数据结构实现BitMap，因此最大上限是512M，转换为bit则是 2^32个bit位。</p><p>BitMap中常见操作指令：</p><ul><li>SETBIT：向指定位置（offset）存入一个0或1</li><li>GETBIT ：获取指定位置（offset）的bit值</li><li>BITCOUNT ：统计BitMap中值为1的bit位的数量</li><li>BITFIELD ：操作（查询、修改、自增）BitMap中bit数组中的指定位置（offset）的值,读多个比特位。</li><li>BITFIELD_RO ：获取BitMap中bit数组，并以十进制形式返回</li><li>BITOP ：将多个BitMap的结果做位运算（与 、或、异或）</li><li>BITPOS ：查找bit数组中指定范围内第一个0或1出现的位置</li></ul><h3 id="实现签到功能"><a href="#实现签到功能" class="headerlink" title="实现签到功能"></a>实现签到功能</h3><p>需求：实现签到接口，将当前用户当天签到信息保存到Redis中</p><p>思路：我们可以把年和月作为bitMap的key，然后保存到一个bitMap中，每次签到就到对应的位上把数字从0变成1，只要对应是1，就表明说明这一天已经签到了，反之则没有签到。</p><p>我们通过接口文档发现，此接口并没有传递任何的参数，没有参数怎么确实是哪一天签到呢？这个很容易，可以通过后台代码直接获取即可，然后到对应的地址上去修改bitMap。</p><h3 id="签到统计"><a href="#签到统计" class="headerlink" title="签到统计"></a>签到统计</h3><p><strong>问题1：</strong>什么叫做连续签到天数？ 从最后一次签到开始向前统计，直到遇到第一次未签到为止，计算总的签到次数，就是连续签到天数。</p><p>Java逻辑代码：获得当前这个月的最后一次签到数据，定义一个计数器，然后不停的向前统计，直到获得第一个非0的数字即可，每得到一个非0的数字计数器+1，直到遍历完所有的数据，就可以获得当前月的签到总天数了</p><p><strong>问题2：</strong>如何得到本月到今天为止的所有签到数据？</p><p>BITFIELD key GET u[dayOfMonth] 0</p><p>假设今天是10号，那么我们就可以从当前月的第一天开始，获得到当前这一天的位数，是10号，那么就是10位，去拿这段时间的数据，就能拿到所有的数据了，那么这10天里边签到了多少次呢？统计有多少个1即可。</p><p>问题3：如何从后向前遍历每个bit位？</p><p>需要让得到的10进制数字和1做与运算就可以了，因为1只有遇见1 才是1，其他数字都是0 ，我们把签到结果和1进行与操作，每与一次，<strong>就把签到结果向右移动一位</strong>，依次内推，我们就能完成逐个遍历的效果了。(优雅)</p><p>关键逻辑代码:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 6.循环遍历</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">      <span class="comment">// 6.1.让这个数字与1做与运算，得到数字的最后一个bit位 // 判断这个bit位是否为0</span></span><br><span class="line">      <span class="keyword">if</span> ((num &amp; <span class="number">1</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 如果为0，说明未签到，结束</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 如果不为0，说明已签到，计数器+1</span></span><br><span class="line">        count++;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 把数字右移一位，抛弃最后一个bit位，继续下一个bit位</span></span><br><span class="line">      num &gt;&gt;&gt;= <span class="number">1</span>;<span class="comment">//无符号右移，抛弃最后一位。</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> Result.ok(count);</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="UV统计"><a href="#UV统计" class="headerlink" title="UV统计"></a>UV统计</h2><h3 id="HyperLoglog"><a href="#HyperLoglog" class="headerlink" title="HyperLoglog"></a>HyperLoglog</h3><p>首先我们搞懂两个概念：</p><ul><li><code>UV</code>：全称Unique Visitor，也叫独立访客量，是指通过互联网访问、浏览这个网页的自然人。1天内同一个用户多次访问该网站，只记录1次。</li><li><code>PV</code>：全称Page View，也叫页面访问量或点击量，用户每访问网站的一个页面，记录1次PV，用户多次打开页面，则记录多次PV。往往用来衡量网站的流量。</li></ul><p>UV统计在服务端做会比较麻烦，因为要判断该用户是否已经统计过了，需要将统计过的用户信息保存。但是如果每个访问的用户都保存到Redis中，数据量会非常恐怖，那怎么处理呢？</p><p><code>Hyperloglog</code>(HLL)是从Loglog算法派生的概率算法，用于确定非常大的集合的基数，而不需要存储其所有值。相关算法原理可以参考：<a href="https://juejin.cn/post/6844903785744056333#heading-0">https://juejin.cn/post/6844903785744056333#heading-0</a><br>Redis中的HLL是基于string结构实现的，单个HLL的内存<strong>永远小于16kb</strong>，<strong>内存占用低</strong>的令人发指！作为代价，其测量结果是概率性的，<strong>有小于0.81％的误差</strong>。不过对于UV统计来说，这完全可以忽略。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;基于-Session-短信登录&quot;&gt;&lt;a href=&quot;#基于-Session-短信登录&quot; class=&quot;headerlink&quot; title=&quot;基于 Session 短信登录&quot;&gt;&lt;/a&gt;基于 Session 短信登录&lt;/h2&gt;&lt;h3 id=&quot;发送短信验证码&quot;&gt;&lt;a h</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Spring6启示录</title>
    <link href="http://www.meprotoss.com/undefined/38bc4ed6.html"/>
    <id>http://www.meprotoss.com/undefined/38bc4ed6.html</id>
    <published>2024-05-06T08:41:30.000Z</published>
    <updated>2024-05-07T02:56:41.230Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>[!TIP]<br>基于动力节点spring6总结</p></blockquote><h2 id="Spring启示录"><a href="#Spring启示录" class="headerlink" title="Spring启示录"></a>Spring启示录</h2><h3 id="OCP开闭原则"><a href="#OCP开闭原则" class="headerlink" title="OCP开闭原则"></a>OCP开闭原则</h3><p>在软件开发过程中应当对扩展开放，对修改关闭</p><h3 id="依赖倒置"><a href="#依赖倒置" class="headerlink" title="依赖倒置"></a>依赖倒置</h3><ul><li><p>Dependence Inversion Principle(DIP)</p></li><li><p>要倡导面向抽象编程，面向接口编程，不要面向具体编程，让上层不再依赖下层，下面改动了，上面的代码不会受到牵连。这样可以大大降低程序的耦合度，耦合度低了，扩展力就强了，同时代码复用性也会增强。（软件七大开发原则都是在为解耦合服务）</p></li><li><p>Spring框架可以帮助我们创建对象，并且可以帮助我们维护对象和对象之间的关系</p></li><li><p>Spring其实就是一个管理Bean对象的工厂</p></li></ul><h3 id="控制反转"><a href="#控制反转" class="headerlink" title="控制反转"></a>控制反转</h3><ul><li>Inversion of Control(IoC)</li></ul><p>控制反转的核心是：将对象的创建权交出去，将对象和对象之间关系的管理权交出去，由第三方容器来负责创建与维护。</p><ul><li>控制反转常见的实现方式：依赖注入（Dependency Injection，简称DI。</li></ul><h2 id="Spring概述"><a href="#Spring概述" class="headerlink" title="Spring概述"></a>Spring概述</h2><p>spring &#x3D; IOC + AOP(面向切面编程)</p><h3 id="Spring8大模块"><a href="#Spring8大模块" class="headerlink" title="Spring8大模块"></a>Spring8大模块</h3><h3 id="Spring-特点"><a href="#Spring-特点" class="headerlink" title="Spring 特点"></a>Spring 特点</h3><ol><li>轻量<br>  a. 小<br>  b. 非侵入式：Spring应用中的对象不依赖于Spring的特定类，也就是说 我们自己创建的对象不依赖spring容器</li><li>IoC</li><li>面向切面(AOP)</li><li>容器<br> Spring包含并管理应用对象的配置和生命周期，在这个意义上它是一种容器，你可以配置你的每个bean如何被创建——基于一个可配置原型（prototype），你的bean可以创建一个单独的实例或者每次需要时都生成一个新的实例——以及它们是如何相互关联的。</li><li>框架<br> Spring可以将简单的组件配置、组合成为复杂的应用。在Spring中，应用对象被声明式地组合，典型地是在一个XML文件里。Spring也提供了很多基础功能（事务管理、持久化框架集成等等），将应用逻辑的开发留给了你。</li></ol><h2 id="Spring-入门程序"><a href="#Spring-入门程序" class="headerlink" title="Spring 入门程序"></a>Spring 入门程序</h2><h3 id="第一个Spring程序"><a href="#第一个Spring程序" class="headerlink" title="第一个Spring程序"></a>第一个Spring程序</h3><ul><li><p>Spring的配置文件：beans.xml 放在类的根路径下。<br>配置文件中进行bean的配置</p><ul><li>id属性：代表对象的唯一标识。</li><li>class属性:用来指定要创建的java类的类名，这个类名必须是全限定类名（包含包名</li></ul></li><li><p>Spring是通过反射机制调用类的无参构造方法来创建对象的。</p></li></ul><h3 id="Spring6-启用Log4j2日志框架"><a href="#Spring6-启用Log4j2日志框架" class="headerlink" title="Spring6 启用Log4j2日志框架"></a>Spring6 启用Log4j2日志框架</h3><p>第一步：引入Log4j2的依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--log4j2的依赖--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.logging.log4j<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>log4j-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.19.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.logging.log4j<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>log4j-slf4j2-impl<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.19.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>第二步：在类的根路径下提供log4j2.xml配置文件（文件名固定为：log4j2.xml，文件必须放到类根路径下。）</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">loggers</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">            level指定日志级别，从低到高的优先级：</span></span><br><span class="line"><span class="comment">                ALL &lt; TRACE &lt; DEBUG &lt; INFO &lt; WARN &lt; ERROR &lt; FATAL &lt; OFF</span></span><br><span class="line"><span class="comment">        --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">root</span> <span class="attr">level</span>=<span class="string">&quot;DEBUG&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">appender-ref</span> <span class="attr">ref</span>=<span class="string">&quot;spring6log&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">root</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">loggers</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">appenders</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--输出日志信息到控制台--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">console</span> <span class="attr">name</span>=<span class="string">&quot;spring6log&quot;</span> <span class="attr">target</span>=<span class="string">&quot;SYSTEM_OUT&quot;</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--控制日志输出的格式--&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">PatternLayout</span> <span class="attr">pattern</span>=<span class="string">&quot;%d&#123;yyyy-MM-dd HH:mm:ss SSS&#125; [%t] %-3level %logger&#123;1024&#125; - %msg%n&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">console</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">appenders</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>第三步：使用日志框架</p><h2 id="四、Spring对IoC的实现"><a href="#四、Spring对IoC的实现" class="headerlink" title="四、Spring对IoC的实现"></a>四、Spring对IoC的实现</h2><h3 id="IoC控制反转"><a href="#IoC控制反转" class="headerlink" title="IoC控制反转"></a>IoC控制反转</h3><ul><li><p>控制反转是一种思想。</p></li><li><p>控制反转是为了降低程序耦合度，提高程序扩展力，达到OCP原则，达到DIP原则。</p></li><li><p>控制反转，反转的是什么？</p><ul><li><p>将对象的创建权利交出去，交给第三方容器负责。</p></li><li><p>将对象和对象之间关系的维护权交出去，交给第三方容器负责。</p></li></ul></li><li><p>控制反转这种思想如何实现呢？</p><ul><li>DI（Dependency Injection）：依赖注入</li></ul></li></ul><h3 id="IoC依赖注入"><a href="#IoC依赖注入" class="headerlink" title="IoC依赖注入"></a>IoC依赖注入</h3><p>依赖注入实现了控制反转的思想。</p><p>Spring通过依赖注入的方式来完成Bean管理的。</p><p>Bean管理说的是：Bean对象的创建，以及Bean对象中属性的赋值（或者叫做Bean对象之间关系的维护）。</p><p>依赖注入：</p><ul><li><p>依赖指的是对象和对象之间的关联关系。</p></li><li><p>注入指的是一种数据传递行为，通过注入行为来让对象和对象产生关系。</p></li></ul><p>依赖注入常见的实现方式包括两种：</p><p>set注入:基于<strong>set方法</strong>实现，底层通过反射机制调用属性对应的set方法然后给属性赋值。因此这种方法要求属性必须对外暴露set方法。</p><p>总结：set注入的核心实现原理：通过反射机制调用set方法来给属性赋值，让两个对象之间产生关系。</p><p>构造注入:通过调用<strong>构造方法</strong>来给属性赋值。</p><p>通过测试得知，通过构造方法注入的时候：</p><ul><li>可以通过下标</li><li>可以通过参数名</li><li>也可以不指定下标和参数名，可以类型自动推断。</li></ul><h3 id="p命名空间注入"><a href="#p命名空间注入" class="headerlink" title="p命名空间注入"></a>p命名空间注入</h3><p>p命名空间注入是基于setter方法的，所以需要对应的属性提供setter方法。</p><h3 id="c命名空间注入"><a href="#c命名空间注入" class="headerlink" title="c命名空间注入"></a>c命名空间注入</h3><p>c命名空间是简化构造方法注入的,需要提供构造方法</p><ul><li>注意：不管是p命名空间还是c命名空间，注入的时候都可以注入简单类型以及非简单类型。</li></ul><h3 id="util命名空间"><a href="#util命名空间" class="headerlink" title="util命名空间"></a>util命名空间</h3><p>使用util命名空间可以让配置复用。</p><h3 id="基于XML的自动装配"><a href="#基于XML的自动装配" class="headerlink" title="基于XML的自动装配"></a>基于XML的自动装配</h3><p>Spring还可以完成自动化的注入，自动化注入又被称为自动装配。它可以根据名字进行自动装配，也可以根据类型进行自动装配。</p><p>如果根据名称装配(byName)，底层会调用set方法进行注入。<br>例如：setAge() 对应的名字是age，setPassword()对应的名字是password，setEmail()对应的名字是email。</p><p>当byType进行自动装配的时候，配置文件中某种类型的Bean必须是唯一的</p><h3 id="Spring-引入外部配置文件"><a href="#Spring-引入外部配置文件" class="headerlink" title="Spring 引入外部配置文件"></a>Spring 引入外部配置文件</h3><h2 id="Bean的作用域"><a href="#Bean的作用域" class="headerlink" title="Bean的作用域"></a>Bean的作用域</h2><h3 id="单例-singleton"><a href="#单例-singleton" class="headerlink" title="单例 singleton"></a>单例 singleton</h3><p>默认情况下，Spring的IoC容器创建的Bean对象是单例的。</p><p>Bean对象的创建是在初始化Spring上下文的时候就完成的。</p><h3 id="多例-prototype"><a href="#多例-prototype" class="headerlink" title="多例 prototype"></a>多例 prototype</h3><p>如果想让Spring的Bean对象以多例的形式存在，可以在bean标签中指定scope属性的值为：prototype</p><p>scope如果没有配置，它的默认值是什么呢？默认值是singleton，单例的。</p><h3 id="其他scope"><a href="#其他scope" class="headerlink" title="其他scope"></a>其他scope</h3><h2 id="Gof-gang-of-four-之工厂模式"><a href="#Gof-gang-of-four-之工厂模式" class="headerlink" title="Gof (gang of four) 之工厂模式"></a>Gof (gang of four) 之工厂模式</h2><p>设计模式: 一种可以被重复利用的方案</p><p>工厂模式是解决对象创建问题的，所以工厂模式属于创建型设计模式。这里为什么学习工厂模式呢？这是因为Spring框架底层使用了大量的工厂模式。</p><p>GoF23种设计模式可分为三大类:</p><ul><li>创建型（5个）：解决对象创建问题。</li><li>结构型(7个)：一些类或对象组合在一起的经典结构。</li><li>行为型（11个）：解决类或对象之间的交互问题。</li></ul><h3 id="工厂模式的三种形态"><a href="#工厂模式的三种形态" class="headerlink" title="工厂模式的三种形态"></a>工厂模式的三种形态</h3><ol><li>简单工厂模式（Simple Factory）：不属于23种设计模式之一。简单工厂模式又叫做：静态 工厂方法模式。简单工厂模式是工厂方法模式的一种特殊实现。</li><li>工厂方法模式（Factory Method）：是23种设计模式之一。</li><li>抽象工厂模式（Abstract Factory）：是23种设计模式之一。</li></ol><h3 id="简单工厂模式"><a href="#简单工厂模式" class="headerlink" title="简单工厂模式"></a>简单工厂模式</h3><p>单工厂模式的角色包括三个：</p><ol><li>抽象产品角色</li><li>具体产品角色</li><li>工厂类角色</li></ol><p>抽象产品角色：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.powernode.factory;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 武器（抽象产品角色）</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> 动力节点</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> 1.0</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@className</span> Weapon</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 1.0</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Weapon</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 所有的武器都有攻击行为</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">attack</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>具体产品角色：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.powernode.factory;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 坦克（具体产品角色）</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> 动力节点</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> 1.0</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@className</span> Tank</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 1.0</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Tank</span> <span class="keyword">extends</span> <span class="title class_">Weapon</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">attack</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;坦克开炮！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.powernode.factory;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 战斗机（具体产品角色）</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> 动力节点</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> 1.0</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@className</span> Fighter</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 1.0</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Fighter</span> <span class="keyword">extends</span> <span class="title class_">Weapon</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">attack</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;战斗机投下原子弹！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.powernode.factory;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 匕首（具体产品角色）</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> 动力节点</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> 1.0</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@className</span> Dagger</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 1.0</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Dagger</span> <span class="keyword">extends</span> <span class="title class_">Weapon</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">attack</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;砍他丫的！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>工厂类角色：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.powernode.factory;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 工厂类角色</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> 动力节点</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> 1.0</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@className</span> WeaponFactory</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 1.0</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WeaponFactory</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据不同的武器类型生产武器</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> weaponType 武器类型</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 武器对象</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Weapon <span class="title function_">get</span><span class="params">(String weaponType)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (weaponType == <span class="literal">null</span> || weaponType.trim().length() == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">Weapon</span> <span class="variable">weapon</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (<span class="string">&quot;TANK&quot;</span>.equals(weaponType)) &#123;</span><br><span class="line">            weapon = <span class="keyword">new</span> <span class="title class_">Tank</span>();</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">&quot;FIGHTER&quot;</span>.equals(weaponType)) &#123;</span><br><span class="line">            weapon = <span class="keyword">new</span> <span class="title class_">Fighter</span>();</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">&quot;DAGGER&quot;</span>.equals(weaponType)) &#123;</span><br><span class="line">            weapon = <span class="keyword">new</span> <span class="title class_">Dagger</span>();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;不支持该武器！&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> weapon;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>测试程序（客户端程序）：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.powernode.factory;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> 动力节点</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> 1.0</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@className</span> Client</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 1.0</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Weapon</span> <span class="variable">weapon1</span> <span class="operator">=</span> WeaponFactory.get(<span class="string">&quot;TANK&quot;</span>);</span><br><span class="line">        weapon1.attack();</span><br><span class="line"></span><br><span class="line">        <span class="type">Weapon</span> <span class="variable">weapon2</span> <span class="operator">=</span> WeaponFactory.get(<span class="string">&quot;FIGHTER&quot;</span>);</span><br><span class="line">        weapon2.attack();</span><br><span class="line"></span><br><span class="line">        <span class="type">Weapon</span> <span class="variable">weapon3</span> <span class="operator">=</span> WeaponFactory.get(<span class="string">&quot;DAGGER&quot;</span>);</span><br><span class="line">        weapon3.attack();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="依赖注入"><a href="#依赖注入" class="headerlink" title="依赖注入"></a>依赖注入</h2><h3 id="set-注入-主要应用"><a href="#set-注入-主要应用" class="headerlink" title="set 注入(主要应用)"></a>set 注入(主要应用)</h3><ul><li><input disabled="" type="checkbox"> set注入的核心实现原理：通过反射机制调用set方法来给属性赋值，让两个对象之间产生关系。</li><li><input disabled="" type="checkbox"> property标签的name是：setUserDao()方法名演变得到的</li><li><input disabled="" type="checkbox"> 注入外部bean</li></ul><blockquote><blockquote><ul><li><input disabled="" type="checkbox"> 外部Bean的特点：bean定义到外面，在property标签中使用ref属性进行注入。通常这种方式是常用。 [ ] 注入内部bean</li></ul></blockquote></blockquote><ul><li><input disabled="" type="checkbox"> 注入简单类型</li></ul><blockquote><blockquote><ul><li><input disabled="" type="checkbox"> 如果给简单类型赋值，使用value属性或value标签。而不是ref。</li><li><input disabled="" type="checkbox"> 简单类型包括哪些呢？</li></ul></blockquote></blockquote><ul><li>基本数据类型</li><li>基本数据类型对应的包装类</li><li>String或其他的CharSequence子类</li><li>Number子类</li><li>Date子类</li><li>Enum子类</li><li>URI</li><li>URL</li><li>Temporal子类</li><li>Locale</li><li>Class</li><li>另外还包括以上简单值类型对应的数组类型<blockquote><blockquote><ul><li><input disabled="" type="checkbox"> 需要注意的是：</li></ul></blockquote></blockquote></li><li>如果把Date当做简单类型的话，日期字符串格式不能随便写。格式必须符合Date的toString()方法格式。显然这就比较鸡肋了。如果我们提供一个这样的日期字符串：2010-10-11，在这里是无法赋值给Date类型的属性的。</li><li>spring6之后，当注入的是URL，那么这个url字符串是会进行有效性检测的。如果是一个存在的url，那就没问题。如果不存在则报错。</li></ul><hr><ul><li><input disabled="" type="checkbox"> 级联属性赋值</li></ul><blockquote><blockquote><ul><li><input disabled="" type="checkbox"> 要点：</li></ul></blockquote></blockquote><ul><li><p>在spring配置文件中，如上，注意顺序。</p></li><li><p>在spring配置文件中，clazz属性必须提供getter方法。</p></li><li><p><input disabled="" type="checkbox"> 注入数组<br>要点：</p></li><li><p>如果数组中是简单类型，使用value标签。</p></li><li><p>如果数组中是非简单类型，使用ref标签。</p></li><li><p><input disabled="" type="checkbox"> 注入list集合(有序可重复)</p><ul><li>同上，只要把array标签改为list</li><li>注意：注入List集合的时候使用list标签，如果List集合中是简单类型使用value标签，反之使用ref标签。</li></ul></li><li><p><input disabled="" type="checkbox"> 注入set集合(无序不可重复)</p><ul><li><p>使用<code>&lt;set&gt;</code>标签</p></li><li><p>set集合中元素是简单类型的使用value标签，反之使用ref标签。</p></li><li><p><input disabled="" type="checkbox"> 注入map集合<br>要点：</p></li><li><p>使用<code>&lt;map&gt;</code>标签</p></li><li><p>如果key是简单类型，使用 key 属性，反之使用 key-ref 属性。</p></li><li><p>如果value是简单类型，使用 value 属性，反之使用 value-ref 属性。</p></li><li><p><input disabled="" type="checkbox"> p命名空间注入</p></li></ul><p>使用p命名空间注入的前提条件包括两个：</p><ul><li><p>第一：在XML头部信息中添加p命名空间的配置信息：xmlns:p&#x3D;”<a href="http://www.springframework.org/schema/p">http://www.springframework.org/schema/p</a>“</p></li><li><p>第二：p命名空间注入是基于setter方法的，所以需要对应的属性提供setter方法。</p></li><li><p><input disabled="" type="checkbox"> c命名空间注入</p></li></ul><p>c命名空间是简化构造方法注入的。</p><ul><li><p>使用c命名空间的两个前提条件：<br>第一：需要在xml配置文件头部添加信息：xmlns:c&#x3D;”<a href="http://www.springframework.org/schema/c">http://www.springframework.org/schema/c</a>“</p></li><li><p>第二：需要提供构造方法。</p></li><li><p><input disabled="" type="checkbox"> util 命名空间</p></li><li><p>使用util命名空间可以让配置复用。</p></li></ul></li></ul><h3 id="构造注入"><a href="#构造注入" class="headerlink" title="构造注入"></a>构造注入</h3><ul><li><p><input disabled="" type="checkbox"> 通过测试得知，通过构造方法注入的时候</p></li><li><p>可以通过下标</p></li><li><p>可以通过参数名</p></li><li><p>也可以不指定下标和参数名，可以类型自动推断。</p></li><li><p>spring在装配方面做的还是比较健壮的</p></li></ul><h3 id="基于XML的自动装配-1"><a href="#基于XML的自动装配-1" class="headerlink" title="基于XML的自动装配"></a>基于XML的自动装配</h3><ul><li><p><input disabled="" type="checkbox"> 根据名称自动装配</p></li><li><p>Spring还可以完成自动化的注入，自动化注入又被称为自动装配。它可以根据名字进行自动装配，也可以根据类型进行自动装配</p></li><li><p>这说明，如果根据名称装配(byName)，底层会调用set方法进行注入。<br>例如：setAge() 对应的名字是age，setPassword()对应的名字是password，setEmail()对应的名字是email。</p></li><li><p><input disabled="" type="checkbox"> 根据类型自动装配</p></li><li><p>配置文件中某种类型的Bean必须是唯一的，不能出现多个。</p></li></ul><h3 id="spring引入外部属性配置文件"><a href="#spring引入外部属性配置文件" class="headerlink" title="spring引入外部属性配置文件"></a>spring引入外部属性配置文件</h3><h3 id="Bean的作用域-1"><a href="#Bean的作用域-1" class="headerlink" title="Bean的作用域"></a>Bean的作用域</h3><ul><li><p><input disabled="" type="checkbox"> Spring的IoC容器中，默认情况下，Bean对象是单例的</p></li><li><p><input disabled="" type="checkbox"> 默认情况下，Bean对象的创建是在初始化Spring上下文的时候就完成的</p></li><li><p><input disabled="" type="checkbox"> 如果想让Spring的Bean对象以多例的形式存在，可以在bean标签中指定scope属性的值为：prototype，<strong>这样Spring会在每一次执行getBean()方法的时候创建Bean对象</strong>，调用几次则创建几次。</p></li><li><p>scope属性的值不止两个，它一共包括8个选项：</p></li><li><p>singleton：默认的，单例。</p></li><li><p>prototype：原型。每调用一次getBean()方法则获取一个新的Bean对象。或每次注入的时候都是新对象。</p></li><li><p>request：一个请求对应一个Bean。仅限于在WEB应用中使用。</p></li><li><p>session：一个会话对应一个Bean。仅限于在WEB应用中使用。</p></li><li><p>global session：portlet应用中专用的。如果在Servlet的WEB应用中使用global session的话，和session一个效果。（portlet和servlet都是规范。servlet运行在servlet容器中，例如Tomcat。portlet运行在portlet容器中。）</p></li><li><p>application：一个应用对应一个Bean。仅限于在WEB应用中使用。</p></li><li><p>websocket：一个websocket生命周期对应一个Bean。仅限于在WEB应用中使用。</p></li><li><p>自定义scope：很少使用。</p></li></ul><h3 id="Gof-FactoryMode-工厂模式"><a href="#Gof-FactoryMode-工厂模式" class="headerlink" title="Gof FactoryMode 工厂模式"></a>Gof FactoryMode 工厂模式</h3><ul><li><input disabled="" type="checkbox"> 简单工厂模式</li></ul><blockquote><blockquote><ul><li><input disabled="" type="checkbox"> 简单工厂模式的优点：</li></ul></blockquote></blockquote><ul><li><p>客户端程序不需要关心对象的创建细节，需要哪个对象时，只需要向工厂索要即可，初步实现了责任的分离。客户端只负责“消费”，工厂负责“生产”。生产和消费分离。</p><blockquote><blockquote><ul><li><input disabled="" type="checkbox"> 简单工厂模式的缺点：</li></ul></blockquote></blockquote></li><li><p>缺点1：工厂类集中了所有产品的创造逻辑，形成一个无所不知的全能类，有人把它叫做上帝类。显然工厂类非常关键，不能出问题，一旦出问题，整个系统瘫痪。</p></li><li><p>缺点2：不符合OCP开闭原则，在进行系统扩展时，需要修改工厂类。Spring中的BeanFactory就使用了简单工厂模式。</p></li><li><p><input disabled="" type="checkbox"> 工厂方法模式</p></li></ul><blockquote><blockquote><ul><li><input disabled="" type="checkbox"> 工厂方法模式既保留了简单工厂模式的优点，同时又解决了简单工厂模式的缺点。<br>工厂方法模式的角色包括：</li></ul></blockquote></blockquote><ul><li>抽象工厂角色</li><li>具体工厂角色</li><li>抽象产品角色</li><li>具体产品角色</li></ul><h2 id="Bean的实例化方式"><a href="#Bean的实例化方式" class="headerlink" title="Bean的实例化方式"></a>Bean的实例化方式</h2><h3 id="1-构造方法"><a href="#1-构造方法" class="headerlink" title="1. 构造方法"></a>1. 构造方法</h3><ul><li><input disabled="" type="checkbox"> 在配置文件中配置类的全路径，spirng直接调用该类的无参构造方法获取bean对象</li></ul><h3 id="2-简单工厂模式"><a href="#2-简单工厂模式" class="headerlink" title="2. 简单工厂模式"></a>2. 简单工厂模式</h3><ul><li><input disabled="" type="checkbox"> 通过简单工厂模式，调用<code>工厂</code>的静态方法<code>get()</code>获取bean对象</li><li><input disabled="" type="checkbox"> 工厂类里的方法是静态方法，所以不需要spring工厂的实例</li></ul><h3 id="3-通过factory-bean实例化-本质上是工厂方法模式"><a href="#3-通过factory-bean实例化-本质上是工厂方法模式" class="headerlink" title="3. 通过factory-bean实例化(本质上是工厂方法模式)"></a>3. 通过factory-bean实例化(本质上是工厂方法模式)</h3><ul><li><input disabled="" type="checkbox"> 工厂类里的方法是非静态方法，所工厂类也必须被spring管理起来</li><li><input disabled="" type="checkbox"> 标签也要多一个 因为得告诉spring是创建哪个<code>工厂</code> 的 哪个<code>对象</code><br>所以得指定哪个对象(factory-bean)的哪个方法(factory-method)</li></ul><h3 id="4-通过FactoryBean接口实例化"><a href="#4-通过FactoryBean接口实例化" class="headerlink" title="4. 通过FactoryBean接口实例化"></a>4. 通过FactoryBean接口实例化</h3><ul><li><input disabled="" type="checkbox"> 只要实现接口和接口的抽象方法 就可以不需要指定factory-bean 和<br>factory-method。是对第三种方法的简化</li><li><input disabled="" type="checkbox"> 因为实现了接口所以直接认为你这个类的对象就是一个豆子<br>td因为实现了接口所以直接认为你这个类的对象就是一个豆子</li></ul><h3 id="BeanFactory-和-FactoryBean-的区别"><a href="#BeanFactory-和-FactoryBean-的区别" class="headerlink" title="BeanFactory 和 FactoryBean 的区别"></a>BeanFactory 和 FactoryBean 的区别</h3><ul><li><p><input disabled="" type="checkbox"> BeanFactory</p></li><li><p>Spring IoC容器的顶级对象，BeanFactory被翻译为“Bean工厂”，在Spring的IoC容器中，“Bean工厂”负责创建Bean对象。<br>BeanFactory是工厂。</p></li><li><p><input disabled="" type="checkbox"> FactoryBean</p></li><li><p>它是一个<strong>Bean</strong>，是一个能够辅助Spring实例化其它Bean对象的一个Bean。<br>在Spring中，Bean可以分为两类：<br>● 第一类：普通Bean<br>● 第二类：工厂Bean（记住：工厂Bean也是一种Bean，只不过这种Bean比较特殊，它可以辅助Spring实例化其它Bean对象。）</p></li></ul><h3 id="注入自定义-Date-工厂Bean的实际应用"><a href="#注入自定义-Date-工厂Bean的实际应用" class="headerlink" title="注入自定义 Date (工厂Bean的实际应用)"></a>注入自定义 Date (工厂Bean的实际应用)</h3><h3 id="Bean-的生命周期-可分为5步7步10步-也就是bean对象从开始创建到消亡的整个过程"><a href="#Bean-的生命周期-可分为5步7步10步-也就是bean对象从开始创建到消亡的整个过程" class="headerlink" title="Bean 的生命周期(可分为5步7步10步)(也就是bean对象从开始创建到消亡的整个过程)"></a>Bean 的生命周期(可分为5步7步10步)(也就是bean对象从开始创建到消亡的整个过程)</h3><ul><li><input disabled="" type="checkbox"> 当想在具体某个生命周期做指定操作时可以用到</li><li>第一步：实例化Bean</li><li>第二步：Bean属性赋值</li><li>第三步：初始化Bean 需要手动指定 使用init-method标签<br>** bean后处理器的before方法</li><li>第四步：使用Bean<br>** bean后处理器的after方法</li><li>第五步：销毁Bean 使用手动指定 用destory-method标签</li></ul><h3 id="Bean的作用域不同，管理方式不同"><a href="#Bean的作用域不同，管理方式不同" class="headerlink" title="Bean的作用域不同，管理方式不同"></a>Bean的作用域不同，管理方式不同</h3><ul><li>对于singleton作用域的Bean，Spring 能够精确地知道该Bean何时被创建，何时初始化完成，以及何时被销毁；</li><li>而对于 prototype 作用域的 Bean，Spring 只负责创建，当容器创建了<br>Bean 的实例后，Bean 的实例就交给客户端代码管理，Spring 容器将不再跟踪其生命周期。</li></ul><h3 id="自己new的对象可以让Spring管理"><a href="#自己new的对象可以让Spring管理" class="headerlink" title="自己new的对象可以让Spring管理"></a>自己new的对象可以让Spring管理</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RegisterBeanTest</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testBeanRegister</span><span class="params">()</span>&#123;</span><br><span class="line">      <span class="comment">// 自己new的对象</span></span><br><span class="line">      <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>();</span><br><span class="line">      System.out.println(user);</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 创建 默认可列表BeanFactory 对象</span></span><br><span class="line">      <span class="type">DefaultListableBeanFactory</span> <span class="variable">factory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DefaultListableBeanFactory</span>();</span><br><span class="line">      <span class="comment">// 注册Bean</span></span><br><span class="line">      factory.registerSingleton(<span class="string">&quot;userBean&quot;</span>, user);</span><br><span class="line">      <span class="comment">// 从spring容器中获取bean</span></span><br><span class="line">      <span class="type">User</span> <span class="variable">userBean</span> <span class="operator">=</span> factory.getBean(<span class="string">&quot;userBean&quot;</span>, User.class);</span><br><span class="line">      System.out.println(userBean);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="Bean的循环依赖问题"><a href="#Bean的循环依赖问题" class="headerlink" title="Bean的循环依赖问题"></a>Bean的循环依赖问题</h2><h3 id="singleton-set注入"><a href="#singleton-set注入" class="headerlink" title="singleton + set注入"></a><code>singleton</code> + set注入</h3><p>循环依赖没有问题,解决方法如下:</p><ul><li><input disabled="" type="checkbox"> spring容器一旦将bean创建出来就立刻进行<code>曝光</code><br>(不赋值就告诉大家我可以被使用啦！！)</li><li><input disabled="" type="checkbox"> 曝光之后再进行赋值</li></ul><h3 id="prototype-set注入"><a href="#prototype-set注入" class="headerlink" title="prototype + set注入"></a><code>prototype</code> + set注入</h3><ul><li><input disabled="" type="checkbox"> 当循环依赖的 <strong>所有</strong> Bean的scope&#x3D;”prototype”的时候，产生的循环依赖，Spring是无法解决的，会出现BeanCurrentlyInCreationException异常。<blockquote><blockquote><ul><li><input disabled="" type="checkbox"> new ClassPathApplicationContext的时候不会new对象<br>，只有在getBean的时候才会创建对象,会无限递归</li></ul></blockquote></blockquote></li><li><input disabled="" type="checkbox"> 当循环依赖的一个是单例时，就不会出现问题</li></ul><h3 id="singleton-prototype-构造注入"><a href="#singleton-prototype-构造注入" class="headerlink" title="singleton&#x2F;prototype+ 构造注入"></a><code>singleton</code>&#x2F;<code>prototype</code>+ 构造注入</h3><ul><li><input disabled="" type="checkbox"> 有异常，因为创建对象和给属性赋值是同时进行的，不给属性赋值对象就创建不出来</li></ul><h3 id="Spring解决循环依赖的机理"><a href="#Spring解决循环依赖的机理" class="headerlink" title="Spring解决循环依赖的机理"></a>Spring解决循环依赖的机理</h3><ul><li><input disabled="" type="checkbox"> Spring只能解决setter方法注入的单例bean之间的循环依赖。<br>ClassA依赖ClassB，ClassB又依赖ClassA，形成依赖闭环。<br>Spring在创建ClassA对象后，不需要等给属性赋值，直接将其曝光到bean缓存当中。在解析ClassA的属性时，又发现依赖于ClassB，再次去获取ClassB，当解析ClassB的属性时，又发现需要ClassA的属性，但此时的ClassA已经被提前曝光加入了正在创建的bean的缓存中，则无需创建新的的ClassA的实例，直接从缓存中获取即可。从而解决循环依赖问题。</li></ul><h2 id="回顾反射机制"><a href="#回顾反射机制" class="headerlink" title="回顾反射机制"></a>回顾反射机制</h2><h3 id="方法调用的四个要素"><a href="#方法调用的四个要素" class="headerlink" title="方法调用的四个要素"></a>方法调用的四个要素</h3><ul><li>哪个对象 </li><li>哪个方法 </li><li>哪个参数</li><li>返回什么值</li></ul><h2 id="全注解式开发"><a href="#全注解式开发" class="headerlink" title="全注解式开发"></a>全注解式开发</h2><h3 id="负责声明bean的注解"><a href="#负责声明bean的注解" class="headerlink" title="负责声明bean的注解"></a>负责声明bean的注解</h3><ul><li>@Component</li><li>@Controller</li><li>@Service</li><li>@Repository</li></ul><p>@Controller、@Service、@Repository这三个注解都是@Component注解的别名。其实这四个注解的功能一样，但是为了增强程序的可读性</p><ul><li>控制器类上使用：Controller</li><li>service类上使用：Service</li><li>dao类上使用：Repository</li></ul><p>他们都是只有一个value属性。value属性用来指定bean的id，也就是bean的名字。</p><h3 id="spring注解的使用"><a href="#spring注解的使用" class="headerlink" title="spring注解的使用"></a>spring注解的使用</h3><ol><li>加入AOP依赖(一般会加入spring-context依赖后会关联加入，所以这一步不用做)</li><li>配置文件中配置context命名空间</li><li>配置包扫描</li><li>Bean上使用注解</li></ol><blockquote><p>[!TIP]<br>如果注解的属性名是value，那么可以省略<br>  如果把value属性彻底去掉，spring会被Bean自动取名，并且默认名字的规律是：Bean类名首字母小写后面不变。</p></blockquote><p>如果是多个包怎么办？有两种解决方案：</p><ul><li>第一种：在配置文件中指定多个包，用逗号隔开。</li><li>第二种：指定多个包的共同父包。</li></ul><h3 id="选择性实例化Bean"><a href="#选择性实例化Bean" class="headerlink" title="选择性实例化Bean"></a>选择性实例化Bean</h3><p>假设在某个包下有很多Bean，有的Bean上标注了Component，有的标注了Controller，有的标注了Service，有的标注了Repository，现在由于某种特殊业务的需要，只允许其中所有的Controller参与Bean管理</p><ul><li>修改配置文件就行，用到再去查</li></ul><h3 id="负责注入的注解"><a href="#负责注入的注解" class="headerlink" title="负责注入的注解"></a>负责注入的注解</h3><p>@Component @Controller @Service @Repository 这四个注解是用来<strong>声明</strong>Bean的，声明后这些Bean将被实例化。接下来我们看一下，如何给Bean的属性赋值。给Bean属性<strong>赋值</strong>需要用到这些注解：</p><ul><li><p>@Value 负责注入简单类型</p><ul><li>@Value注解可以直接使用在属性上，也可以使用在setter方法上,以及构造方法的形参上。</li><li>为了简化代码，以后我们一般不提供setter方法，直接在属性上使用@Value注解完成属性赋值。</li></ul></li><li><p>@Autowired 单独使用@Autowired注解，默认根据类型装配。【默认是byType】</p><ul><li>@Autowired注解可以用来注入非简单类型。被翻译为：自动连线的，或者自动装配。单独使用@Autowired注解，默认根据类型装配。【默认是byType】</li><li>当有参数的构造方法只有一个时，@Autowired注解可以省略。如果有多个构造方法，@Autowired肯定是不能省略的。</li><li>可以直接使用在属性上，也可以使用在setter方法上,以及构造方法、构造方法参数上</li></ul></li><li><p>如一个要装配的接口有不止一个实现类，则配合@Qualified使用才能byName进行装配</p></li><li><p>@Resource注解默认根据属性名进行装配。</p><ul><li>@Resource注解也可以完成非简单类型注入。</li><li>与@Autowired注解的区别：<ul><li>@Resource注解是JDK扩展包中的，也就是说属于JDK的一部分。所以该注解是标准注解，更加具有通用性。</li><li>@Autowired注解是Spring框架自己的。</li><li>@Resource注解默认根据名称装配byName，未指定name时，使用属性名作为name。通过name找不到的话会自动启动通过类型byType装配。</li><li>@Resource注解用在属性上、setter方法上。</li><li>@Autowired注解用在属性上、setter方法上、构造方法上、构造方法参数上。</li></ul></li></ul></li></ul><h2 id="GOF代理模式"><a href="#GOF代理模式" class="headerlink" title="GOF代理模式"></a>GOF代理模式</h2><h3 id="对代理模式的理解"><a href="#对代理模式的理解" class="headerlink" title="对代理模式的理解"></a>对代理模式的理解</h3><p>代理模式中有一个非常重要的特点：对于客户端程序来说，使用代理对象时就像在使用目标对象一样。【在程序中，目标需要被保护时】</p><p>代理模式是GoF23种设计模式之一。属于结构型设计模式。</p><p>代理模式的作用是：为其他对象提供一种代理以控制对这个对象的访问。在某些情况下，一个客户不想或者不能直接引用一个对象，此时可以通过一个称之为“代理”的第三者来实现间接引用。代理对象可以在客户端和目标对象之间起到<strong>中介</strong>的作用，并且可以通过代理对象去掉客户不应该看到的内容和服务或者添加客户需要的额外服务。 通过<strong>引入一个新的对象</strong>来实现对真实对象的操作或者将新的对象作为真实对象的一个替身，这种实现机制即为代理模式，<strong>通过引入代理对象来间接访问一个对象</strong>，这就是代理模式的模式动机。<br>代理模式中的角色：</p><ul><li>代理类（代理主题）</li><li>目标类（真实主题）</li><li>代理类和目标类的公共接口（抽象主题）：客户端在使用代理类时就像在使用目标类，不被客户端所察觉，所以代理类和目标类要有共同的行为，也就是实现共同的接口。</li></ul><h3 id="动态代理"><a href="#动态代理" class="headerlink" title="动态代理"></a>动态代理</h3><p>在内存当中动态生成类的技术常见的包括：</p><ul><li>JDK动态代理技术：只能代理接口。</li><li>CGLIB动态代理技术：CGLIB(Code Generation Library)是一个开源项目。是一个强大的，高性能，高质量的Code生成类库，它可以在运行期扩展Java类与实现Java接口。它既可以代理接口，又可以代理类，底层是通过<strong>继承</strong>的方式实现的,因此被代理的目标类不能用<code>final</code>修饰。性能比JDK动态代理要好。（底层有一个小而快的字节码处理框架ASM。）</li><li>Javassist动态代理技术：Javassist是一个开源的分析、编辑和创建Java字节码的类库。是由东京工业大学的数学和计算机科学系的 Shigeru Chiba （千叶 滋）所创建的。它已加入了开放源代码JBoss 应用服务器项目，通过使用Javassist对字节码操作为JBoss实现动态”AOP”框架。</li></ul><h3 id="静态代理和动态代理的区别"><a href="#静态代理和动态代理的区别" class="headerlink" title="静态代理和动态代理的区别"></a>静态代理和动态代理的区别</h3><p>静态代理和动态代理都是在面向对象编程中常见的设计模式，它们都允许一个对象在另一个对象的基础上提供额外的功能。它们的主要区别在于代理类的创建时间和绑定方式。</p><ol><li>静态代理：<br>静态代理是在编译时就已经确定了的代理关系。在静态代理中，代理类在编译期间就已经创建好，并且代理类和被代理类的关系在编译时确定，不能动态改变。</li></ol><p>特点：<br>代理类和被代理类在编译期间确定。<br>需要为每一个被代理类编写一个对应的代理类。<br>编译时就已确定代理关系，不灵活。</p><ol start="2"><li>动态代理：<br>动态代理是在运行时创建的代理对象，代理类在程序运行时动态生成，而不是在编译期间确定。Java 中的动态代理主要是通过 java.lang.reflect.Proxy 类来实现。</li></ol><p>特点：<br>代理类是在运行时动态生成的。<br>不需要为每一个被代理类编写一个对应的代理类，可以通过反射机制动态处理。<br>在运行时可以动态改变代理关系，更加灵活。</p><p>应用场景：</p><ul><li>静态代理： 适用于被代理类较少且不需要频繁变更代理关系的情况，比如安全检查、日志记录等。</li><li>动态代理： 适用于被代理类较多或者代理关系需要经常变更的情况，比如 AOP（面向切面编程）、RPC（远程过程调用）等。</li></ul><p>总的来说，动态代理相对于静态代理更加灵活，因为它允许在运行时动态生成代理对象，而无需在编译时确定。这使得动态代理在一些需要动态管理和调整代理关系的场景下更为实用。</p><h2 id="面向切面编程的AOP-Aspect-Oriented-Programming"><a href="#面向切面编程的AOP-Aspect-Oriented-Programming" class="headerlink" title="面向切面编程的AOP(Aspect Oriented Programming)"></a>面向切面编程的AOP(Aspect Oriented Programming)</h2><ul><li>AOP底层使用的是动态代理实现</li><li>Spring的AOP使用的动态代理是：JDK动态代理 + CGLIB动态代理技术。Spring在这两种动态代理中灵活切换，如果是代理接口，会默认使用JDK动态代理，如果要代理某个类，这个类没有实现接口，就会切换使用CGLIB</li></ul><h3 id="AOP介绍"><a href="#AOP介绍" class="headerlink" title="AOP介绍"></a>AOP介绍</h3><p>一般一个系统当中都会有一些系统服务，例如：日志、事务管理、安全等。这些系统服务被称为：交叉业务</p><p>如果在每一个业务处理过程当中，都掺杂这些交叉业务代码进去的话，存在两方面问题：</p><ul><li><p>第一：交叉业务代码在多个业务流程中反复出现，显然这个交叉业务代码没有得到复用。并且修改这些交叉业务代码的话，需要修改多处。</p></li><li><p>第二：程序员无法专注核心业务代码的编写，在编写核心业务代码的同时还需要处理这些交叉业务。</p></li><li><p>用一句话总结AOP：将与核心业务无关的代码独立的抽取出来，形成一个独立的组件，然后以横向交叉的方式应用到业务流程当中的过程被称为AOP。</p></li></ul><p>AOP的优点:</p><ul><li>第一：代码复用性增强。</li><li>第二：代码易维护。</li><li>第三：使开发者更关注业务逻辑。</li></ul><h3 id="AOP七大术语"><a href="#AOP七大术语" class="headerlink" title="AOP七大术语"></a>AOP七大术语</h3><ul><li><p><input disabled="" type="checkbox"> 切面：程序中和业务逻辑没有关系的通用代码(交叉业务)</p><ul><li><p><input disabled="" type="checkbox"> 连接点 Joinpoint</p><blockquote><blockquote><ul><li><input disabled="" type="checkbox"> 在程序的整个执行流程中，可以织入切面的位置。方法的执行前后，异常抛出之后等位置。</li></ul></blockquote></blockquote></li><li><p><input disabled="" type="checkbox"> 切点 Pointcut</p><blockquote><blockquote><ul><li><input disabled="" type="checkbox"> 在程序执行流程中，真正织入切面的方法。（一个切点对应多个连接点）</li></ul></blockquote></blockquote></li><li><p><input disabled="" type="checkbox"> 通知 Advice</p><blockquote><blockquote><ul><li><input disabled="" type="checkbox"> 通知又叫增强，就是具体你要织入的代码。</li></ul></blockquote></blockquote></li><li><p><input disabled="" type="checkbox"> 切面Aspect</p><blockquote><blockquote><ul><li><input disabled="" type="checkbox"> 切点 + 通知就是切面。</li></ul></blockquote></blockquote></li><li><p><input disabled="" type="checkbox"> 织入 Weaving</p><blockquote><blockquote><ul><li><input disabled="" type="checkbox"> 把通知应用到目标对象上的过程。</li></ul></blockquote></blockquote></li><li><p><input disabled="" type="checkbox"> 代理对象 Proxy</p><blockquote><blockquote><ul><li><input disabled="" type="checkbox"> 一个目标对象被织入通知后产生的新对象。</li></ul></blockquote></blockquote></li><li><p><input disabled="" type="checkbox"> 目标对象 Target</p><blockquote><blockquote><ul><li><input disabled="" type="checkbox"> 被织入通知的对象。</li></ul></blockquote></blockquote></li></ul></li></ul><p> 切点表达式</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">execution([访问控制权限修饰符] 返回值类型 [全限定类名]方法名(形式参数列表) [异常])</span><br></pre></td></tr></table></figure><h3 id="使用Spring的AOP"><a href="#使用Spring的AOP" class="headerlink" title="使用Spring的AOP"></a>使用Spring的AOP</h3><h4 id="切面的先后顺序"><a href="#切面的先后顺序" class="headerlink" title="切面的先后顺序"></a>切面的先后顺序</h4><ul><li><input disabled="" type="checkbox"> 可以使用@Order注解来标识切面类，为@Order注解的value指定一个整数型的数字，数字越小，优先级越高。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Order(1)</span> <span class="comment">//设置优先级</span></span><br></pre></td></tr></table></figure><h4 id="通用切点"><a href="#通用切点" class="headerlink" title="通用切点"></a>通用切点</h4><ul><li>将切点表达式单独的定义出来，在需要的位置引入即可</li></ul><h4 id="连接点-Joinpoint"><a href="#连接点-Joinpoint" class="headerlink" title="连接点(Joinpoint)"></a>连接点(Joinpoint)</h4><ul><li><input disabled="" type="checkbox"> getSignature 获取目标方法的签名</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> 开始一直到&#123;&#125;之前</span><br></pre></td></tr></table></figure><h4 id="全注解开发AOP"><a href="#全注解开发AOP" class="headerlink" title="全注解开发AOP"></a>全注解开发AOP</h4><ul><li><input disabled="" type="checkbox"> 编写一个类来代替spring配置文件</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.powernode.spring6.service;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.ComponentScan;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.EnableAspectJAutoProxy;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ComponentScan(&quot;com.powernode.spring6.service&quot;)</span></span><br><span class="line"><span class="meta">@EnableAspectJAutoProxy(proxyTargetClass = true)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Spring6Configuration</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><input disabled="" type="checkbox"> 因为xml文件没了 所以生成对象的时候也要有所变化</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testAOPWithAllAnnotation</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">ApplicationContext</span> <span class="variable">applicationContext</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AnnotationConfigApplicationContext</span>(Spring6Configuration.class);</span><br><span class="line">    <span class="type">OrderService</span> <span class="variable">orderService</span> <span class="operator">=</span> applicationContext.getBean(<span class="string">&quot;orderService&quot;</span>, OrderService.class);</span><br><span class="line">    orderService.generate();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="spring-对事务的支持"><a href="#spring-对事务的支持" class="headerlink" title="spring 对事务的支持"></a>spring 对事务的支持</h2><h3 id="事务概述"><a href="#事务概述" class="headerlink" title="事务概述"></a>事务概述</h3><ul><li>什么是事务<ul><li>在一个业务流程当中，通常需要多条DML（insert delete update）语句共同联合才能完成，这多条DML语句必须同时成功，或者同时失败，这样才能保证数据的安全。</li><li>多条DML要么同时成功，要么同时失败，这叫做事务。</li><li>事务：Transaction（tx）</li></ul></li><li>事务的四个处理过程：<ul><li>第一步：开启事务 (start transaction)</li><li>第二步：执行核心业务代码</li><li>第三步：提交事务（如果核心业务处理过程中没有出现异常）(commit transaction)</li><li>第四步：回滚事务（如果核心业务处理过程中出现异常）(rollback transaction)</li></ul></li><li>事务的四个特性：<ul><li>A 原子性：事务是最小的工作单元，不可再分。</li><li>C 一致性：事务要求要么同时成功，要么同时失败。事务前和事务后的总量不变。</li><li>I 隔离性：事务和事务之间因为有隔离性，才可以保证互不干扰。</li><li>D 持久性：持久性是事务结束的标志。</li></ul></li></ul><h3 id="事务的传播行为"><a href="#事务的传播行为" class="headerlink" title="事务的传播行为"></a>事务的传播行为</h3><ul><li><input disabled="" type="checkbox"> 在service类中有a()方法和b()方法，a()方法上有事务，b()方法上也有事务，当a()方法执行过程中调用了b()方法，事务是如何传递的？合并到一个事务里？还是开启一个新的事务？这就是事务传播行为。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Transactional(propagation = Propagation.REQUIRED)</span></span><br></pre></td></tr></table></figure><p>一共有七种传播行为：</p><ul><li>REQUIRED：支持当前事务，如果不存在就新建一个(默认)【没有就新建，有就加入】</li><li>SUPPORTS：支持当前事务，如果当前没有事务，就以非事务方式执行【有就加入，没有就不管了】</li><li>MANDATORY：必须运行在一个事务中，如果当前没有事务正在发生，将抛出一个异常【有就加入，没有就抛异常】</li><li>REQUIRES_NEW：开启一个新的事务，如果一个事务已经存在，则将这个存在的事务挂起【不管有没有，直接开启一个新事务，开启的新事务和之前的事务不存在嵌套关系，之前事务被挂起】</li><li>NOT_SUPPORTED：以非事务方式运行，如果有事务存在，挂起当前事务【不支持事务，存在就挂起】</li><li>NEVER：以非事务方式运行，如果有事务存在，抛出异常【不支持事务，存在就抛异常】</li><li>NESTED：如果当前正有一个事务在进行中，则该方法应当运行在一个嵌套式事务中。被嵌套的事务可以独立于外层事务进行提交或回滚。如果外层事务不存在，行为就像REQUIRED一样。【有事务的话，就在这个事务里再嵌套一个完全独立的事务，嵌套的事务可以独立的提交和回滚。没有事务就和REQUIRED一样。】</li></ul><h3 id="事物的隔离级别"><a href="#事物的隔离级别" class="headerlink" title="事物的隔离级别"></a>事物的隔离级别</h3><ul><li>脏读：读取到没有提交到数据库的数据(缓存中的数据)，叫做脏读。</li><li>不可重复读：在同一个事务当中，第一次和第二次读取的数据不一样。</li><li>幻读：读到的数据是假的。多事务并发一定会产生幻读问题。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Transactional(isolation = Isolation.READ_COMMITTED)</span></span><br></pre></td></tr></table></figure><blockquote><blockquote><ul><li><input disabled="" type="checkbox"> 其中可以设置的隔离级别有以下四种</li></ul></blockquote></blockquote><ul><li>Default</li><li>read_uncommitted</li><li>READ_COMMITTED</li><li>repeatable_read</li><li>serializable</li></ul><h3 id="事物超时"><a href="#事物超时" class="headerlink" title="事物超时"></a>事物超时</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Transactional(timeout = 10)</span></span><br></pre></td></tr></table></figure><ul><li>以上代码表示设置事务的超时时间为10秒。</li><li>表示超过10秒如果该事务中所有的DML语句还没有执行完毕的话，最终结果会选择回滚。</li><li>默认值-1，表示没有时间限制。</li><li>这里有个坑，事务的超时时间指的是哪段时间？:在当前事务当中，最后一条DML语句执行<code>之前</code>的时间。如果最后一条DML语句后面很有很多业务逻辑，这些业务代码执行的时间不被计入超时时间。</li></ul><h3 id="只读事务"><a href="#只读事务" class="headerlink" title="只读事务"></a>只读事务</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Transactional(readOnly = true)</span></span><br></pre></td></tr></table></figure><ul><li>将当前事务设置为只读事务，在该事务执行过程中只允许select语句执行，delete insert update均不可执行。<br>该特性的作用是：启动spring的优化策略。提高select语句执行效率。<br>如果该事务中确实没有增删改操作，建议设置为只读事务。</li></ul><h3 id="设置哪些异常回滚事务"><a href="#设置哪些异常回滚事务" class="headerlink" title="设置哪些异常回滚事务"></a>设置哪些异常回滚事务</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Transactional(rollbackFor = RuntimeException.class)</span></span><br></pre></td></tr></table></figure><ul><li>表示只有发生RuntimeException异常或该异常的子类异常才回滚。</li></ul><h3 id="设置哪些异常不回滚事务"><a href="#设置哪些异常不回滚事务" class="headerlink" title="设置哪些异常不回滚事务"></a>设置哪些异常不回滚事务</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Transactional(noRollbackFor = NullPointerException.class)</span></span><br></pre></td></tr></table></figure><p>表示发生NullPointerException或该异常的子类异常不回滚，其他异常则回滚。</p><h3 id="事务的全注解开发"><a href="#事务的全注解开发" class="headerlink" title="事务的全注解开发"></a>事务的全注解开发</h3><p>编写一个类来代替配置文件</p><h2 id="Spring6整合JUnit5"><a href="#Spring6整合JUnit5" class="headerlink" title="Spring6整合JUnit5"></a>Spring6整合JUnit5</h2><h3 id="Spring对JUnit4的支持"><a href="#Spring对JUnit4的支持" class="headerlink" title="Spring对JUnit4的支持"></a>Spring对JUnit4的支持</h3><p>:wq<br>Spring提供的方便主要是这几个注解：</p><ul><li><p>@RunWith(SpringJUnit4ClassRunner.class)</p></li><li><p>@ContextConfiguration(“classpath:spring.xml”)</p></li><li><p>在单元测试类上使用这两个注解之后，在单元测试类中的属性上可以使用@Autowired。比较方便。</p></li></ul><h3 id="Spring对JUnit5的支持"><a href="#Spring对JUnit5的支持" class="headerlink" title="Spring对JUnit5的支持"></a>Spring对JUnit5的支持</h3><p>在JUnit5当中，可以使用Spring提供的以下两个注解，标注到单元测试类上，这样在类当中就可以使用@Autowired注解了。</p><ul><li>@ExtendWith(SpringExtension.class)</li><li>@ContextConfiguration(“classpath:spring.xml”)</li></ul><h2 id="Spring6集成MyBatis3-5"><a href="#Spring6集成MyBatis3-5" class="headerlink" title="Spring6集成MyBatis3.5"></a>Spring6集成MyBatis3.5</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">AccountMapper</span> &#123;</span><br><span class="line">    <span class="comment">// 接口定义的方法</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Repository</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AccountMapperImpl</span> <span class="keyword">implements</span> <span class="title class_">AccountMapper</span> &#123;</span><br><span class="line">    <span class="comment">// 实现接口定义的方法</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AccountService</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> AccountMapper accountMapper;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 类的其余部分</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li><input disabled="" type="checkbox"> 在这个例子中，AccountMapper 是一个接口，AccountMapperImpl 是实现了这个接口的类。在 AccountService 类中，通过 @Autowired 注解将 accountMapper 字段注入为 AccountMapper 接口的实现类的一个实例。</li></ul><h2 id="spring中的八大模式"><a href="#spring中的八大模式" class="headerlink" title="spring中的八大模式"></a>spring中的八大模式</h2><h3 id="简单工厂模式-1"><a href="#简单工厂模式-1" class="headerlink" title="简单工厂模式"></a>简单工厂模式</h3><p>BeanFactory的getBean()方法，通过唯一标识来获取Bean对象。是典型的简单工厂模式（静态工厂模式）；</p><h3 id="工厂方法模式"><a href="#工厂方法模式" class="headerlink" title="工厂方法模式"></a>工厂方法模式</h3><p>FactoryBean是典型的工厂方法模式。在配置文件中通过factory-method属性来指定工厂方法，该方法是一个实例方法。</p><h3 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h3><p>Spring用的是双重判断加锁的单例模式。</p><h3 id="代理模式"><a href="#代理模式" class="headerlink" title="代理模式"></a>代理模式</h3><p>Spring的AOP就是使用了动态代理实现的。</p><h3 id="装饰器模式"><a href="#装饰器模式" class="headerlink" title="装饰器模式"></a>装饰器模式</h3><p>JavaSE中的IO流是非常典型的装饰器模式。</p><p>Spring 中配置 DataSource 的时候，这些dataSource可能是各种不同类型的，比如不同的数据库：Oracle、SQL Server、MySQL等，也可能是不同的数据源：比如apache 提供的org.apache.commons.dbcp.BasicDataSource、spring提供的org.springframework.jndi.JndiObjectFactoryBean等。</p><p>这时，能否在尽可能少修改原有类代码下的情况下，做到动态切换不同的数据源？此时就可以用到装饰者模式。</p><p>Spring根据每次请求的不同，将dataSource属性设置成不同的数据源，以到达切换数据源的目的。</p><p><strong>Spring中类名中带有：Decorator和Wrapper单词的类，都是装饰器模式。</strong></p><h3 id="观察者模式"><a href="#观察者模式" class="headerlink" title="观察者模式"></a>观察者模式</h3><p>定义对象间的一对多的关系，当一个对象的状态发生改变时，所有依赖于它的对象都得到通知并自动更新。Spring中观察者模式一般用在listener的实现</p><h3 id="策略模式"><a href="#策略模式" class="headerlink" title="策略模式"></a>策略模式</h3><p>策略模式是行为性模式，调用不同的方法，适应行为的变化 ，强调父类的调用子类的特性 。</p><p>getHandler是HandlerMapping接口中的唯一方法，用于根据请求找到匹配的处理器。</p><p>比如我们自己写了AccountDao接口，然后这个接口下有不同的实现类：AccountDaoForMySQL，AccountDaoForOracle。对于service来说不需要关心底层具体的实现，只需要面向AccountDao接口调用，底层可以灵活切换实现，这就是策略模式。</p><h3 id="模板方法模式"><a href="#模板方法模式" class="headerlink" title="模板方法模式"></a>模板方法模式</h3><p>Spring中的JdbcTemplate类就是一个模板类。它就是一个模板方法设计模式的体现。在模板类的模板方法execute中编写核心算法，具体的实现步骤在子类中完成。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;[!TIP]&lt;br&gt;基于动力节点spring6总结&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;Spring启示录&quot;&gt;&lt;a href=&quot;#Spring启示录&quot; class=&quot;headerlink&quot; title=&quot;Spring启示录&quot;&gt;&lt;/a</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>测试开发学习路线</title>
    <link href="http://www.meprotoss.com/undefined/d3855f56.html"/>
    <id>http://www.meprotoss.com/undefined/d3855f56.html</id>
    <published>2024-05-06T08:34:53.000Z</published>
    <updated>2024-05-07T16:04:08.277Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、编程语言入门"><a href="#一、编程语言入门" class="headerlink" title="一、编程语言入门"></a>一、编程语言入门</h2><ul><li><input checked="" disabled="" type="checkbox"> java</li></ul><h2 id="二、基础"><a href="#二、基础" class="headerlink" title="二、基础"></a>二、基础</h2><h3 id="计算机基础"><a href="#计算机基础" class="headerlink" title="计算机基础"></a>计算机基础</h3><ul><li><input disabled="" type="checkbox"> 数据结构与算法</li><li><input disabled="" type="checkbox"> 计算机网络</li><li><input disabled="" type="checkbox"> linux</li><li><input disabled="" type="checkbox"> mysql 重点是sql语句的编写</li></ul><h3 id="测试基础"><a href="#测试基础" class="headerlink" title="测试基础"></a>测试基础</h3><ul><li><input disabled="" type="checkbox"> 测试工具</li><li><input disabled="" type="checkbox"> 功能测试基础</li></ul><h2 id="三、进阶"><a href="#三、进阶" class="headerlink" title="三、进阶"></a>三、进阶</h2><h3 id="开发"><a href="#开发" class="headerlink" title="开发"></a>开发</h3><ul><li><input disabled="" type="checkbox"> 后端web开发</li><li><input disabled="" type="checkbox"> 自动化测试</li></ul><h2 id="项目实战"><a href="#项目实战" class="headerlink" title="项目实战"></a>项目实战</h2><ul><li><input disabled="" type="checkbox"> 开发项目实战</li></ul><blockquote><p>[!TIP]<br>应届校招以准备开发项目实战为佳,而不是测试项目</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;一、编程语言入门&quot;&gt;&lt;a href=&quot;#一、编程语言入门&quot; class=&quot;headerlink&quot; title=&quot;一、编程语言入门&quot;&gt;&lt;/a&gt;一、编程语言入门&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;input checked=&quot;&quot; disabled=&quot;&quot; type=&quot;chec</summary>
      
    
    
    
    
  </entry>
  
</feed>
