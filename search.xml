<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>八股文骚套路之设计模式</title>
      <link href="/undefined/cb77a7ee.html"/>
      <url>/undefined/cb77a7ee.html</url>
      
        <content type="html"><![CDATA[<h2 id="jdk中常见的设计模式"><a href="#jdk中常见的设计模式" class="headerlink" title="jdk中常见的设计模式"></a>jdk中常见的设计模式</h2><ul><li>单例</li><li>工厂模式（简单工厂、抽象工厂）</li><li>装饰器模式</li></ul><h2 id="你是否在你的代码里使用过设计模式？"><a href="#你是否在你的代码里使用过设计模式？" class="headerlink" title="你是否在你的代码里使用过设计模式？"></a>你是否在你的代码里使用过设计模式？</h2><ul><li>面向对象编程中，使用工厂模式来创建对象<!-- TODO: 举一个黑马点评中的例子 --></li></ul><h2 id="Java中什么叫单例设计模式？请写出Java中线程安全的单例模式"><a href="#Java中什么叫单例设计模式？请写出Java中线程安全的单例模式" class="headerlink" title="Java中什么叫单例设计模式？请写出Java中线程安全的单例模式"></a>Java中什么叫单例设计模式？请写出Java中线程安全的单例模式</h2><ul><li>一个类只有一个实例,主要有懒汉式和饿汉式两种创建方式，懒汉式仅初始化类，但是仅在调用getInstance方法时才创建对象；<br>饿汉式则在初始化类的时候一并创建对象</li><li>懒汉式，线程不安全</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance;</span><br><span class="line">  <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(instance == <span class="literal">null</span>)&#123;</span><br><span class="line">      instance = <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> instance;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>懒汉式，线程安全(使用synchronized来保证线程安全)</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(instance == <span class="literal">null</span>)&#123;</span><br><span class="line">      instance = <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> instance;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>饿汉式</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">Singleton</span> <span class="variable">instance</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span> &#123;&#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="使用工厂模式最主要的好处是什么？在哪里使用？"><a href="#使用工厂模式最主要的好处是什么？在哪里使用？" class="headerlink" title="使用工厂模式最主要的好处是什么？在哪里使用？"></a>使用工厂模式最主要的好处是什么？在哪里使用？</h2><h2 id="为什么说枚举是实现单例的最好方式"><a href="#为什么说枚举是实现单例的最好方式" class="headerlink" title="为什么说枚举是实现单例的最好方式"></a>为什么说枚举是实现单例的最好方式</h2><ul><li>线程安全</li><li>反射安全性</li><li>序列化安全性</li><li>简洁性和可读性</li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>八股文骚套路之Redis</title>
      <link href="/undefined/eaffd6f8.html"/>
      <url>/undefined/eaffd6f8.html</url>
      
        <content type="html"><![CDATA[<blockquote><p>[!TIP]<br>所谓缓存雪崩、击穿、穿透，主要是针对缓存不在合适的时候过期导致的问题</p></blockquote><h2 id="缓存雪崩的解决方案"><a href="#缓存雪崩的解决方案" class="headerlink" title="缓存雪崩的解决方案"></a>缓存雪崩的解决方案</h2><p><strong>缓存在同一时间大面积的失效</strong>，导致大量的请求都直接落到了数据库上，对数据库造成了巨大的压力</p><p><strong>缓存服务宕机</strong>也会导致缓存雪崩现象</p><h3 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h3><h4 id="针对redis服务不可用的情况"><a href="#针对redis服务不可用的情况" class="headerlink" title="针对redis服务不可用的情况"></a>针对redis服务不可用的情况</h4><ul><li>Redis 集群:采用 Redis 集群，避免单机出现问题整个缓存服务都没办法使用</li><li>多级缓存</li></ul><h4 id="针对大量缓存同时失效的情况"><a href="#针对大量缓存同时失效的情况" class="headerlink" title="针对大量缓存同时失效的情况"></a>针对大量缓存同时失效的情况</h4><ul><li>设置随机失效时间：避免大量缓存同时到期</li><li>提前预热：针对热点数据提前预热，将其存入缓存中并设置合理的过期时间 （比如秒杀场景下的数据在秒杀结束之前不过期)。<ul><li>缓存预热的常见实现方式：定时任务和消息队列，<strong>Kafka</strong>可以异步的进行缓存预热</li></ul></li></ul><h2 id="如何保证缓存和数据库中数据的一致性"><a href="#如何保证缓存和数据库中数据的一致性" class="headerlink" title="如何保证缓存和数据库中数据的一致性"></a>如何保证缓存和数据库中数据的一致性</h2><ul><li>让缓存失效的时间变短,这样缓存就会很快从数据库从加载数据。(不推荐)</li><li>增加缓存更新重试机制：针对缓存不可用导致的缓存删除失败，可以引入消息队列实现<strong>异步</strong>重试，将删除缓存重试的消息投递到消息队列，然后由专门的消费者来重试，直到成功。</li></ul><h2 id="缓存击穿-热点key问题"><a href="#缓存击穿-热点key问题" class="headerlink" title="缓存击穿(热点key问题)"></a>缓存击穿(热点key问题)</h2><p>请求的 key 对应的是<strong>热点数据 ，该数据存在于数据库中，但不存在于缓存中</strong>,瞬时大量的请求直接打到了数据库上</p><p>举个例子：秒杀进行过程中，缓存中的某个秒杀商品的数据突然过期，这就导致瞬时大量对该商品的请求直接落到数据库上，对数据库造成了巨大的压力</p><h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><ul><li>提前预热：提前将热点key存入缓存</li><li>加锁：在缓存失效之后，通过设置互斥锁确保只有一个请求取查询数据库更新缓存。</li><li>永不过期（不推荐）</li></ul><h2 id="缓存穿透"><a href="#缓存穿透" class="headerlink" title="缓存穿透"></a>缓存穿透</h2><p><strong>大量请求的key 是不合理的，根本不存在于缓存中，也不存在于数据库中</strong></p><h3 id="解决方法-1"><a href="#解决方法-1" class="headerlink" title="解决方法"></a>解决方法</h3><ul><li>缓存无效key</li><li>设置布隆过滤器：布隆过滤器可以很方便的判断一个给定数据是否存在于海量数据中。相当于在用户请求和缓存之间添加了一层过滤，将所有可能存在的请求值都存放在布隆过滤器中，当用户请求过来，先判断在不在过滤器中，如果不存在，则直接返回请求参数错误给客户端。</li></ul><h2 id="缓存穿透vs缓存击穿"><a href="#缓存穿透vs缓存击穿" class="headerlink" title="缓存穿透vs缓存击穿"></a>缓存穿透vs缓存击穿</h2><p>缓存穿透:请求的key在缓存中不存在，也不存在在数据库中<br>缓存击穿：请求的key是热点数据，不在缓存中，在数据库中</p><h2 id="缓存雪崩vs缓存击穿"><a href="#缓存雪崩vs缓存击穿" class="headerlink" title="缓存雪崩vs缓存击穿"></a>缓存雪崩vs缓存击穿</h2><p>缓存雪崩： 缓存中的大量或所有数据失效<br>缓存击穿： 热点数据不在缓存中（通常是由于缓存中的那份数据已经过期）</p><h2 id="常用的缓存读写策略"><a href="#常用的缓存读写策略" class="headerlink" title="常用的缓存读写策略"></a>常用的缓存读写策略</h2><ul><li>旁路缓存：<ul><li>写：先更新数据库，然后直接删除缓存（数据库优先）</li><li>读：先读缓存；读不到就读db返回；然后把数据写入缓存</li><li>适用于读请求较多的场景</li></ul></li><li>读写穿透<ul><li>写：先查缓存，缓存中没有直接更新数据库；缓存中存在则先更新缓存，然后缓存同步更新数据库（缓存优先）</li><li>读：先读缓存；读不到就读db，写入缓存再返回</li></ul></li><li>异步缓存写入：<ul><li>类似读写穿透，<strong>两者都是由 cache 服务来负责 cache 和 db 的读写。</strong></li><li>两者区别在于：读写穿透<strong>同步更新数据库和缓存</strong>；异步缓存写入<strong>只更新缓存，异步批量更新数据库</strong></li></ul></li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>八股文骚套路之mysql</title>
      <link href="/undefined/c53b31d1.html"/>
      <url>/undefined/c53b31d1.html</url>
      
        <content type="html"><![CDATA[<h2 id="ORDER-BY、LIMIT、GROUP-BY、HAVING-这些关键字的作用"><a href="#ORDER-BY、LIMIT、GROUP-BY、HAVING-这些关键字的作用" class="headerlink" title="ORDER BY、LIMIT、GROUP BY、HAVING 这些关键字的作用"></a>ORDER BY、LIMIT、GROUP BY、HAVING 这些关键字的作用</h2><ul><li>order by：排序</li><li>limit: 限制查询返回的行数</li><li>group by：根据一个或多个列对查询结果分组</li><li>having: 用于过滤分组后的数据，相比较where HAVING 在分组后应用条件，而 WHERE 在分组前应用条件</li></ul><h2 id="左链接和右链接的区别"><a href="#左链接和右链接的区别" class="headerlink" title="左链接和右链接的区别"></a>左链接和右链接的区别</h2><p>一个以左边的表为基础，确保左表中的行都出现在结果中,反之亦然</p><h2 id="InnoDB相关"><a href="#InnoDB相关" class="headerlink" title="InnoDB相关"></a>InnoDB相关</h2><p>索引的本质是一种排序好的数据结构</p><h3 id="InnoDB-和-MyISM、MEMORY-的区别是什么"><a href="#InnoDB-和-MyISM、MEMORY-的区别是什么" class="headerlink" title="InnoDB 和 MyISM、MEMORY 的区别是什么"></a>InnoDB 和 MyISM、MEMORY 的区别是什么</h3><h2 id="索引相关"><a href="#索引相关" class="headerlink" title="索引相关"></a>索引相关</h2><h3 id="索引所采用的数据结构，以及为什么要这样设计"><a href="#索引所采用的数据结构，以及为什么要这样设计" class="headerlink" title="索引所采用的数据结构，以及为什么要这样设计"></a>索引所采用的数据结构，以及为什么要这样设计</h3><p>常见的索引结构有:</p><ul><li>hash表 不支持顺序和范围查询</li><li>红黑树</li><li>B树</li><li>B+树</li><li>二叉查找树(左小右大)</li><li>AVL 平衡二叉树(优化的二叉查找树 左右子树高度之差不超过 1)</li></ul><h3 id="BTree-索引和-Hash-索引的适用范围"><a href="#BTree-索引和-Hash-索引的适用范围" class="headerlink" title="BTree 索引和 Hash 索引的适用范围"></a>BTree 索引和 Hash 索引的适用范围</h3><p>InnoDB数据库和MyISM数据库默认使用BTree索引</p><ul><li>节点存放key，叶子存放key和data</li><li>叶子节点有一条引用鲢指向与他相邻的叶子节点</li><li>任何查找都是从根节点到叶子节点的过程，检索效率稳定</li><li>B+树的范围查找只需要对叶子节点作范围查询</li></ul><p>hash索引适用于等值查询，尤其是在内存密集的环境中；不适用于范围查询、排序和处理大量哈希冲突的情况</p><h2 id="SQL优化问题"><a href="#SQL优化问题" class="headerlink" title="SQL优化问题"></a>SQL优化问题</h2><h3 id="哪些场景可以使用索引"><a href="#哪些场景可以使用索引" class="headerlink" title="哪些场景可以使用索引"></a>哪些场景可以使用索引</h3><ul><li>排序</li><li>连接操作</li><li>唯一性约束</li><li>聚集函数</li><li>范围查询</li><li>避免全表查询</li></ul><h3 id="索引在哪些情况会失效"><a href="#索引在哪些情况会失效" class="headerlink" title="索引在哪些情况会失效"></a>索引在哪些情况会失效</h3><ul><li>不能对索引列进行查询和函数操作</li><li>数据分布不均匀</li><li>数据量很大</li><li>频繁更新的列</li><li>索引列参与复杂的表达式或者条件</li></ul><h2 id="事务四大特性，并解释这四大特性的含义"><a href="#事务四大特性，并解释这四大特性的含义" class="headerlink" title="事务四大特性，并解释这四大特性的含义"></a>事务四大特性，并解释这四大特性的含义</h2><p>ACID</p><ul><li>原子性 事务是最小执行单位，不允许分割</li><li>一致性 执行事务前后 数据保持一致</li><li>隔离性 并发访问数据库时，一个用户的事务不被其他事务所干扰</li><li>持久性 事务提交之后对数据库的影响是永久的</li></ul><p>只有保证了事务的持久性、原子性、隔离性之后，一致性才能得到保障。也就是说 A、I、D 是手段，C 是目的！</p><h2 id="并发事务处理会带来哪些问题？"><a href="#并发事务处理会带来哪些问题？" class="headerlink" title="并发事务处理会带来哪些问题？"></a>并发事务处理会带来哪些问题？</h2><ul><li>脏读 a读到了b修改未提交的数据</li><li>幻读 a多次读同一个数据，但是期间其他事务对数据进行了修改</li><li>丢失修改 a读一个数据，b也访问该数据，第一个事务修改数据之后，b也修改了这个数据，导致a的修改结果丢失</li></ul><h2 id="事务隔离级别"><a href="#事务隔离级别" class="headerlink" title="事务隔离级别"></a>事务隔离级别</h2><ul><li>读未提交 读取尚未提交的数据变更 会导致脏读 不可重读 幻读</li><li>读已提交 允许读取并发事务已经提交的数据 会导致不可重读 幻读</li><li>可重读 对同一字段的多次读取结果是一致的 会导致幻读</li><li>可串行化 满足acid</li></ul><h2 id="InnoDB-行锁实现方式"><a href="#InnoDB-行锁实现方式" class="headerlink" title="InnoDB 行锁实现方式"></a>InnoDB 行锁实现方式</h2><ul><li><p>共享锁(s)（读锁）和排它锁(x)（写锁）</p></li><li><p>MVCC（多版本并发控制）MVCC可以在读取数据时不加锁，同时保证事务的一致性。每个事务在开始时都会生成一个唯一的事务ID，每行数据也会保存这个事务ID的版本信息。这样，即使其他事务在修改数据，当前事务也可以读取到之前版本的数据。</p></li><li><p>MVCC（多版本并发控制） 是一种<strong>并发控制机制</strong>，通过在每个数据行上维护多个版本的数据，当一个事务要对数据库中的数据进行修改的时候，MVCC会为该事务创建一个数据快照，而不是直接修改实际的数据行，用于在多个并发事务同时读写数据库时保持数据的一致性和隔离性</p></li></ul><p>读操作使用旧版本数据的快照，写操作创建新版本，并确保原始版本仍然可用</p><h2 id="你了解-Next-key-锁吗？"><a href="#你了解-Next-key-锁吗？" class="headerlink" title="你了解 Next-key 锁吗？"></a>你了解 Next-key 锁吗？</h2><p>Next-Key锁是一种特殊类型的锁，通常在实现范围查询时用于避免幻读（Phantom Read）问题。</p><p>Next-Key锁结合了行锁（Row Lock）和间隙锁（Gap Lock）的特性，用于确保范围查询的一致性。</p><h2 id="如何避免-InnoDB-中的死锁"><a href="#如何避免-InnoDB-中的死锁" class="headerlink" title="如何避免 InnoDB 中的死锁"></a>如何避免 InnoDB 中的死锁</h2><ul><li>减少并发</li><li>尽量使用索引</li><li>使用事务的隔离级别</li><li>合理设计事务</li></ul><h2 id="死锁的类型"><a href="#死锁的类型" class="headerlink" title="死锁的类型"></a>死锁的类型</h2><p>死锁是指多个事务在相互持有资源的情况下，同时等待对方释放资源</p><ul><li><p>简单死锁<br>涉及两个事务，互相等待</p></li><li><p>递归死锁<br>多个事务，循环等待</p></li><li><p>资源不足死锁<br>资源紧张的情况下，多个事务由于资源不足进入等待</p></li></ul><h2 id="如何优化数据库？"><a href="#如何优化数据库？" class="headerlink" title="如何优化数据库？"></a>如何优化数据库？</h2><ul><li>索引</li><li>分库分表和读写分离</li><li>数据冷热分离</li><li>深度分页优化</li></ul><h2 id="数据库中的乐观锁和悲观锁，以及适用场景？"><a href="#数据库中的乐观锁和悲观锁，以及适用场景？" class="headerlink" title="数据库中的乐观锁和悲观锁，以及适用场景？"></a>数据库中的乐观锁和悲观锁，以及适用场景？</h2><ul><li><p>悲观锁：假设并发访问会导致冲突，因此在访问数据之前获取锁，以防止别的事务对数据进行修改,适用于频繁写的场景。（例如数据库中的行级锁和表级锁）</p></li><li><p>乐观锁：假设并发访问不会导致冲突，因此在访问数据时不会立即获取锁，<strong>在更新数据时检查数据是否被其他事务修改过</strong>，如果没有则进行更新，否则会进行回滚或者重试。适用于读操作多，写操作少的场景</p></li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>计算机基础——Linux</title>
      <link href="/undefined/f7999b22.html"/>
      <url>/undefined/f7999b22.html</url>
      
        <content type="html"><![CDATA[<h2 id="inode"><a href="#inode" class="headerlink" title="inode"></a>inode</h2><p>index + node</p><p>inode就是用来维护某个文件被分成几块、每一块在的地址、文件拥有者，创建时间，权限，大小等信息。</p><h2 id="Linux常用指令"><a href="#Linux常用指令" class="headerlink" title="Linux常用指令"></a>Linux常用指令</h2><table><thead><tr><th>指令</th><th>作用</th></tr></thead><tbody><tr><td>stat</td><td>查看文件的 inode 信息</td></tr><tr><td>ln</td><td>创建硬链接</td></tr><tr><td>file</td><td>查看文件类型信息</td></tr><tr><td>tar</td><td>压缩和解压缩</td></tr><tr><td>ls -l</td><td>查看某个目录下的文件或目录的权限</td></tr><tr><td>top</td><td>查看系统的 CPU 使用率、内存使用率、进程信息等</td></tr><tr><td>systemctl</td><td>查看系统服务的状态、启动、停止、重启等</td></tr></tbody></table><h2 id="Linux获取实时刷新的日志"><a href="#Linux获取实时刷新的日志" class="headerlink" title="Linux获取实时刷新的日志"></a>Linux获取实时刷新的日志</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 实时刷新</span></span><br><span class="line"><span class="built_in">tail</span> -f logfile.log</span><br><span class="line"><span class="comment"># 每5分钟执行一次查询</span></span><br><span class="line">watch -n 300 <span class="string">&#x27;tail logfile.log&#x27;</span></span><br><span class="line"></span><br><span class="line">journalctl -f</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>八股文骚套路之测开</title>
      <link href="/undefined/aec9bf64.html"/>
      <url>/undefined/aec9bf64.html</url>
      
        <content type="html"><![CDATA[<h2 id="常用自动话测试工具"><a href="#常用自动话测试工具" class="headerlink" title="常用自动话测试工具"></a>常用自动话测试工具</h2><h3 id="Selenium"><a href="#Selenium" class="headerlink" title="Selenium **"></a>Selenium **</h3><p>Web自动化测试</p><h3 id="Postman"><a href="#Postman" class="headerlink" title="Postman ***"></a>Postman ***</h3><p>接口测试</p><h3 id="Jmeter"><a href="#Jmeter" class="headerlink" title="Jmeter ***"></a>Jmeter ***</h3><h3 id="Jenkins"><a href="#Jenkins" class="headerlink" title="Jenkins"></a>Jenkins</h3><h2 id="手机兼容性测试"><a href="#手机兼容性测试" class="headerlink" title="手机兼容性测试"></a>手机兼容性测试</h2><ul><li>系统兼容性</li><li>屏幕兼容性</li><li>型号兼容性</li><li>数据来源</li></ul><h2 id="软件开发流程"><a href="#软件开发流程" class="headerlink" title="软件开发流程"></a>软件开发流程</h2><ul><li>需求分析</li><li>指定测试计划</li><li>用例设计</li><li>用例执行</li><li>缺陷管理</li><li>测试报告</li></ul><h2 id="软件测试方法"><a href="#软件测试方法" class="headerlink" title="软件测试方法 *****"></a>软件测试方法 *****</h2><ol><li>软件测试方法：白盒、黑盒(功能测试)、灰盒、 静态测试、动态测试</li></ol><p>白盒测试一般可被分为静态分析和动态分析两类技术：</p><ul><li>静态分析主要有：控制流分析技术、数据流分析技术、信息流分析技术。</li><li>动态分析主要有：逻辑覆盖率测试(分支测试、路径测试等)，程序插装等。</li><li>白盒测试优点：迫使测试人员去仔细的思考软件的实现；可以检测代码中的每条分支和路径；揭示隐藏在代码中的错误；对代码的测试比较彻底</li><li>白盒测试缺点：昂贵；无法检测代码中遗漏的路径和数据敏感性错误；不验证规格的正确性。</li></ul><p>静态测试：是一种不通过执行程序而进行测试的技术。它的关键功能是检查软件的表示和描述是否一致，没有冲突或者没有歧义</p><p>动态测试：包含了程序在受控的环境下使用特定的期望结果进行正式的运行。它显示了一个系统在检查状态下是正确还是不正确。<br> 单元测试属于白盒测试范畴；集成测试属于灰盒测试范畴；系统测试属于黑盒测试范畴。</p><h2 id="CI-CD理解"><a href="#CI-CD理解" class="headerlink" title="CI&#x2F;CD理解 *****"></a>CI&#x2F;CD理解 *****</h2><ul><li>CI(Continuous Integration)持续集成</li></ul><p>持续集成强调开发人员提交了新代码之后，立刻进行构建、（单元）测试。根据测试结果，我们可以确定新代码和原有代码能否正确地集成在一起。<br><strong>集成</strong>是指软件个人研发的部分向软件整体部分交付，以便尽早发现个人开发部分的问题；</p><ul><li><p>CD(Continuous Delivery)持续交付<br>持续交付在持续集成的基础上，将集成后的代码部署到更贴近真实运行环境的「类生产环境」（production-like environments）中。比如，我们完成单元测试后，可以把代码部署到连接数据库的 Staging 环境中更多的测试。如果代码没有问题，可以继续手动部署到生产环境中。<br><strong>交付</strong>是指研发尽快向客户交付，以便尽早发现生产环境中存在的问题。</p></li><li><p>CD(Continuous Deployment)持续部署<br>持续部署则是在持续交付的基础上，把部署到生产环境的过程自动化。<br><strong>部署</strong>是代码尽快向可运行的开发&#x2F;测试节交付，以便尽早测试；</p></li></ul><p>所谓的<strong>持续</strong>，就是说每完成一个完整的部分，就向下个环节交付，发现问题可以马上调整。是的问题不会放大到其他部分和后面的环节。</p><h2 id="单元测试"><a href="#单元测试" class="headerlink" title="单元测试 ***"></a>单元测试 ***</h2><p>单元测试是指，对软件中的<strong>最小可测试单元</strong>在与程序其他部分相隔离的情况下进行检查和验证的工作，这里的最小可测试单元通常是指<strong>函数或者类</strong>。</p><h2 id="时间紧任务重不能加人的情况怎么尽最大努力测试"><a href="#时间紧任务重不能加人的情况怎么尽最大努力测试" class="headerlink" title="时间紧任务重不能加人的情况怎么尽最大努力测试?"></a>时间紧任务重不能加人的情况怎么尽最大努力测试?</h2><p>答：1. 不写测试用例，先和产品人员沟通覆盖主要业务，选出重要的模块先正向后逆向2. 可以使用错误推荐法<strong>根据经验复测</strong>。</p><h2 id="任何测试都应该先走业务"><a href="#任何测试都应该先走业务" class="headerlink" title="任何测试都应该先走业务"></a>任何测试都应该先走<strong>业务</strong></h2><p>而测业务需要使用场景法</p><h2 id="针对某一个产品写测试用例"><a href="#针对某一个产品写测试用例" class="headerlink" title="针对某一个产品写测试用例 *****"></a>针对某一个产品写测试用例 *****</h2><p>基本思路：可以从功能测试，UI测试，稳定性测试，压力测试（边界极限），安全测试，本地化测试等角度去考虑</p><p>质量模型：性功能已可健全 （性能、功能、易用性、可靠性、兼容性、安全性</p><p><strong>首先应从正向和逆向考虑功能</strong></p><h3 id="测试水杯"><a href="#测试水杯" class="headerlink" title="测试水杯 *"></a>测试水杯 *</h3><ol><li>基本功能<br>硬度、装载能力、装载种类、漏水、冷水&#x2F;热水&#x2F;冰水、保温</li><li>界面测试(UI)<br>看其形状、大小设计是否符合需求规格说明书的定义，适合人方便拿起喝水；<br>外观是否吸引人，赏心悦目；<br>广告图案沾水后是否掉色、模糊；<br>广告图案是否使用环保材料、不影响使用者健康和回收再利用；<br>广告图案是否和当地政治、宗教符合，没有冲突；<br>广告图案是否做到了本地化和国际化。</li><li>易用性测试</li><li>稳定性测试</li><li>安全性</li><li>本地化测试<br>为国际化和本地化的需要，广告图案和文字是否在政治、宗教和文化方面具有广泛的适用性；</li><li>性能测试</li></ol><h3 id="测试一个输入框-计数"><a href="#测试一个输入框-计数" class="headerlink" title="测试一个输入框(计数) **"></a>测试一个输入框(计数) **</h3><p>通常是一个登陆页面，上面有用户名，密码的输入框，再多一点的有个验证码。</p><h3 id="针对“用户登录”设计测试用例"><a href="#针对“用户登录”设计测试用例" class="headerlink" title="针对“用户登录”设计测试用例 ***"></a>针对“用户登录”设计测试用例 ***</h3><h4 id="功能测试"><a href="#功能测试" class="headerlink" title="功能测试"></a>功能测试</h4><p>正向用例:</p><ol><li>输入已注册的用户名和正确的密码，验证是否登录成功；</li></ol><p>逆向用例：</p><ol start="2"><li>输入已注册的用户名和不正确的密码，验证是否登录失败，并且提示信息正确；</li><li>输入未注册的用户名和任意密码，验证是否登录失败，并且提示信息正确；</li><li>用户名和密码两者都为空，验证是否登录失败，并且提示信息正确；</li><li>用户名和密码两者之一为空，验证是否登录失败，并且提示信息正确；</li><li>如果登录功能启用了验证码功能，在用户名和密码正确的前提下，输入正确的验证码，验证是否登录成功；</li><li>如果登录功能启用了验证码功能，在用户名和密码正确的前提下，输入错误的验证码，验证是否登录失败，并且提示信息正确。</li></ol><p>以上是基本的</p><p>有经验的测试测试工程师还会增加:</p><ol><li>用户名和密码是否大小写敏感；</li><li>页面上的密码框是否加密显示；</li><li>后台系统创建的用户第一次登录成功时，是否提示修改密码；</li><li>忘记用户名和忘记密码的功能是否可用；</li><li>前端页面是否根据设计要求限制用户名和密码长度；</li><li>如果登录功能需要验证码，点击验证码图片是否可以更换验证码，更换后的验证码是否可用；</li><li>刷新页面是否会刷新验证码；</li><li>如果验证码具有时效性，需要分别验证时效内和时效外验证码的有效性；</li><li>用户登录成功但是会话超时后，继续操作是否会重定向到用户登录界面；</li><li>不同级别的用户，比如管理员用户和普通用户，登录系统后的权限是否正确；</li><li>页面默认焦点是否定位在用户名的输入框中；</li><li>快捷键Tab 和Enter等，是否可以正常使用。</li></ol><h4 id="性能"><a href="#性能" class="headerlink" title="性能"></a>性能</h4><ol><li>单用户登录的响应时间是否小于3秒；</li><li>单用户登录时，后台请求数量是否过多；</li><li>高并发场景下用户登录的响应时间是否小于5秒；</li><li>高并发场景下服务端的监控指标是否符合预期；</li><li>高集合点并发场景下，是否存在资源死锁和不合理的资源等待；</li><li>长时间大量用户连续登录和登出，服务器端是否存在内存泄漏。</li></ol><h4 id="安全性"><a href="#安全性" class="headerlink" title="安全性"></a>安全性</h4><ol><li>用户密码后台存储是否加密；</li><li>用户密码在网络传输过程中是否加密；</li><li>密码是否具有有效期，密码有效期到期后，是否提示需要修改密码；</li><li>不登录的情况下，在浏览器中直接输入登录后的URL地址，验证是否会重新定向到用户登录界面；</li><li>密码输入框是否不支持复制和粘贴；</li><li>密码输入框内输入的密码是否都可以在页面源码模式下被查看；</li><li>用户名和密码的输入框中分别输入典型的“SQL注入攻击”字符串，验证系统的返回页面；</li><li>用户名和密码的输入框中分别输入典型的“XSS跨站脚本攻击”字符串，验证系统行为是否被篡改；</li><li>连续多次登录失败情况下，系统是否会阻止后续的尝试以应对暴力破解；</li><li>同一用户在同一终端的多种浏览器上登录，验证登录功能的互斥性是否符合设计预期；</li><li>同一用户先后在多台终端的浏览器上登录，验证登录是否具有互斥性。</li></ol><h4 id="兼容性"><a href="#兼容性" class="headerlink" title="兼容性"></a>兼容性</h4><ol><li>不同浏览器下，验证登录页面的显示以及功能正确性；</li><li>相同浏览器的不同版本下，验证登录页面的显示以及功能正确性；</li><li>不同移动设备终端的不同浏览器下，验证登录页面的显示以及功能正确性；</li><li>不同分辨率的界面下，验证登录页面的显示以及功能正确性。</li></ol><h3 id="微信红包测试用例"><a href="#微信红包测试用例" class="headerlink" title="微信红包测试用例 *****"></a>微信红包测试用例 *****</h3><p>从业务流程考虑:</p><p>单个红包：</p><ol><li>红包金额为空、0、0.01、200.00、200.01、199.99、200</li><li>留言输入数字、字母、汉字、特殊字符</li><li>留言长度</li><li>留言复制粘贴</li><li>表情选择收藏表情、其他表情</li><li>删除表情、重新选择表情</li><li>选择支付方式:零钱、银行卡、添加新卡支付。其中钱数&lt;红包钱数、其中钱数&#x3D;红包钱数、其中钱数&gt;红包钱数</li><li>使用指纹确认付款（正确的、错误的指纹）</li><li>使用密码确认付款（正确的、错误的密码）</li><li>红包成功发送后 相应支付方式中钱数减少（减少金额与红包金额一致）</li><li>接受者能看到红包具体信息，红包金额、留言、表情均能正确显示</li><li>红包被拆开后显示已领取，领取者零钱中增加正确金额，再次领取只能查看红包信息</li><li>发红包者自己领红包</li><li>红包24小时未被领取提示红包被退回，相应支付方式中钱数增加（增加金额与红包金额一致），对方不能领红包</li></ol><p>群发红包-普通红包：（只写了与单个红包不同的地方）</p><ol><li>红包个数 为空、0、001、100、99、101</li><li>红包拆开每个金额一样 均为发红包时设置的单个金额对应的钱数</li><li>红包被拆时，有相应提示</li><li>发红包者自己领红包</li><li>红包24小时内未被拆完，剩余钱被退回，相应支付方式中钱数增加</li></ol><p>群发红包-拼手气红包：</p><ol><li>红包总额&#x2F;红包个数&lt;0.01</li><li>红包每个人拆开金额不同，总金额与发红包设置的总额一致</li><li>红包24小时内拆完后显示最佳手气</li><li>红包24小时内未被拆完不显示最佳手气</li></ol><p>兼容性：安卓、苹果 不同型号版本手机</p><p>UI测试：界面无错别字，风格统一</p><p>中断测试：不同应用之间切换、断网、来电、短信、低电量、手机没电</p><p>网络测试：2g&#x2F;3g&#x2F;4g  WiFi 移动联通电信  弱网  无网</p><h3 id="微信朋友圈测试用例"><a href="#微信朋友圈测试用例" class="headerlink" title="微信朋友圈测试用例 *****"></a>微信朋友圈测试用例 *****</h3><p>当给出的功能比较笼统的时候，可以想一想这个大功能有哪些小功能 然后再考虑这些小功能的业务流程或者说使用场景逻辑，从中提取测试点，提取到测试点之后再使用等价类法、边界值法等方法设计具体的设计用例。</p><p>功能测试</p><p>1 朋友圈发送功能</p><p>1）只发送文本</p><p>a、考虑文本长度：1-1500字符（该数据为百度数据）、超出最大字符长度</p><p>b、文本是否支持复制粘贴</p><p>c、为空验证</p><p>2）只发送图片</p><p>a、本地相册选择&#x2F;拍摄</p><p>b、图片数量验证：1-9张图片、超出9张</p><p>c、为空验证</p><p>3）只发送视频</p><p>a、本地相册选择&#x2F;拍摄</p><p>b、视频秒数验证：1-10s，超出10s</p><p>c、视频个数验证：1个，超出1个</p><p>d、视频格式验证：支持的视频格式，例mp4、不支持的视频格式</p><p>e、视频大小验证：苹果400kb以内、Android200-300kb（此为百度数据）、超出规定大小</p><p>f、视频预览增删改操作</p><p>g、为空验证</p><p>4）发送文本+图片：输入满足要求的文本、图片进行一次验证</p><p>5）发送文本+视频：输入满足要求的文本、视频进行一次验证</p><p>6）发送图片+视频：不支持发送</p><p>7）朋友圈发送内容是否有限制，例如涉及黄赌毒等敏感字</p><p>8）所在位置</p><p>a、不显示位置：发送到朋友圈动态不显示位置</p><p>b、选择对应位置：搜索支持、自动定位、手动编辑</p><p>C、点击取消，返回上一级页面</p><p>9）谁可以看</p><p>a、设置公开：所有朋友可见</p><p>b、设置私密（仅自己可见）：自己查看朋友圈-可见、好友查看朋友圈-不可见</p><p>c、设置部分可见（部分朋友可见）：选择的部分好友-可见、不被选择的好友-不可见、是否有人数上限</p><p>d、设置不给谁看（选中的朋友不可见）：不被选中的朋友-可见、被选中的朋友-不可见、是否有人数上限</p><p>e、点击取消，返回发送页面</p><p>10）提醒谁看</p><p>a、提醒单人&#x2F;提醒多人：被提醒的朋友-收到消息提醒、未被提醒-未有消息提醒</p><p>b、是否有人数上限</p><p>c、点击取消，返回发送页面</p><p>11）同步QQ空间：默认不同步、同步到QQ空间</p><p>12）取消发送朋友圈操作</p><p>a、选择相机，点击取消，返回朋友圈页面</p><p>b、进入朋友圈发送页面，选择文本图片，点击取消</p><p>13）朋友圈当天发送次数是否有上限限制</p><p>2、朋友圈浏览功能</p><p>1）文本查看：</p><p>a、过长文本内容是否隐藏，并支持查看全文</p><p>b、右键选择复制、收藏、翻译</p><p>c、url链接是否支持点击跳转网页</p><p>2）图片查看</p><p>a、小图右键支持收藏&#x2F;编辑</p><p>b、点击支持大图浏览</p><p>c、选择发送给朋友、收藏、保存图片、编辑</p><p>d、多张图片支持左右滑动浏览</p><p>3）视频查看</p><p>a、右键视频支持静音播放&#x2F;搜藏</p><p>b、点击视频播放按键支持播放视频</p><p>c、选择发送给朋友、收藏、保存视频、编辑</p><p>4）分享动态浏览：QQ空间&#x2F;公众号文章&#x2F;非腾讯产品分享后朋友圈是否正常显示</p><p>5）赞：点赞、取消点赞</p><p>6）评论</p><p>a、评论长度：评论字数合理长度、评论超过字数上限</p><p>b、评论类型：纯中文、纯数字、纯字母、纯字符、纯表情（微信表情&#x2F;手机自带表情）、混合类型、包含url链接；</p><p>c、评论是否支持复制粘贴</p><p>d、为空验证</p><p>e、发表评论后删除</p><p>f、评论回复操作</p><p>7）删除朋友圈动态</p><p>8）更换相册封面</p><p>9）刷新是否正常获取新动态</p><p>10）上滑是否加载更多</p><p>界面&#x2F;易用性测试</p><p>1、技术人员角度：页面布局设计是否跟产品原型图&#x2F;ui效果图一致</p><p>2、但除了考虑1之外，我们同样要考虑到用户使用：功能操作是否简便，页面布局排版风格是否美观合理，提示语相关信息是否易于理解</p><p>中断测试</p><p>1、主要考虑：a)核心功能  b)当前功能存在实时数据交换，例发朋友圈、浏览朋友圈进行中断，是否容易出现崩溃</p><p>2、中断包括：前后台切换、锁屏解锁、断网重连、app切换、来电话&#x2F;来短信中断、插拔耳机线&#x2F;数据线</p><p>网络测试</p><p>1、三大运营商不同网络制式测试</p><p>2、网络切换测试：WIFI&#x2F;4G&#x2F;3G&#x2F;2G</p><p>3、无网测试：对于缓存在本地的数据，部分朋友圈信息是否支持浏览</p><p>4、弱网测试：</p><p>a、延时：页面响应时间是否可接受、不同网络制式是否区分超时时长、出现请求超时，是否给予相应的提示</p><p>b、丢包：有无超时重连机制、如果未响应，是否给予相应提示</p><p>c、页面呈现的完整性验证</p><p>兼容性测试</p><p>1、Android手机端、苹果手机端、pad版（主流）功能界面显示是否正常</p><p>2、各平台朋友圈展示数据是否一致</p><p>安全测试</p><p>发送朋友圈时，文本输入脚本代码，是否出现异常</p><p>性能测试</p><p>1、服务器性能测试</p><p>可通过loadrunner&#x2F;jmeter工具实现，主要关注TPS、响应时间、吞吐量、CPU、内存等</p><p>2、app客户端性能测试</p><p>可通过GT工具实现，运行时关注cpu、内存、流量、电量等占用率</p><p>3、app压力稳定性测试</p><p>通过monkey工具实现，频繁发送朋友圈，浏览朋友圈请求，是否容易发生崩溃</p><h2 id="测开岗高频算法题"><a href="#测开岗高频算法题" class="headerlink" title="测开岗高频算法题"></a>测开岗高频算法题</h2><p><strong>测开岗的算法题难度相对要低一些，差不多都是剑指offer上或者力扣上的热门且难度为简单、中等的题。把每个标签的前5~10道题刷一刷，面试的时候基本够用。</strong></p><p>三个数字的最大乘积</p><p>有两个很长很很长的字符串，但是字符都是数字，实现这俩字符串的加法，输出为一个字符串。如str1&#x3D;”1231213347845713824718237489123748343246217489132”, str2&#x3D;”623478573127438912743892017489132748172341324132”</p><p>两数之和 标签：哈希表 （★★★）</p><p>str1能不能最多交换两次字符变成str2，并设计测试用例。</p><p>和为s的连续正数序列 标签：暴力、双指针</p><p>有效括号 标签：栈 （★★★★）</p><p>数组中重复的数字 标签：哈希表 （★★★★★）</p><p>7的倍数或者包含7打印”-“，其余的打印数字，每行不超过5个数字</p><p>从1到100000000中取出一个数(自己申明一个变量，比如num &#x3D; 2333)，写代码找出取出的是哪个数。    标签：二分查找</p><p>一个数在有序数组里出现的次数。标签：二分</p><p>字符串转整数，并写测试用例。    标签：数学，有很多非数字类型需要考虑，还有数字越界的情况需要考虑，比较考察测试思维 （★★★★★）</p><p>连续子数组的最大和 标签：分治、DP （★★★★）</p><p>在字符串中找出没有重复字符的最长的连续子串，并返回子串及长度，譬如“aaabcdcbcbbb” 最长子串为abcd，长度为4</p><p>判断链表是否有环 标签：双指针</p><p>两个栈实现一个队列 （★★）</p><p>最长不含重复字符的子字符串 标签：双指针、滑动窗口 （★★★★★）</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>暑期实习复盘</title>
      <link href="/undefined/20a82735.html"/>
      <url>/undefined/20a82735.html</url>
      
        <content type="html"><![CDATA[<h2 id="网易互娱游戏测试"><a href="#网易互娱游戏测试" class="headerlink" title="网易互娱游戏测试"></a>网易互娱游戏测试</h2><h3 id="一面-1小时"><a href="#一面-1小时" class="headerlink" title="一面(1小时)"></a>一面(1小时)</h3><ul><li><p>自我介绍</p></li><li><p>脑机接口具体研究内容</p></li><li><p>最近有玩过什么游戏吗<br>回答了街头霸王6 哈迪斯</p></li><li><p>格斗游戏小众，你喜欢玩这个游戏原因是什么</p></li><li><p>为什么格斗游戏小众，为什么没有扩展开来</p><ul><li>上手难度高，机制会比较复杂</li><li>挫败感比较强</li><li>设备成本高，缺乏便携性</li><li>兴起于街机厅</li><li>付费购买</li></ul></li><li><p>游戏中设置机器人让玩家获得正反馈，为什么格斗游戏不能这么做</p><ul><li>pve不是游戏的核心</li><li>即使有ai加持，操作模式死板，取巧攻略</li><li>人是各种各样的，随机性更强</li></ul></li><li><p>moba类游戏可以盛行的原因是什么？和格斗游戏的区别在哪里？</p><ul><li>硬件成本比较低</li><li>付费成本低，大部分免费</li><li>新手用户多，不容易被虐</li><li>社群做的很好，社交属性强</li><li>moba类游戏上手简单</li></ul></li><li><p>格斗游戏做成免费，皮肤卖钱 会有什么问题？</p><ul><li>可以尝试</li></ul></li><li><p>没有人这么干的原因</p><ul><li>制作成本比较高，圈子小 不挣钱，所以只要找准用户定位</li></ul></li><li><p>如何向年轻人推广</p><ul><li>加强键盘适配，降低硬件成本</li><li>简易出招模式</li><li>尝试手游格斗，让大家尝试一下</li></ul></li><li><p>手游最近在玩什么？</p><ul><li>穿越火线手游</li><li>爆破模式 互相配合 游戏机制有趣</li></ul></li><li><p>其他类型 和平精英玩过没？现在为什么不玩了</p><ul><li>手游fps手感不好，交互体现很好。</li></ul></li><li><p>和平精英玩的人很多，为什么会有受众群体?</p><ul><li>便携性和社交属性</li></ul></li><li><p>非腾讯系的游戏无法背靠qq 微信通讯软件，如何做社交属性的开发？</p><ul><li>利用第三方社交平台交流互动</li><li>游戏内部搭建工会 社团 世界平台</li><li>接入qq 微信的分享功能</li></ul></li><li><p>游戏内如何做交流平台 实现什么样的功能？</p><ul><li>围绕竞争和合作两个方向来做</li><li>合作方面：按流派玩法门派职业进行分类，让类似玩家进行合作和交流</li><li>竞争： pk关系 排行榜</li><li>其他的：玩家工会等等其他常见方案</li></ul></li><li><p>排行榜用什么数据结构来实现</p><ul><li>考虑到数据唯一 有序 不可重复 可使用有序表 sortedlist</li></ul></li><li><p>玩家数量很多一次性把上千万玩家放到一个list会爆内存怎么办</p><ul><li>加锁 进行并发控制</li></ul></li><li><p>指出我理解错误，意思是把所有玩家数据加载到一个list内存会放不下怎么办？</p><ul><li>内存扩容</li><li>对数据进行过滤</li></ul></li><li><p>如何做过滤</p><ul><li>做排序 然后再选区要的部分</li></ul></li><li><p>做排序还是要把数据一次性读出来，还有没有别的方案？</p><ul><li>使用一个区间进行初次过滤，筛选掉大部分玩家，然后再排序</li></ul></li><li><p>筛选区间如何设置？</p><ul><li>用统计学上的分布进行判断</li></ul></li><li><p>假设排行榜上一开始所有的数据都是0 该怎么办？</p><ul><li>没懂让再解释一下</li></ul></li><li><p>假设一开始全是0 不就没法筛选了吗？这时候怎么办?</p><ul><li>答了不会</li></ul></li><li><p>sortedlist底层实现是什么？如何保证有序的？</p><ul><li>没有深入了解过，但是我觉得应该是数组+链表</li><li>数组用来存，链表保证有序</li></ul></li><li><p>解释一下你的思路</p><ul><li>链表保存前后关系，实现类似于hashtable</li></ul></li><li><p>保证链表插入有序的时间复杂度？</p><ul><li>O(n)</li></ul></li><li><p>对一个链表进行重新排序的思路和时间复杂度</p><ul><li>没想到好方法，回答了暴力思路 😭 O(n^2)</li></ul></li><li><p>你这个时间复杂度超过了大部份常用排序算法，你为什么要用复杂度这么高的链表</p><ul><li>我说确实不太合适，得具体看业务场景，然后回答了使用链表的好处说了插入方便，不用占用连续内存空间，然后面试官就说ok了</li></ul></li><li><p>为一个函数设计测试用例：有序链表再插入一个新的值之后，仍然有序。</p><ul><li>懵逼，回答了不同位置插入；不同数据类型插入；高频词插入(面试的时候组织不起来语言，说一直插有够尴尬)</li></ul></li><li><p>反问</p></li></ul><h2 id="二面-55分钟"><a href="#二面-55分钟" class="headerlink" title="二面(55分钟)"></a>二面(55分钟)</h2><ul><li>自我介绍</li><li>为什么投这个岗位</li><li>除了这个岗位还考虑什么岗位</li><li>简历上的测试项目，项目背景等等拷打</li><li>自动化测试 web场景的思路，具体做了什么？</li><li>错误码有哪些？</li><li>为什么要做这个项目（简历上的</li><li>白盒黑盒测试相关</li><li>你觉得你网上下的项目里的项目质量怎么样，学到了什么</li><li>评价一下自己的编码能力</li><li>有大型项目经历吗？平时代码量怎么样？</li><li>手撕shell脚本 批量文件重命名（简单</li><li>为什么平时开发要用linux 脚本为什么不用python，而用shell和lua</li><li>如何调试你刚刚写的代码</li><li>做过最大型的项目是什么</li><li>论文进度？</li><li>后面就是压力面相关，加班、同事关系等等</li><li>大家对你的评价</li></ul><h2 id="hr面-很快，全程约15分钟"><a href="#hr面-很快，全程约15分钟" class="headerlink" title="hr面(很快，全程约15分钟)"></a>hr面(很快，全程约15分钟)</h2><ul><li>自我介绍</li><li>项目</li><li>项目中担任的角色</li><li>项目中遇到的最大的困难</li><li>三个关键词形容自己</li><li>加班等压力面相关</li><li>为什么选择这个岗位</li><li>了解过别的游戏公司吗</li><li>职业规划</li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/undefined/0.html"/>
      <url>/undefined/0.html</url>
      
        <content type="html"><![CDATA[<h2 id="你做游戏测试的职业规划？"><a href="#你做游戏测试的职业规划？" class="headerlink" title="你做游戏测试的职业规划？"></a>你做游戏测试的职业规划？</h2><ol><li>首先作为一个游戏的重度爱好者，从事游戏行业一直是我的理想，能将自己的兴趣和工作结合起来，真的是一件很棒的事情</li><li>要扎实专业技能，因为先前很少有实际应用于游戏场景的测试经验，所以在刚迈入工作岗位的时候，有必要在业务中强化自己的专业能力，做好本职工作，积累经验。</li><li>其次作为一名测试人员，我认为丰富的知识面也是相当重要的，测试是产品上线之前的最后一道工序，在测试中检测出问题的时候，需要经常需要和开发、策划人员进行沟通和反馈，所以自己本身对于业务的技术框架也必须是熟悉的，也许不需要对细节有多么深入的理解，但是一定要有一个宏观上的把控,所以我会努力去拓展自己的知识面，不仅仅是将眼光局限于测试技能，而是也要加强自己的代码能力，强化数据库、微服务等知识。</li><li>除了技能上的锻炼，作为游戏行业的测试，不同于其他测试岗位，对于游戏行业的风向和市场的偏好也必须有深刻的理解，一个不懂游戏的人去担任游戏行业的从业者显然是一件很糟糕的事情。</li><li>还有的话，我认为不断提高自己的软实力也是非常有必要的，在有了一定的积累之后，将不再单单局限于测试本身，而是会进行更加宏观的设计，比如测试策略的指制定、测试进度的把控，同时要提升自己的人际交往能力，尤其是沟通和表达能力，有的时候这个也许比技术本身还要重要。</li></ol><h2 id="你做测试的优势在哪里"><a href="#你做测试的优势在哪里" class="headerlink" title="你做测试的优势在哪里"></a>你做测试的优势在哪里</h2><ul><li>首先我对游戏充满了热爱，同时对平时在游玩中遇到的bug和错误深恶痛绝，如果能成为一名游戏测试人员，那么就有机会在遇到检测出这些问题，这让我感到很兴奋</li><li>其次我对多种编程语言都有一定的涉猎，主学的是java，也自学过python，同时在维护和配置自己的archlinux系统和neovim编辑器的时候，经常会接触到shell和lua语言，对他们都有一定的了解</li><li>我有强烈的探索欲望和持之以恒的品质，不怕麻烦，不畏难，并乐于总结经验，进行分享。提及自己在配置和使用neovim和archlinux中遇到的问题和收获</li><li>我有较强的语言表达能力和人际交往能力，兴趣广泛，容易与人相处，作为一名测试人员，往往需要及时整理测试文档，与开发人员和策划人员进行沟通和接洽，所以必须要有这方面的能力，我喜欢与人交往，乐于表现，读书期间曾多次参加志愿者展演，也曾经在毕业晚会的舞台上登台演出。</li></ul><h2 id="你找工作的时候，最重要的考虑因素是什么？为什么"><a href="#你找工作的时候，最重要的考虑因素是什么？为什么" class="headerlink" title="你找工作的时候，最重要的考虑因素是什么？为什么"></a>你找工作的时候，最重要的考虑因素是什么？为什么</h2><ul><li>最重要的因素是岗位与自身的契合度，我认为岗位与人的匹配是非常重要的。</li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>小说精品屋学习笔记</title>
      <link href="/undefined/e48fb72f.html"/>
      <url>/undefined/e48fb72f.html</url>
      
        <content type="html"><![CDATA[<h2 id="技术栈"><a href="#技术栈" class="headerlink" title="技术栈"></a>技术栈</h2><ul><li>后端技术：MYSQL Redis Undertow Nginx</li><li>前端技术：Vue axios element-plus</li></ul><h2 id="数据库设计"><a href="#数据库设计" class="headerlink" title="数据库设计"></a>数据库设计</h2><h2 id="项目开发"><a href="#项目开发" class="headerlink" title="项目开发"></a>项目开发</h2><h3 id="通用请求-响应数据格式的封装"><a href="#通用请求-响应数据格式的封装" class="headerlink" title="通用请求&#x2F;响应数据格式的封装"></a>通用请求&#x2F;响应数据格式的封装</h3><h4 id="错误码使用枚举类"><a href="#错误码使用枚举类" class="headerlink" title="错误码使用枚举类"></a>错误码使用枚举类</h4><ul><li>错误码为字符串类型，共 5 位，分成两个部分：错误产生来源+四位数字编号。</li><li>错误产生来源分为 A&#x2F;B&#x2F;C， A 表示错误来源于用户，比如参数错误，用户安装版本过低，用户支付</li><li>超时等问题； B 表示错误来源于当前系统，往往是业务逻辑出错，或程序健壮性差等问题； C 表示错误来源于第三方服务，比如 CDN 服务出错，消息投递超时等问题；四位数字编号从 0001 到 9999，大类之间的步长间距预留 100。</li><li>错误码分为一级宏观错误码、二级宏观错误码、三级宏观错误码。</li><li>在无法更加具体确定的错误场景中，可以直接使用一级宏观错误码。</li></ul><h4 id="跨域配置"><a href="#跨域配置" class="headerlink" title="跨域配置"></a>跨域配置</h4><p>跨域是指浏览器从一个域名的网页去请求另一个域名的资源时，域名、端口、协议任一不同，都是跨域。在前后端分离的模式下，前后端的域名是不一致的，此时就会发生跨域访问问题。</p><p>跨域是出于浏览器的同源策略限制，同源策略（Sameoriginpolicy）是一种约定，它是浏览器最核心也最基本的安全功能，如果缺少了同源策略，则浏览器的正常功能可能都会受到影响。</p><p>我们可以通过前端配置、后端配置或 nginx 配置来解决跨域问题。</p><p>如果选择前端配置，我们可以使用 node 中间件 proxy 配置跨域，前端通过 node proxy 来转发我们的接口请求，和浏览器直接打交道的是 node proxy，这样可以避免浏览器的同源策略。</p><p>因为我们项目的侧重点在后端，而且 Spring MVC 提供了跨域解决方案（CORS (opens new window)）的支持。所以我们这里通过后端配置来解决跨域问题。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Diary</title>
      <link href="/undefined/50bac2e6.html"/>
      <url>/undefined/50bac2e6.html</url>
      
        <content type="html"><![CDATA[<h2 id="2024-06-15-16-03-59"><a href="#2024-06-15-16-03-59" class="headerlink" title="2024&#x2F;06&#x2F;15 16:03:59"></a>2024&#x2F;06&#x2F;15 16:03:59</h2><p>测试理论需要看的书：《软件测试的艺术》</p><p>数据库要多动手敲语句</p><p>算法：剑指offer还是得看看;首推codetop 可以按高频，10道题一组，一组练个两三轮。<br>以”容易“难度为主</p><p>编程语言：可以把python熟悉一下</p><p>不熟练的最好不要写在简历上</p><p><a href="https://link.zhihu.com/?target=https://www.nowcoder.com/discuss/607662?channel=-1&source_id=profile_follow_post_nctrack">测试开发岗-高频知识整理【校招】</a></p><p><a href="https://link.zhihu.com/?target=https://www.nowcoder.com/discuss/628372?channel=-1&source_id=profile_follow_post_nctrack">春招测开岗面试高频考点万字汇总</a></p><p>这里按重要性将知识点的类别排个序，除必选外，选择一个多花2天精通。</p><p>1）测试理论 【必选】 0.5天<br>2）编程语言 【必选】 java、python、C++ 1.5天</p><ul><li><input disabled="" type="checkbox"> 自动化测试项目练手</li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>八股文骚套路之操作系统</title>
      <link href="/undefined/2d72da9e.html"/>
      <url>/undefined/2d72da9e.html</url>
      
        <content type="html"><![CDATA[<p><a href="https://mubu.com/app/edit/home/5Vbsc1GjSNm">八股-操作系统</a></p><h2 id="内核态和用户态和系统调用"><a href="#内核态和用户态和系统调用" class="headerlink" title="内核态和用户态和系统调用"></a>内核态和用户态和系统调用</h2><p>根据进程访问资源的特点，把进程在系统上的运行分为用户态和内核态</p><p>用户态具有较低的数据访问权限，可直接读取用户程序的数据，而内核态拥有较高的权限，几乎可以访问计算机的任何资源，当应用程序需要执行某些特殊权限的操作的时候，会通过系统调用切换到内核态</p><p>把进程分为用户态和内核态是出于安全性和性能上的考虑</p><p>用户态和内核态之间的切换有系统调用、中断、异常三种方式</p><p>系统调用是主动用户态进程主动要求切换的一种方式，通过系统调用，应用程序可以和操作系统之间进行交互，访问操作系统底层资源（文件、设备、网络</p><p>中断是外部设备完成用户操作请求之后，向cpu发出中断信号，这时cpu会暂停执行吓一跳指令先去执行中断信号对应的程序，如果中断之前执行的是用户态程序，那么此时就自然而然的发生了用户态到内核态之间的切换</p><p>异常是cpu在执行用户态程序的时候，发生了不可知的异常，此时进程会切换到异常处理的内核相关程序中，也就切换到了内核态。</p><h2 id="进程和线程（重要）"><a href="#进程和线程（重要）" class="headerlink" title="进程和线程（重要）"></a>进程和线程（重要）</h2><h3 id="进程和线程的基本定义，然后再让你对比一下两者"><a href="#进程和线程的基本定义，然后再让你对比一下两者" class="headerlink" title="进程和线程的基本定义，然后再让你对比一下两者"></a>进程和线程的基本定义，然后再让你对比一下两者</h3><ul><li>进程是计算机上正在运行的一个程序的实例</li><li>线程也被称为轻量级进程,是进程被划分为更小的运行单位。</li><li>一个程序至少有一个进程，一个进程至少有一个线程</li><li>进程和进程之间不共享资源是独立的，线程和线程之间共享同一个进程的资源,且有可能互相影响</li></ul><h3 id="进程和线程的状态"><a href="#进程和线程的状态" class="headerlink" title="进程和线程的状态"></a>进程和线程的状态</h3><p>我们一般把进程大致分为 5 种状态，这一点和线程很像,</p><ol><li>创建状态(new)：进程正在被创建</li><li>就绪状态(ready)：进程已处于准备运行状态，即进程获得了除了处理器之外的一切所需资源，一旦得到处理器资源(处理器分配的时间片)即可运行</li><li>运行状态(running)</li><li>阻塞状态(waiting)：又称为等待状态，进程正在等待某一事件而暂停运行如等待某资源为可用或等待 IO 操作完成。即使处理器空闲，该进程也不能运行。</li><li>结束状态(terminated)</li></ol><h2 id="内存管理（重要）"><a href="#内存管理（重要）" class="headerlink" title="内存管理（重要）"></a>内存管理（重要）</h2><h3 id="内存管理的目的、逻辑和物理地址"><a href="#内存管理的目的、逻辑和物理地址" class="headerlink" title="内存管理的目的、逻辑和物理地址"></a>内存管理的目的、逻辑和物理地址</h3><ul><li>内存的分配与回收：对进程所需的内存进行分配和释放，malloc 函数：申请内存，free 函数：释放内存。</li><li>地址转换：将程序中的虚拟地址转换成内存中的物理地址。</li><li>内存扩充：当系统没有足够的内存时，利用虚拟内存技术或自动覆盖技术，从逻辑上扩充内存。</li><li>内存映射：将一个文件直接映射到进程的进程空间中，这样可以通过内存指针用读写内存的办法直接存取文件内容，速度更快。</li><li>内存优化：通过调整内存分配策略和回收算法来优化内存使用效率。</li><li>内存安全：保证进程之间使用内存互不干扰，避免一些恶意程序通过修改内存来破坏系统的安全性。</li></ul><h3 id="内存管理机制"><a href="#内存管理机制" class="headerlink" title="内存管理机制"></a>内存管理机制</h3><ul><li><p>连续内存管理：为一个用户程序分配一个连续的内存空间，内存利用率一般不高。容易产生内存碎片</p></li><li><p>非连续内存管理：允许一个程序使用的内存分布在离散或者说不相邻的内存中，相对更加灵活一些。</p></li></ul><h3 id="虚拟内存和请求分页"><a href="#虚拟内存和请求分页" class="headerlink" title="虚拟内存和请求分页"></a>虚拟内存和请求分页</h3><p>虚拟内存(Virtual Memory)本质上来说它只是逻辑存在的，是一个假想出来的内存空间<br>它允许程序访问比实际物理内存更大的内存空间。<br>在使用虚拟内存的系统中，每个程序都认为它拥有连续的、私有的内存空间，这被称为虚拟地址空间</p><p>**<br>  虚拟内存的主要主要作用：<br>**</p><ul><li>隔离进程：物理内存通过虚拟地址空间访问，虚拟地址空间与进程一一对应。每个进程都认为自己拥有了整个物理内存，进程之间彼此隔离，一个进程中的代码无法更改正在由另一进程或操作系统使用的物理内存。</li><li>提升物理内存利用率：有了虚拟地址空间后，操作系统只需要将进程当前正在使用的部分数据或指令加载入物理内存。</li><li>简化内存管理：进程都有一个一致且私有的虚拟地址空间，程序员不用和真正的物理内存打交道，而是借助虚拟地址空间访问物理内存，从而简化了内存管理。</li><li>多个进程共享物理内存：进程在运行过程中，会加载许多操作系统的动态库。这些库对于每个进程而言都是公用的，它们在内存中实际只会加载一份，这部分称为共享内存。</li><li>提高内存使用安全性：控制进程对物理内存的访问，隔离不同进程的访问权限，提高系统的安全性。</li><li>提供更大的可使用内存空间：可以让程序拥有超过系统物理内存大小的可用内存空间。<br>这是因为<strong>当物理内存不够用时，可以利用磁盘充当</strong>，将物理内存页（通常大小为 4 KB）保存到磁盘文件（会影响读写速度），数据或代码页会根据需要在物理内存与磁盘之间移动。</li></ul><p><strong>局部性原理</strong>是指在程序执行过程中，数据和指令的访问存在一定的空间和时间上的局部性特点。其中，时间局部性是指一个数据项或指令在一段时间内被反复使用的特点，空间局部性是指一个数据项或指令在一段时间内与其相邻的数据项或指令被反复使用的特点。</p><ul><li>请求分页 ： 页表机制、缺页中断、页面置换算法</li></ul><h2 id="虚拟地址和物理地址"><a href="#虚拟地址和物理地址" class="headerlink" title="虚拟地址和物理地址"></a>虚拟地址和物理地址</h2><p>虚拟地址是程序开发时程序员与程序员进行交互的地址<br>物理地址就是内存地址寄存器中真正的地址</p><p>MMU(memeory management unit)将虚拟地址转化为物理地址,这个过程称之为<strong>地址转换</strong></p><p>而地址转换有两种方式:</p><p><strong>分段机制</strong>和<strong>分页机制</strong></p><p>分段机制以一段连续的物理内存管理（不同长度的段）和分配物理内存，通过段表来映射虚拟地址和物理地址</p><p>分页机制把物理内存分为<strong>连续等长</strong>的物理页，通过页表来映射地址,虚拟地址空间中的任意虚拟页可以被映射到任意的物理页上，所以可以实现物理内存资源的离散分配</p><h2 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h2><p>多个进程&#x2F;线程同时被阻塞，它们中的一个或者全部都在等待某个资源被释放。由于进程&#x2F;线程被无限期地阻塞，因此程序不可能正常终止。</p><h3 id="死锁的必要条件"><a href="#死锁的必要条件" class="headerlink" title="死锁的必要条件"></a>死锁的必要条件</h3><p>互斥、占有并等待、非抢占（资源不能被抢占，只能完成任务之后主动释放、循环等待</p><h3 id="死锁预防、避免、检测与解除"><a href="#死锁预防、避免、检测与解除" class="headerlink" title="死锁预防、避免、检测与解除"></a>死锁预防、避免、检测与解除</h3><p>预防死锁的方法，是通过考虑破坏第二个条件和第四个条件。</p><ol><li>静态分配策略静态分配策略破坏死锁产生的第二个条件（占有并等待）。<br>静态分配策略，指一个进程必须在执行前就申请到它所需要的全部资源，并且知道它所要的资源都得到满足之后才开始执行。进程要么占有所有的资源然后开始执行，要么不占有资源。静态分配策略逻辑简单，实现也很容易，但这种策略 严重地降低了资源利用率，</li><li>层次分配策略破坏了产生死锁的第四个条件(循环等待)。所有的资源被分成了多个层次，一个进程得到某一次的一个资源后，它只能再申请较高一层的资源；当一个进程要释放某层的一个资源时，必须先释放所占用的较高层的资源，这样不会发生循环等待。</li></ol><p>常用的解除死锁的方法有以下四种：</p><ol><li>立即结束所有进程的执行，重新启动操作系统</li><li>撤销涉及死锁的所有进程，解除死锁后继续运行</li><li>逐个撤销涉及死锁的进程，回收其资源直至死锁解除。</li><li>抢占资源：从涉及死锁的一个或几个进程中抢占资源，把夺得的资源再分配给涉及死锁的进程直至死锁解除。</li></ol><h2 id="CPU-调度"><a href="#CPU-调度" class="headerlink" title="CPU 调度"></a>CPU 调度</h2><h3 id="几种常见的-CPU-调度算法"><a href="#几种常见的-CPU-调度算法" class="headerlink" title="几种常见的 CPU 调度算法"></a>几种常见的 CPU 调度算法</h3><ul><li>先到先服务调度(First-Come First-Served Scheduling，FCFS)</li><li>最短作业优先调度(Shortest Job First，SJF)</li><li>优先级调度（Priority Scheduling）</li><li>轮转法调度(Round Robin，RR)</li></ul><p>多级队列调度（Multilevel Queue） 就诞生了。简单来说就是把就绪队列（存放有待执行进程）分成多个独立队列，每个队列都有自己的调度算法。</p><h2 id="Linux相关（重要）"><a href="#Linux相关（重要）" class="headerlink" title="Linux相关（重要）"></a>Linux相关（重要）</h2><h3 id="Linux-常用命令"><a href="#Linux-常用命令" class="headerlink" title="Linux 常用命令"></a>Linux 常用命令</h3><p>1.cd 切换目录，2.mkdir创建目录,3.mv移动或重命名 ,4.cp复制, 5.touch 创建文件 7.find查找8.cat&#x2F;tail&#x2F;head&#x2F;less查看  9.ps-ef查看进程 10.ifconfig 查看ip地址 11.rm删除</p><ul><li><p>file:file通过探测文件内容判断文件类型，使用权限是所有用户</p></li><li><p>grep:grep命令可以指定文件中搜索特定内容，并将含有这些内容的行标准输出</p></li><li><p>tar：对文件进行打包，调用gzip或bzip对文件进行压缩或解压</p></li><li><p>查看进程：ps -ef|grep 进程id  【ps:将某个进程显示出来 -A 　显示所有程序。  -e 　此参数的效果和指定”A”参数相同。 -f 　显示UID,PPIP,C与STIME栏位。】</p></li><li><p>杀死叫firefox的进程：ps aux| grep firefox | awk ‘{print $2}’ |xargs kill  *</p></li></ul><p>xargs 命令是用来把前面命令的输出结果(PID)作为“kill -s 9”命令的参数，并执行该命令</p><p>$pkill -９ firefox *说明：pkill＝pgrep+kill，”-9” 即发送的信号是9，</p><p>pkill与kill在这点的差别是：pkill无须 “ｓ”，终止信号等级直接跟在 “-“ 后面</p><p>pgrep的p表明了这个命令是专门用于进程查询的grep</p><p>查看端口号: netstat –tunlp|grep 端口号或lsof -i:端口号</p><h3 id="如何查看Linux系统进程？"><a href="#如何查看Linux系统进程？" class="headerlink" title="如何查看Linux系统进程？"></a>如何查看Linux系统进程？</h3><p>通过ps命令可以查看当前系统运行的进程的列表，包括PID，进程名，CPU占用百分比，内存占用等信息。</p><p>可以使用top命令来查看Linux系统正在运行的进程。</p><h3 id="如何查看a-txt的第7到第9行？"><a href="#如何查看a-txt的第7到第9行？" class="headerlink" title="如何查看a.txt的第7到第9行？"></a>如何查看a.txt的第7到第9行？</h3><ul><li><p>cat a.txt | tail -n +7 | head -n 9</p></li><li><p>sed -n ‘7,9p’ a.txt</p></li></ul><h3 id="查看文件a-txt的前3行"><a href="#查看文件a-txt的前3行" class="headerlink" title="查看文件a.txt的前3行"></a>查看文件a.txt的前3行</h3><p>cat a.txt | head -n 3 或 head a.txt -n 3 (后3行用tail)</p><h3 id="查看文件a-txt，显示第50行到第200行"><a href="#查看文件a-txt，显示第50行到第200行" class="headerlink" title="查看文件a.txt，显示第50行到第200行"></a>查看文件a.txt，显示第50行到第200行</h3><pre><code>cat a.txt | head -n 200 | tail -n +50tail -n +50：从50行开始显示，显示50行以后的head -n 200：显示前面200行</code></pre><h3 id="查看a-txt文件的第5行"><a href="#查看a-txt文件的第5行" class="headerlink" title="查看a.txt文件的第5行"></a>查看a.txt文件的第5行</h3><pre><code>awk &#39;NR==5&#39; a.txthead -n 5 a.txt | tail -n 1sed -n 5p</code></pre><h3 id="一个文件中字段以逗号隔开，如何查看某一列的所有的数据？"><a href="#一个文件中字段以逗号隔开，如何查看某一列的所有的数据？" class="headerlink" title="一个文件中字段以逗号隔开，如何查看某一列的所有的数据？"></a>一个文件中字段以逗号隔开，如何查看某一列的所有的数据？</h3><pre><code>awk -F[,] &#39;&#123;print $10&#125;&#39;</code></pre><h3 id="如何查看程序运行时的某个端口？"><a href="#如何查看程序运行时的某个端口？" class="headerlink" title="如何查看程序运行时的某个端口？"></a>如何查看程序运行时的某个端口？</h3><pre><code>lsof -i :&lt;端口号&gt;</code></pre><h3 id="Linux-文件系统"><a href="#Linux-文件系统" class="headerlink" title="Linux 文件系统"></a>Linux 文件系统</h3><p>常见目录说明：</p><ul><li>&#x2F;bin： 存放二进制可执行文件(ls、cat、mkdir 等)，常用命令一般都在这里；</li><li>&#x2F;etc： 存放系统管理和配置文件；</li><li>&#x2F;home： 存放所有用户文件的根目录，是用户主目录的基点，比如用户 user 的主目录就是&#x2F;home&#x2F;user，可以用~user 表示；</li><li>&#x2F;usr： 用于存放系统应用程序；</li><li>&#x2F;opt： 额外安装的可选应用程序包所放置的位置。一般情况下，我们可以把 tomcat 等都安装到这里；</li><li>&#x2F;proc： 虚拟文件系统目录，是系统内存的映射。可直接访问这个目录来获取系统信息；</li><li>&#x2F;root： 超级用户（系统管理员）的主目录（特权阶级^o^）；</li><li>&#x2F;sbin: 存放二进制可执行文件，只有 root 才能访问。这里存放的是系统管理员使用的系统级别的管理命令和程序。如 ifconfig 等；</li><li>&#x2F;dev： 用于存放设备文件；</li><li>&#x2F;mnt： 系统管理员安装临时文件系统的安装点，系统提供这个目录是让用户临时挂载其他的文件系统；</li><li>&#x2F;boot： 存放用于系统引导时使用的各种文件；</li><li>&#x2F;lib 和&#x2F;lib64： 存放着和系统运行相关的库文件 ；</li><li>&#x2F;tmp： 用于存放各种临时文件，是公用的临时文件存储点；</li><li>&#x2F;var： 用于存放运行时需要改变数据的文件，也是某些大文件的溢出区，比方说各种服务的日志文件（系统启动日志等。）等；</li><li>&#x2F;lost+found： 这个目录平时是空的，系统非正常关机而留下“无家可归”的文件（windows 下叫什么.chk）就在这里。</li></ul><h3 id="僵尸进程和孤儿进程"><a href="#僵尸进程和孤儿进程" class="headerlink" title="僵尸进程和孤儿进程"></a>僵尸进程和孤儿进程</h3><ul><li><p>僵尸进程：子进程已经终止，担父进程仍然在运行，而且父进程没有调用wait或waitpid等系统调用来释放子进程占用的资源。这种情况下的子进程称为僵尸进程</p></li><li><p>孤儿进程：父进程没了，但是子进程仍然在运行</p></li></ul><p>Linux可以通过top指令来查看僵尸进程，zombie的值标识僵尸进程的数量</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>八股文骚套路之数据结构</title>
      <link href="/undefined/faaf69f9.html"/>
      <url>/undefined/faaf69f9.html</url>
      
        <content type="html"><![CDATA[<p><a href="https://mubu.com/app/edit/home/1cv82aWbhSC">八股数据结构</a></p><h2 id="b树和b-树的区别"><a href="#b树和b-树的区别" class="headerlink" title="b树和b+树的区别"></a>b树和b+树的区别</h2><ul><li>存储方式: 节点存什么东西？（数据 索引）</li><li>节点指针: B树中的节点包含指向子节点的指针，而B+树中的内部节点只包含键值和指向下一级节点的指针 <strong>不包含指向具体数据的指针</strong>。所有的数据都存储在叶子节点中，通过叶子节点的链表顺序访问数据。</li><li>范围查询: 由于B+树的叶子节点形成了有序链表，所以在B+树上进行范围查询非常高效，只需要遍历叶子节点的链表即可</li><li>使用场景: b树节点包含数据，适用于随机访问；b+树叶子节点形成有序链表，适用于顺序访问和范围查询</li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>八股文骚套路之计算机网络</title>
      <link href="/undefined/101a7be.html"/>
      <url>/undefined/101a7be.html</url>
      
        <content type="html"><![CDATA[<p>面试过程中偏向与应用，所以问的比较多的也就是应用层、运输层、网络层的协议，物理层和数据链路层的东西面试基本不会被问到，所以准备面试过程中这块就不用看了。<br><a href="https://mubu.com/app/edit/home/4IsX074ceSC">八股-网络协议</a></p><h2 id="OSI七层模型"><a href="#OSI七层模型" class="headerlink" title="OSI七层模型"></a>OSI七层模型</h2><p>物理层 数据链路层 网络层 传输层 会话层 表示层 应用层</p><p>物理层 数据链路层 网络层 传输层 应用层</p><h2 id="在搜索框输入www-baidu-com，发生了什么？"><a href="#在搜索框输入www-baidu-com，发生了什么？" class="headerlink" title="在搜索框输入www.baidu.com，发生了什么？"></a>在搜索框输入<a href="http://www.baidu.com，发生了什么？">www.baidu.com，发生了什么？</a></h2><ol><li>在浏览器中输入指定网页的 URL。</li><li>浏览器通过 DNS 协议，获取域名对应的 IP 地址。</li><li>浏览器根据 IP 地址和端口号，向目标服务器发起一个 TCP 连接请求。</li><li>TCP连接建立之后，浏览器在 TCP 连接上，向服务器发送一个 HTTP 请求报文，请求获取网页的内容。</li><li>服务器收到 HTTP 请求报文后，处理请求，并返回 HTTP 响应报文给浏览器。</li><li>浏览器收到 HTTP 响应报文后，解析响应体中的 HTML 代码，渲染网页的结构和样式，同时根据 HTML 中的其他资源的 URL（如图片、CSS、JS 等），再次发起 HTTP 请求，获取这些资源的内容，直到网页完全加载显示。</li><li>浏览器在不需要和服务器通信时，可以主动关闭 TCP 连接，或者等待服务器的关闭请求。</li></ol><h2 id="http-和-https-的区别"><a href="#http-和-https-的区别" class="headerlink" title="http 和 https 的区别"></a>http 和 https 的区别</h2><h3 id="http"><a href="#http" class="headerlink" title="http"></a>http</h3><ul><li>超文本传输协议</li><li>明文传输</li><li>基于请求和响应</li><li>无状态</li><li>应用层协议</li><li>端口80</li></ul><h3 id="https"><a href="#https" class="headerlink" title="https"></a>https</h3><ul><li>http + ssl&#x2F;tls</li><li>具有加密性质的SSL加密传输协议</li><li>由http通信</li><li>利用ssl&#x2F;tls建立信道</li><li>端口443</li><li>需要证书</li></ul><h2 id="详细介绍一下ssl-TLS"><a href="#详细介绍一下ssl-TLS" class="headerlink" title="详细介绍一下ssl&#x2F;TLS"></a>详细介绍一下ssl&#x2F;TLS</h2><p>运行在TCP上，加密采用对称加密</p><h3 id="什么是对称加密"><a href="#什么是对称加密" class="headerlink" title="什么是对称加密"></a>什么是对称加密</h3><p>通信双方共享唯一密钥K 加解密算法已知 相比非对称加密 代价小 但是安全性较低</p><h2 id="http-请求报文"><a href="#http-请求报文" class="headerlink" title="http 请求报文"></a>http 请求报文</h2><ul><li>请求方法</li><li>GET: 请求<strong>获取</strong>request——URL所标识的资源</li><li>POST：在Request——URL所标识的资源后附加资源(向指定的资源<strong>提交</strong>要被处理的数据)</li><li>HEAD：请求获取由Request——URL所标识的资源的响应消息报头</li><li>PUT：请求服务器存储一个资源，由Request——URL作为其标识  </li><li>DELETE：请求服务器删除由Request——URL所标识的资源</li><li>TRACE：请求服务器回送收到的请求信息（用于测试和诊断）</li><li>CONNECT：保留</li><li>OPTIONS：请求查询服务器性能</li></ul><h2 id="http-状态码"><a href="#http-状态码" class="headerlink" title="http 状态码"></a>http 状态码</h2><p>状态码是用于表示网页服务器HTTP响应状态的3位数字代码</p><p>1xx:请求被成功接收<br>2xx:请求被成功处理<br>3xx:重定向相关<br>4xx:客户端错误<br>5xx:服务器端错误</p><h2 id="TCP-和-UDP-的区别"><a href="#TCP-和-UDP-的区别" class="headerlink" title="TCP 和 UDP 的区别"></a>TCP 和 UDP 的区别</h2><ul><li>面向连接:传输数据之前是否要建立连接</li><li>可靠传输:收到报文之后是否需要确认，是否需要保证数据的不丢失和顺序到达</li><li>是否有状态:是否记录自己发送的消息被接受了等等</li><li>传输效率:</li><li>传输形式:tcp面向字节流，udp面向报文</li><li>首部开销:</li><li>广播或多播:tcp只支持点对点，udp支持一对一一对多多对一</li></ul><h2 id="tcp为什么可靠"><a href="#tcp为什么可靠" class="headerlink" title="tcp为什么可靠"></a>tcp为什么可靠</h2><ul><li>确认和重传机制:建立连接时三次握手同步双方的“序列号 + 确认号 + 窗口大小信息”，是确认重传、流控的基础</li><li>数据排序:TCP有专门的序列号SN字段，可提供数据re-order</li><li>流量控制:滑动窗口和计时器的使用。TCP窗口中会指明双方能够发送接收的最大数据量，发送方通过维持一个发送滑动窗口来确保不会发生由于发送方报文发送太快接收方无法及时处理的问题。</li><li>拥塞控制:TCP的拥塞控制由4个核心算法组成:“慢启动” “拥塞避免”  “快速重传 ”  “快速恢复”</li></ul><h2 id="cookie-和-session-的区别"><a href="#cookie-和-session-的区别" class="headerlink" title="cookie 和 session 的区别"></a>cookie 和 session 的区别</h2><pre><code>cookie和session都是会话技术，cookie是运行在客户端，session是运行在服务器端cookie有安全隐患，通过拦截或本地文件找得到你的cookie后可以进行攻击session是保存在服务器端上会存在一段时间后消失，如果session过多会增加服务器的压力</code></pre><h2 id="IP-地址和-Mac-地址的区别，了解-ARP-地址解析协议并了解其工作原理"><a href="#IP-地址和-Mac-地址的区别，了解-ARP-地址解析协议并了解其工作原理" class="headerlink" title="IP 地址和 Mac 地址的区别，了解 ARP 地址解析协议并了解其工作原理"></a>IP 地址和 Mac 地址的区别，了解 ARP 地址解析协议并了解其工作原理</h2><p>互联网中的每一个资源都有一个ip地址，而一切网络设备都有一个唯一mac地址 ,ip地址是一种不重复的定位方式</p><p>mac地址是永久的，而ip可能会随着网络的更换而变化</p><p>arp(address resolution protocol)地址解析协议。解决了ip地址转mac地址的问题</p><h2 id="建立连接TCP三次握手和断开连接TCP四次挥手"><a href="#建立连接TCP三次握手和断开连接TCP四次挥手" class="headerlink" title="建立连接TCP三次握手和断开连接TCP四次挥手"></a>建立连接TCP三次握手和断开连接TCP四次挥手</h2><h3 id="三次握手"><a href="#三次握手" class="headerlink" title="三次握手"></a>三次握手</h3><p>第一次握手<br>    建立连接时，客户端发送syn包（syn&#x3D;j）到服务器，并进入SYN_SENT状态，等待服务器确认。SYN：同步序列编号(客户端发送同步请求等待服务器确认)<br>第二次握手<br>    服务器收到SYN包，必须确认客户的SYN(ack&#x3D;j+1),同时自己也发送一个SYN包(syn&#x3D;k)，即SYN+ACK包，此时服务器进入SYN_RECV状态(服务器收到请求同意建立连接，告诉客户端自己同意)<br>第三次握手<br>    客户端收到服务器的SYN+ACK包，向服务器发送确认包ACK(ACK&#x3D;K+1)，此包发送完毕，客户端和服务器进入ESTABLISHED（TCP连接成功）状态(客户端告诉服务端自己知道你同意了于是开启了连接，)</p><h3 id="为什么要三次握手"><a href="#为什么要三次握手" class="headerlink" title="为什么要三次握手?"></a>为什么要三次握手?</h3><p>主要就是用来确认自己和对方的接受和发送都正常</p><ol><li>第一次握手：Client 什么都不能确认；Server 确认了对方发送正常，自己接收正常</li><li>第二次握手：Client 确认了：自己发送、接收正常，对方发送、接收正常；Server 确认了：对方发送正常，自己接收正常</li><li>第三次握手：Client 确认了：自己发送、接收正常，对方发送、接收正常；Server 确认了：自己发送、接收正常，对方发送、接收正常</li></ol><h3 id="四次挥手"><a href="#四次挥手" class="headerlink" title="四次挥手"></a>四次挥手</h3><p>断开一个 TCP 连接则需要“四次挥手”，缺一不可：</p><p>第一次挥手：客户端发送一个 FIN（SEQ&#x3D;x） 标志的数据包-&gt;服务端，用来关闭客户端到服务端的<strong>数据传送</strong>。然后客户端进入 FIN-WAIT-1 状态。<br>第二次挥手：服务端收到这个 FIN（SEQ&#x3D;X） 标志的数据包，它发送一个 ACK （ACK&#x3D;x+1）标志的数据包-&gt;客户端 。然后服务端进入 CLOSE-WAIT 状态，客户端进入 FIN-WAIT-2 状态。<br>第三次挥手：服务端发送一个 FIN (SEQ&#x3D;y)标志的数据包-&gt;客户端，请求关闭连接，然后服务端进入 LAST-ACK 状态。<br>第四次挥手：客户端发送 ACK (ACK&#x3D;y+1)标志的数据包-&gt;服务端，然后客户端进入TIME-WAIT状态，服务端在收到 ACK (ACK&#x3D;y+1)标志的数据包后进入 CLOSE 状态。此时如果客户端等待 2MSL 后依然没有收到回复，就证明服务端已正常关闭，随后客户端也可以关闭连接了</p><p>第一次挥手：A 说“我没啥要说的了”<br>第二次挥手：B 回答“我知道了”，但是 B 可能还会有要说的话，A 不能要求 B 跟着自己的节奏结束通话<br>第三次挥手：于是 B 可能又巴拉巴拉说了一通，最后 B 说“我说完了”<br>第四次挥手：A 回答“知道了”，这样通话才算结束。</p><h2 id="DNS域名系统"><a href="#DNS域名系统" class="headerlink" title="DNS域名系统"></a>DNS域名系统</h2><p>DNS 要解决的是域名和 IP 地址的映射问题。</p><p>DNS域名服务器分为四种：本地、权威、顶级、根</p><p>DNS有两种查询解析方法：迭达和递归</p><p>常用的方法是从请求主机到本地 DNS 服务器的查询是递归的，其余的查询时迭代的。</p><h2 id="UDP如何实现可靠传输"><a href="#UDP如何实现可靠传输" class="headerlink" title="UDP如何实现可靠传输"></a>UDP如何实现可靠传输</h2><p>UDP实现可靠传输,其实是借鉴TCP可靠传输的策略</p><h3 id="常见的可靠传输策略"><a href="#常见的可靠传输策略" class="headerlink" title="常见的可靠传输策略"></a>常见的可靠传输策略</h3><ol><li>ACK机制</li><li>重传机制</li><li>序号机制</li><li>重排机制</li><li>窗口机制</li></ol>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>八股文骚套路之JVM</title>
      <link href="/undefined/3fe50e69.html"/>
      <url>/undefined/3fe50e69.html</url>
      
        <content type="html"><![CDATA[<h2 id="运行时数据区中包含哪些区域？哪些线程共享？哪些线程独享？【⭐⭐⭐⭐⭐】"><a href="#运行时数据区中包含哪些区域？哪些线程共享？哪些线程独享？【⭐⭐⭐⭐⭐】" class="headerlink" title="运行时数据区中包含哪些区域？哪些线程共享？哪些线程独享？【⭐⭐⭐⭐⭐】"></a>运行时数据区中包含哪些区域？哪些线程共享？哪些线程独享？【⭐⭐⭐⭐⭐】</h2><p>JDK1.7之前的运行时数据区包括 堆、方法区、虚拟机栈、本地方法栈、程序计数器<br>其中堆和方法区是线程共享的；虚拟机栈、本地方法栈和程序计数器是线程私有的。<br>Jdk1.8之后 方法区的实现变成了元空间，和运行时常量池一起被放到了本地内存</p><h3 id="程序计数器"><a href="#程序计数器" class="headerlink" title="程序计数器"></a>程序计数器</h3><p>可以看作当前线程所执行的字节码文件的行号指示器，实现代码的流程控制，还需要能让线程切换之后能恢复到正确的执行位置，自然是线程私有的</p><h3 id="虚拟机栈"><a href="#虚拟机栈" class="headerlink" title="虚拟机栈"></a>虚拟机栈</h3><p>除了一些本地方法是在本地方法栈中实现，其他所有java方法的调用都通过虚拟机栈实现的。<br>栈由一个个栈帧组成，每一个方法调用的时候都会有一个栈帧被压入虚拟机栈中，每个栈帧中都保存着局部变量表、操作数栈、动态链接和方法的返回地址。</p><h4 id="局部变量表"><a href="#局部变量表" class="headerlink" title="局部变量表"></a>局部变量表</h4><p>主要存储编译期间的基本数据类型和对象引用(是指向对象起始地址的引用指针)</p><h4 id="操作数栈"><a href="#操作数栈" class="headerlink" title="操作数栈"></a>操作数栈</h4><p>用于存放方法执行过程中产生的中间计算结果。</p><h4 id="动态链接"><a href="#动态链接" class="headerlink" title="动态链接"></a>动态链接</h4><p>主要用于一个方法需要调用其余方法的场景，当一个方法要去调用其他方法，就需要把常量池里指向方法的符号引用转化为内存地址中的直接引用。</p><h3 id="本地方法栈"><a href="#本地方法栈" class="headerlink" title="本地方法栈"></a>本地方法栈</h3><p>和虚拟机栈类似，只是里面存的是Native方法</p><h3 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h3><p>用来存放对象实例，几乎所有的对象实例和数组都在这里分配内存</p><h2 id="说一下方法区和永久代的关系"><a href="#说一下方法区和永久代的关系" class="headerlink" title="说一下方法区和永久代的关系"></a>说一下方法区和永久代的关系</h2><p>方法区是JVM运行时的数据区域的一块逻辑区域，是各个线程共享的内存区域，它是一个逻辑概念，定义规则。</p><p>而永久代则是方法区的一个具体实现方式，Jdk1.8之后方法区的实现变成了元空间，被放到了本地内存里</p><h3 id="Java-创建一个对象的过程。【⭐⭐⭐⭐】"><a href="#Java-创建一个对象的过程。【⭐⭐⭐⭐】" class="headerlink" title="Java 创建一个对象的过程。【⭐⭐⭐⭐】"></a>Java 创建一个对象的过程。【⭐⭐⭐⭐】</h3><p>类加载检查：首先，再Java中使用new关键字创建对象的时候，首先要加载对象的类。如果类未被加载，那么JVM会使用类加载器(这里有一个双亲委派机制)加载并初始化该类</p><p>分配内存空间:类加载完成之后，JVM会在堆中为对象分配内存空间。分配内存的方式有指针碰撞和空闲列表两种，选择哪种分配方式取决于Java堆内存是否规整。</p><p>连接：接下来，JVM会把对象里的普通成员变量初始化为0值。这一步操作主要是保证对象里面的实例字段不用初始化就可以直接使用。</p><p>设置对象头： 然后，JVM还需要对对象的对象头做一些设置，比如对象所属的类元信息、对象的GC分代年龄、hashCode、锁标记等。</p><p>执行<init>方法：JVM调用对象的构造函数，对对象的属性进行赋值和其他初始化操作</p><p>最后，JVM会返回对象的引用</p><h2 id="对象的访问定位的两种方式【⭐⭐⭐⭐⭐】"><a href="#对象的访问定位的两种方式【⭐⭐⭐⭐⭐】" class="headerlink" title="对象的访问定位的两种方式【⭐⭐⭐⭐⭐】"></a>对象的访问定位的两种方式【⭐⭐⭐⭐⭐】</h2><p>一般有两种方式:</p><ol><li>句柄(堆中划分出一个句柄池，栈中的引用指向句柄地址，然后句柄中包含了对象的实例数据和类型数据的地址)</li><li>直接指针(栈中的引用直接指向实例数据的地址，如果访问对象本身的话，就不用多一次访问开销，而对象的类型数据的指针存放在方法区中，如果定位的话，需要多一次直接定位开销)</li></ol><p>使用句柄最大的好处就是引用中存储的是句柄地址，对象移动时只需改变句柄的地址就可以，而无需改变对象本身。</p><p>使用直接指针来访问速度更快，它节省了一次指针定位的时间开销，因为对象访问在 Java 中非常频繁。</p><h2 id="你了解分代理论吗？讲一下-Minor-GC、还有-Full-GC-⭐⭐⭐⭐⭐"><a href="#你了解分代理论吗？讲一下-Minor-GC、还有-Full-GC-⭐⭐⭐⭐⭐" class="headerlink" title="你了解分代理论吗？讲一下 Minor GC、还有 Full GC ⭐⭐⭐⭐⭐"></a>你了解分代理论吗？讲一下 Minor GC、还有 Full GC ⭐⭐⭐⭐⭐</h2><p>Java中的自动内存隔离主要是针对的堆内存中对象的分配和回收。</p><p>在Jdk1.7之前 堆内存通常分为 新生代 老年代 和永久代，Jdk8之后永久代被元空间取代，元空间使用的是直接内存</p><p>大多数情况下，对象优先在新生代中的eden区中分配(大对象直接进入老年代)，当eden区空间不足的时候，JVM会进行一次minorGC,经过一次minorGC的对象会被分配到survivor区，如果survivor区放不下，那么会通过分配担保机制提前移动到老年代去，如果仍能存活且能被survivor容纳的话，会被移动到survivor空间。且年龄+1<br>当年龄增加到阈值的时候，就会晋升到老年代中。</p><p>minorGC是partial GC 的一种，只对新生代进行垃圾收集</p><h2 id="Java-用什么方法确定哪些对象该被清理？-讲一下可达性分析算法的流程。【⭐⭐⭐⭐】"><a href="#Java-用什么方法确定哪些对象该被清理？-讲一下可达性分析算法的流程。【⭐⭐⭐⭐】" class="headerlink" title="Java 用什么方法确定哪些对象该被清理？ 讲一下可达性分析算法的流程。【⭐⭐⭐⭐】"></a>Java 用什么方法确定哪些对象该被清理？ 讲一下可达性分析算法的流程。【⭐⭐⭐⭐】</h2><ul><li>引用计数法<br>给对象添加一个引用计数器，每当有一个地方引用，计数器就+1；当引用失效，计数器就-1；引用计数器为0的对象就是不可能再被使用的</li></ul><p>但是这个方法没法解决对象间的循环引用问题</p><ul><li>可达性分析算法</li></ul><p>通过一系列的称为 “GC Roots” 的对象作为起点，从这些节点开始向下搜索，节点所走过的路径称为引用链，当一个对象到 GC Roots 没有任何引用链相连的话，则证明此对象是不可用的，需要被回收。</p><h2 id="JDK-中有几种引用类型？分别的特点是什么？【⭐⭐】"><a href="#JDK-中有几种引用类型？分别的特点是什么？【⭐⭐】" class="headerlink" title="JDK 中有几种引用类型？分别的特点是什么？【⭐⭐】"></a>JDK 中有几种引用类型？分别的特点是什么？【⭐⭐】</h2><ol><li><p>强引用<br>表示必不可少。垃圾回收器绝不会回收它。当内存空间不足，Java 虚拟机宁愿抛出 OutOfMemoryError 错误，使程序异常终止，也不会靠随意回收具有强引用的对象来解决内存不足问题。</p></li><li><p>软引用（SoftReference）<br>表示可有可无。如果内存空间足够，垃圾回收器就不会回收它，如果内存空间不足了，就会回收这些对象的内存。</p></li><li><p>弱引用（WeakReference）<br>表示可有可无。弱引用与软引用的区别在于：弱引用的生命周期更短，在垃圾回收器线程扫描它所管辖的内存区域的过程中，一旦发现了只具有弱引用的对象，不管当前内存空间足够与否，都会回收它的内存。</p></li><li><p>虚引用<br>表示形同虚设，任何时候都可能被垃圾回收</p></li></ol><h2 id="如何回收方法区？【⭐⭐⭐】"><a href="#如何回收方法区？【⭐⭐⭐】" class="headerlink" title="如何回收方法区？【⭐⭐⭐】"></a>如何回收方法区？【⭐⭐⭐】</h2><p>主要有两种方法：</p><ol><li>类卸载：当一个类不再被引用，即没有任何对象实例引用该类，且该类的类加载器已经被回收时，JVM 可以卸载这个类。类卸载会导致该类在方法区中所占用的内存被释放，从而实现方法区的回收。</li><li>常量池回收：在方法区中的运行时常量池中存储着类信息、常量、静态变量等数据。常量池的大小是有限的，当常量池用尽时，JVM 会对常量池进行回收。常量池回收通常是通过 Full GC（Full Garbage Collection）来实现的。</li></ol><h2 id="标记清除、标记复制、标记整理分别是怎样清理垃圾的？各有什么优缺点？【⭐⭐⭐⭐⭐】"><a href="#标记清除、标记复制、标记整理分别是怎样清理垃圾的？各有什么优缺点？【⭐⭐⭐⭐⭐】" class="headerlink" title="标记清除、标记复制、标记整理分别是怎样清理垃圾的？各有什么优缺点？【⭐⭐⭐⭐⭐】"></a>标记清除、标记复制、标记整理分别是怎样清理垃圾的？各有什么优缺点？【⭐⭐⭐⭐⭐】</h2><ol><li><p>标记清除<br>首先<strong>标记出所有不需要回收</strong>的对象，标记完之后回收所有没有标记的对象<br>优点是简单，缺点是效率不高，容易产生大量不连续的内存碎片</p></li><li><p>标记复制<br><strong>将内存分为大小相同的两块，每次使用其中的一块</strong>，当内存使用完之后，<strong>把还存活的对象复制到另外一块，然后再把前面的空间一次性清理掉</strong><br>优点是解决了内存碎片问题<br>缺点是可用内存变小，而且如果存活的对象表较大，复制的效率也会很低所以不适合老年代</p></li><li><p>标记整理算法<br>标记所有不需要回收的对象，然后<strong>让所有存活的对象向一端移动</strong>，然后直接清理掉端边界外的内存<br>优点是减少了内存碎片，缺点是多了整理的这一步，效率不高</p></li><li><p>分代收集算法<br>根据新生代和老年代的特点，选择上述三个中适合的垃圾收集算法</p></li></ol><h2 id="JVM-中的安全点和安全区各代表什么？写屏障你了解吗？【⭐⭐⭐⭐】"><a href="#JVM-中的安全点和安全区各代表什么？写屏障你了解吗？【⭐⭐⭐⭐】" class="headerlink" title="JVM 中的安全点和安全区各代表什么？写屏障你了解吗？【⭐⭐⭐⭐】"></a>JVM 中的安全点和安全区各代表什么？写屏障你了解吗？【⭐⭐⭐⭐】</h2><p>在执行GC的时候，所有的工作线程都必须停顿，安全点就代表在这个点的时候，所有线程的工作状态是确定的，JVM可以安全的执行GC</p><p>安全点是对正在执行的线程设定的。如果一个线程处于 Sleep 或中断状态，它就不能响应 JVM 的中断请求，再运行到 Safe Point 上。</p><p>安全区是指在一段代码片段中，引用关系不会发生变化。在这个区域内的任意地方开始 GC 都是安全的。</p><h2 id="TODO-并发标记要解决什么问题？并发标记带来了什么问题？如何解决并发扫描时对象消失问题？⭐⭐⭐⭐"><a href="#TODO-并发标记要解决什么问题？并发标记带来了什么问题？如何解决并发扫描时对象消失问题？⭐⭐⭐⭐" class="headerlink" title="TODO:并发标记要解决什么问题？并发标记带来了什么问题？如何解决并发扫描时对象消失问题？⭐⭐⭐⭐"></a>TODO:并发标记要解决什么问题？并发标记带来了什么问题？如何解决并发扫描时对象消失问题？⭐⭐⭐⭐</h2><h2 id="新生代垃圾收集器有哪些？老年代垃圾收集器有哪些？哪些是单线程垃圾收集器，哪些是多线程垃圾收集器？各有什么特点？各基于哪一种垃圾收集算法？【⭐⭐⭐⭐】"><a href="#新生代垃圾收集器有哪些？老年代垃圾收集器有哪些？哪些是单线程垃圾收集器，哪些是多线程垃圾收集器？各有什么特点？各基于哪一种垃圾收集算法？【⭐⭐⭐⭐】" class="headerlink" title="新生代垃圾收集器有哪些？老年代垃圾收集器有哪些？哪些是单线程垃圾收集器，哪些是多线程垃圾收集器？各有什么特点？各基于哪一种垃圾收集算法？【⭐⭐⭐⭐】"></a>新生代垃圾收集器有哪些？老年代垃圾收集器有哪些？哪些是单线程垃圾收集器，哪些是多线程垃圾收集器？各有什么特点？各基于哪一种垃圾收集算法？【⭐⭐⭐⭐】</h2><p>如果说收集算法是内存回收的方法论，那么垃圾收集器就是内存回收的具体实现。</p><ol><li><p>Serial 串行收集器是单线程的垃圾收集器，新生代采用标记复制算法 老年代采用标记整理算法 缺点是执行GC的时候需要stop the world 优点是简单高效</p></li><li><p>ParNew 收集器是Serial收集器的多线程版本 新生代采用标记-复制算法，老年代采用标记-整理算法。</p></li><li><p>Parallel Scavenge 收集器也是用标记-复制算法的垃多线程收集器，它更加关注如何提高吞吐量 新生代采用标记-复制算法，老年代采用标记-整理算法。</p></li><li><p>Serial Old 收集器，是serial收集器的老年版本,是单线程的 与 Parallel Scavenge 收集器搭配使用</p></li><li><p>Parallel Old 收集器 是Parallel Scavenge 收集器的老年代版本，使用多线程和“标记整理”算法，在注重吞吐量以及 CPU 资源的场合，都可以优先考虑 Parallel Scavenge 收集器和 Parallel Old 收集器。</p></li><li><p>CMS(Concurrent Mark Sweep 并发标记清除) 并发收集器，可以让用户进程和垃圾回收同时进行 ，基于标记清除算法</p></li></ol><p>有4个步骤：</p><ul><li>初始标记：暂停所有其他线程，并记录下与root相连的对象</li><li>并发标记：同时开启GC和用户线程，用一个闭包结构去记录可达对象，用这个算法去跟踪记录用户进的执行导致可达对象更新的地方</li><li>重新标记：把并发标记期间用户程序继续运行导致的标记变动的那一部分对象进行标记和记录</li><li>并发清除：开启用户线程，同时 GC 线程开始对未标记的区域做清扫。<br>优点：并发收集，停顿少，用户体验好<br>缺点：对CPU的压力比较大；无法处理浮动垃圾；基于标记清楚算法会产生大量的内存碎片</li></ul><ol start="7"><li>G1 (Garbage-First) 面向服务器的垃圾收集器，内存得大，cpu性能得牛逼 也是默认的垃圾收集器，G1 收集器的运作大致分为以下几个步骤：</li></ol><ul><li>初始标记</li><li>并发标记</li><li>最终标记</li><li>筛选回收<br>特点：</li><li>充分利用并行和并发，既可以使用多个cpu来缩短stop the world 的时间，又可以通过并发使得Java程序在gc期间继续执行</li><li>分代收集</li><li>空间整合 整体上是基于标记整理算法，但是局部上基于标记复制算法</li><li>可以预测停顿的时间</li></ul><h2 id="讲一下内存分配策略？【⭐⭐⭐⭐】"><a href="#讲一下内存分配策略？【⭐⭐⭐⭐】" class="headerlink" title="讲一下内存分配策略？【⭐⭐⭐⭐】"></a>讲一下内存分配策略？【⭐⭐⭐⭐】</h2><p>常见的内存分配策略有两种<br>第一种：对象优先在Eden区进行分配，当Eden区满了之后，进行一次minorGC(新生代垃圾回收)，仍然存活的对象被移动到survivor区或老年代<br>第二种：如果对象大小超过了一定的阈值，那么JVM会自动将其分配到老年代，因为大对象往往拥有较长的生命周期，直接分配到老年代可以减少在新生代的复制操作<br>第三种：长期存活的对象今日老年代，JVM给每个对象一个年龄计数器，在eden区的对象经过一次minorGC之后如果仍然存活会被移动到survivor区，且年龄+1；后续在survivor区每经历一次minorGC，年龄就+1，直到达到阈值默认为15，就会被移动到老年代。<br>第四种：动态对象年龄判定，如果survivor区中相同年龄的对象的总内存超过survivor空间一半，年龄大于等于这个年龄的对象可直接进入老年代。</p><h3 id="空间分配担保机制"><a href="#空间分配担保机制" class="headerlink" title="空间分配担保机制"></a>空间分配担保机制</h3><p>minorGC之前，需要检查老年代可用空间是否足够容纳新生代所有对象。如果够的话说明minorGC是安全的。</p><h2 id="虚拟机基础故障处理工具有哪些？【⭐⭐⭐】"><a href="#虚拟机基础故障处理工具有哪些？【⭐⭐⭐】" class="headerlink" title="虚拟机基础故障处理工具有哪些？【⭐⭐⭐】"></a>虚拟机基础故障处理工具有哪些？【⭐⭐⭐】</h2><p>jstat: 监视虚拟机各种运行状态信息</p><p>jinfo: 实时地查看和调整虚拟机各项参数</p><p>jmap:生成堆转储快照</p><p>jhat: 分析 heapdump 文件</p><p>jstack :生成虚拟机当前时刻的线程快照</p><h2 id="什么是字节码？类文件结构的组成了解吗？【⭐⭐⭐⭐】"><a href="#什么是字节码？类文件结构的组成了解吗？【⭐⭐⭐⭐】" class="headerlink" title="什么是字节码？类文件结构的组成了解吗？【⭐⭐⭐⭐】"></a>什么是字节码？类文件结构的组成了解吗？【⭐⭐⭐⭐】</h2><p>JVM可以理解的代码称为字节码</p><p>类文件结构有魔数、class文件版本号、常量池、访问标识、当前类、父类、字段表、方法表、属性表</p><h2 id="类的生命周期？类加载的过程了解么？加载这一步主要做了什么事情？初始化阶段中哪几种情况必须对类初始化？【⭐⭐⭐⭐⭐】"><a href="#类的生命周期？类加载的过程了解么？加载这一步主要做了什么事情？初始化阶段中哪几种情况必须对类初始化？【⭐⭐⭐⭐⭐】" class="headerlink" title="类的生命周期？类加载的过程了解么？加载这一步主要做了什么事情？初始化阶段中哪几种情况必须对类初始化？【⭐⭐⭐⭐⭐】"></a>类的生命周期？类加载的过程了解么？加载这一步主要做了什么事情？初始化阶段中哪几种情况必须对类初始化？【⭐⭐⭐⭐⭐】</h2><p>类从被加载到JVM内存开始到卸载出内存，生命周期主要有7个阶段：加载、验证、准备、解析、初始化、使用、卸载，其中验证、准备和解析三个阶段统称为连接</p><p>系统加载类文件主要有三步：加载 连接和初始化</p><p>加载这一步首先是通过全类名获取定义此类的二进制字节流；其次将字节流代表的静态存储结构转化为方法区的运行时数据结构;然后在内存中生成一个代表该类的class对象作为数据的访问入口</p><p>初始化阶段有6种情况必须对类进行初始化</p><ol><li>当遇到 new、 getstatic、putstatic 或 invokestatic 这 4 条字节码指令时</li><li>对类进行反射调用时</li><li>初始化一个类，如果其父类还未初始化，则先触发该父类的初始化。</li><li>当虚拟机启动时，虚拟机需要定义一个主类，这个主类需要被初始化</li><li>MethodHandle 和 VarHandle 可以看作是轻量级的反射调用机制，而要想使用这 2 个调用，就必须先使用 findStaticVarHandle 来初始化要调用的类。</li><li>当一个接口中定义了被default关键字修饰的接口方法的时候，如果有这个接口的实现类发生了初始化，那该接口要在其之前被初始化。</li></ol><h2 id="讲一下双亲委派模型。【⭐⭐⭐⭐⭐】"><a href="#讲一下双亲委派模型。【⭐⭐⭐⭐⭐】" class="headerlink" title="讲一下双亲委派模型。【⭐⭐⭐⭐⭐】"></a>讲一下双亲委派模型。【⭐⭐⭐⭐⭐】</h2><p>类加载器有很多种：启动类加载器，扩展类加载器、应用程序类加载器等等，双亲委派模型就是用来确定具体用哪一个类加载器加载。<br>它是这样运作的，每当一个类加载器接到加载请求的时候，系统会判断当前类是否被加载过，如果加载过就直接返回，否则才会尝试加载；进行类加载的时候，会先把这个请求委派给父类的加载器，这样依次类推，所有的请求都会最终传送到顶层的启动类加载器；只有当父类加载器没有找到所需要的类的时候，子加载器才会自己尝试加载；如果最终子类加载器也无法加载这个类，会抛出classnotfoundexception异常</p><p>双亲委派模型的好处是可以避免类的重复加载，保证Java的核心API不被修改</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>八股文骚套路之Java集合</title>
      <link href="/undefined/2ca694ee.html"/>
      <url>/undefined/2ca694ee.html</url>
      
        <content type="html"><![CDATA[<h2 id="集合概述"><a href="#集合概述" class="headerlink" title="集合概述"></a>集合概述</h2><p>Java集合，也叫容器主要有两大接口派生而来</p><ul><li>Collection<ul><li>List(列表):有序可重复<ul><li>ArrayList</li><li>Vector</li><li>LinkedList(双向链表)</li></ul></li><li>Set(集合)：不可重复&#x2F;唯一<ul><li>HashSet(无序唯一)<ul><li>LinkedHashSet:底层使用LinkedHashMap实现</li></ul></li><li>TreeSet(有序唯一)：红黑树(自平衡排序二叉树)</li></ul></li><li>Queue(队列)：特定的排序规则，有序可重复</li></ul></li><li>Map(映射 可以多对一，不能一对多)<ul><li>HashMap：JdK1.8之前是数组+链表，JdK1.8之后在链表长度大于阈值8的时候会将链表转化为红黑树以减少搜索时间，但是在转化之前还会判断当前的哈希桶数组(用来存键值对的数组)的长度是不是小于64，如果不是，那么会先对数组进行扩容。<ul><li>LinkedHashMap:在HashMap的基础上增加了一条双向链表，使HashMap的结构可以保持键值对的插入顺序</li></ul></li><li>Hashtable</li><li>SortedMap</li></ul></li></ul><blockquote><p>[!TIP]<br>在 HashMap 中，主要有一个用于存储键值对的数组，这个数组被称为“哈希桶数组”或“Entry 数组”。在 JDK 1.8 之前，HashMap 的底层数据结构由一个数组 + 链表组成。数组的每个元素（称为桶或者 Entry）都是一个链表的头节点，每个节点存储一个键值对。当发生哈希冲突时，具有相同哈希值的键值对会被放置在同一个桶中，通过链表形式串联在一起。</p></blockquote><h3 id="如何选用集合？"><a href="#如何选用集合？" class="headerlink" title="如何选用集合？"></a>如何选用集合？</h3><ul><li><p>需要根据键值获取元素则选Map接口下的集合，需要排序则用TreeMap，不需要排序则选HashMap，需要线程安全就用ConcurrentHashMap,尽量不用HashTable</p></li><li><p>当只需要存放元素值的时候选用Collection接口的集合，需要唯一用Set接口下的集合，比如TreeSet和HashSet，不需要就用List下的接口比如ArrayList和LinkedList。</p></li></ul><h3 id="ArrayList-数组列表-和-Array（数组）的区别？"><a href="#ArrayList-数组列表-和-Array（数组）的区别？" class="headerlink" title="ArrayList(数组列表) 和 Array（数组）的区别？"></a>ArrayList(数组列表) 和 Array（数组）的区别？</h3><p>ArrayList 内部基于动态数组实现，比 Array（静态数组） 使用起来更加灵活</p><ul><li>ArrayList可以动态地扩容或缩容，而 Array 被创建之后就不能改变它的长度了。</li><li>ArrayList 允许你使用泛型来确保类型安全，Array 则不可以。</li><li>ArrayList 中只能存储对象。对于基本类型数据，基本数据类型要使用包装类。Array 可以直接存储基本类型数据，也可以存储对象。</li><li>ArrayList 支持插入、删除、遍历等常见操作，并且提供了丰富的 API 操作方法，比如 add()、remove()等。Array 只是一个固定长度的数组，只能按照下标访问其中的元素，不具备动态添加、删除元素的能力。</li><li>ArrayList创建时不需要指定大小，而Array创建时必须指定大小。</li></ul><h3 id="ArrayList-与-LinkedList-区别"><a href="#ArrayList-与-LinkedList-区别" class="headerlink" title="ArrayList 与 LinkedList 区别?"></a>ArrayList 与 LinkedList 区别?</h3><p>两者都是线程不安全的</p><p>然后记住ArrayList 采用数组存储 LinkedList 采用链表存储,再根据底层数据结构从插入删除元素，随机访问，内存空间占用上展开来将就行</p><h2 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h2><h3 id="Comparable-和-Comparator-的区别"><a href="#Comparable-和-Comparator-的区别" class="headerlink" title="Comparable 和 Comparator 的区别"></a>Comparable 和 Comparator 的区别</h3><p>Comparable 接口和 Comparator 接口都是 Java 中用于排序的接口, 用于在类对象之间比较大小、排序</p><p>一般我们需要对一个集合使用自定义排序时，我们就要重写compareTo()方法或compare()方法</p><h3 id="无序性和不可重复性的含义是什么"><a href="#无序性和不可重复性的含义是什么" class="headerlink" title="无序性和不可重复性的含义是什么"></a>无序性和不可重复性的含义是什么</h3><ul><li><p>无序性指的是存储的数据在底层数组中的顺序不是按照数组索引的顺序添加，而是根据数据的哈希值决定</p></li><li><p>不可重复性指 equals() 判断的时候返回false，所以需要同时重写equals方法和hashcode方法</p></li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>八股文骚套路之Java基础</title>
      <link href="/undefined/df1beea2.html"/>
      <url>/undefined/df1beea2.html</url>
      
        <content type="html"><![CDATA[<p>⭐ ：面试中不常问到，如果面试官问到尽量能答出来，答不出来也没关系。<br>⭐⭐ ：面试中不常问到，但是如果面试官问到的话，答不出来对你的印象会减分。<br>⭐⭐⭐：面试中会问到，答不出来面试有点悬。面试官会惊讶为什么你这也不会。<br>⭐⭐⭐⭐：面试高频考点。<br>⭐⭐⭐⭐⭐：面试超高频考点。四星考点和五星考点是参加十场面试，至少能有五场面试问到这些的。大家在准备面试过程中尽量把这些知识点的回答条理梳理清楚，面试官一问就开背。</p><h2 id="🆗Java-语言的特点⭐️⭐️"><a href="#🆗Java-语言的特点⭐️⭐️" class="headerlink" title="🆗Java 语言的特点⭐️⭐️"></a>🆗Java 语言的特点⭐️⭐️</h2><ul><li>语法简单，上手容易</li><li>面向对象(封装 继承 多态)</li><li>Java 虚拟机实现了 Java 语言的跨平台性</li><li>支持多线程</li><li>可靠(异常处理和自动内存管理机制)、安全(多重安全防护机制如访问权限修饰符、限制程序直接访问操作系统资源)</li><li>高效性(预编译等技术)</li><li>支持网络编程</li><li>编译与解释并存</li></ul><h2 id="🆗比较-JVM-和-JDK-以及-JRE-⭐️⭐️⭐️"><a href="#🆗比较-JVM-和-JDK-以及-JRE-⭐️⭐️⭐️" class="headerlink" title="🆗比较 JVM 和 JDK 以及 JRE ⭐️⭐️⭐️"></a>🆗比较 JVM 和 JDK 以及 JRE ⭐️⭐️⭐️</h2><ul><li>JVM(Java Virtual Machine) Java 虚拟机是运行 Java 字节码的虚拟机</li><li>JDK(Java Development Kit) Java 开发工具包，提供 Java 的开发环境，<strong>包含 JRE</strong></li><li>JRE(Java Runtime Environment)  Java 运行时环境，包含 JVM 和一些核心类库<br>总结： JDK 包含了 JRE 和开发工具， JRE 包含了 JVM 和核心类库</li></ul><h2 id="🆗为什么说-Java-解释与编译并存-⭐️⭐️"><a href="#🆗为什么说-Java-解释与编译并存-⭐️⭐️" class="headerlink" title="🆗为什么说 Java 解释与编译并存 ⭐️⭐️"></a>🆗为什么说 Java 解释与编译并存 ⭐️⭐️</h2><ul><li>高级编程语言按照程序的执行方式分为编译型和解释型</li><li>编译型是通过编译器一次性将源码翻译为机器码，而解释型是通过解释器逐句将代码解释为机器码再执行。</li><li>Java 程序执行需要先由编译器编译为字节码 .class 文件,再由 Java 解释器解释执行。</li></ul><h2 id="🆗Java-基本类型有哪几种，各占多少位？⭐️⭐️"><a href="#🆗Java-基本类型有哪几种，各占多少位？⭐️⭐️" class="headerlink" title="🆗Java 基本类型有哪几种，各占多少位？⭐️⭐️"></a>🆗Java 基本类型有哪几种，各占多少位？⭐️⭐️</h2><p>基本类型有8种</p><p>6种数字类型：</p><ul><li><p>4种整型:byte short int long (分别为8 16 32 64)</p></li><li><p>2种浮点型:float double(分别为32 64)</p></li><li><p>1种字符型：char(16)</p></li><li><p>1种布尔型：boolean(8)</p></li></ul><h2 id="🆗Java中的泛型和类型擦除-⭐️⭐️⭐️"><a href="#🆗Java中的泛型和类型擦除-⭐️⭐️⭐️" class="headerlink" title="🆗Java中的泛型和类型擦除 ⭐️⭐️⭐️"></a>🆗Java中的泛型和类型擦除 ⭐️⭐️⭐️</h2><p>泛型是Java的一个新特性，可以用来增强可读性和稳定性。<br>Java编译器可以对泛型参数进行检测，可以指定传入对象的泛型<br>泛型一般有三种使用方式：泛型类、泛型接口、泛型方法<br>但是泛型是语法糖的一种，Java虚拟机里没有泛型，只有普通类和普通方法，Java虚拟机会在编译阶段通过类型擦除的方式进行解语法糖，类型擦除就是将所有的泛型参数用其最顶级的父类进行替换。</p><h3 id="🆗既然编译器要将泛型擦除，那为什么还要使用泛型，用Object代替不行吗？-使用泛型的好处"><a href="#🆗既然编译器要将泛型擦除，那为什么还要使用泛型，用Object代替不行吗？-使用泛型的好处" class="headerlink" title="🆗既然编译器要将泛型擦除，那为什么还要使用泛型，用Object代替不行吗？(使用泛型的好处)"></a>🆗既然编译器要将泛型擦除，那为什么还要使用泛型，用Object代替不行吗？(使用泛型的好处)</h3><ol><li>使用泛型可在编译期前进行类型检测。</li><li>使用 Object 类型需要手动添加强制类型转换，降低代码可读性，提高出错概率。</li></ol><h2 id="🆗-和-equals-的区别⭐️⭐️⭐️"><a href="#🆗-和-equals-的区别⭐️⭐️⭐️" class="headerlink" title="🆗&#x3D;&#x3D; 和 equals() 的区别⭐️⭐️⭐️"></a>🆗&#x3D;&#x3D; 和 equals() 的区别⭐️⭐️⭐️</h2><p>这两者对于基本类型和引用类型的效果是不同的</p><ul><li>对于基本数据类型，&#x3D;&#x3D; 比较的是值；对于引用数据类型，&#x3D;&#x3D;比较的是内存地址</li></ul><p>因为在Java中只有值传递，所以本质上来说 &#x3D;&#x3D; 比较的就是值。</p><ul><li>equals()不能用来判断<strong>基本数据类</strong>的变量，只能用来判断两个<strong>对象</strong>是否相等，这有两种情况：第一种是没有重写equals方法，那么默认比较的是两个对象的地址，等同于&#x3D;&#x3D;；但是一般会重写equals方法来判断两个对象的属性是否相等,若属性相等则返回true认为两个对象相等</li></ul><h2 id="🆗hashCode-和-equals-⭐⭐⭐⭐"><a href="#🆗hashCode-和-equals-⭐⭐⭐⭐" class="headerlink" title="🆗hashCode() 和 equals() ⭐⭐⭐⭐"></a>🆗hashCode() 和 equals() ⭐⭐⭐⭐</h2><p>hashCode是用来获取散列码，用来确定对象在hash表中的索引位置，帮助快速找到所需要的对象。<br>当把对象加入hashset，hashset会先计算当前对象的哈希值来确定该对象加入的位置，同时也会将这个哈希值和已经加入对象的哈希值作比较，如果没有一样的，hashset会假设这个对象没有重复出现。但是如果发现有相同的哈希值的对象，则更进一步用equals方法来检查两个对象是不是真的相同。如果相同那么就不会让这个对象加入；如果不同，那么会重新将这个对象散列到其他位置。这样可以大大减少equals方法的执行速度。</p><ul><li>重写equals的时候必须重写hashcode()方法，因为hashcode相等是两个对象相等的必要不充分条件。</li></ul><h2 id="🆗重载和重写的区别⭐⭐⭐⭐"><a href="#🆗重载和重写的区别⭐⭐⭐⭐" class="headerlink" title="🆗重载和重写的区别⭐⭐⭐⭐"></a>🆗重载和重写的区别⭐⭐⭐⭐</h2><ul><li>重载是同一个类中多个同名方法，根据输入参数的数据类型或者数量的不同，作出不同的处理</li><li>重写是子类继承父类的相同方法时，输入数据是一样的，但是需要作出不同于父类的处理，比如功能的扩展之类的，需要覆盖父类的方法(重写发生在运行时,可以改变内部逻辑，但是外部的样子不能改变)</li></ul><h2 id="🆗深拷贝和浅拷贝"><a href="#🆗深拷贝和浅拷贝" class="headerlink" title="🆗深拷贝和浅拷贝"></a>🆗深拷贝和浅拷贝</h2><ul><li>深拷贝会完全复制整个对象，包括这个对象的内部对象。</li><li>浅拷贝会在堆上创建一个新的对象，但是如果对象内部是引用类型的话，不会拷贝内部对象，而是拷贝内部对象的地址引用</li><li>引用拷贝则是只拷贝引用地址</li></ul><h2 id="成员变量和局部变量的区别⭐️⭐️⭐️"><a href="#成员变量和局部变量的区别⭐️⭐️⭐️" class="headerlink" title="成员变量和局部变量的区别⭐️⭐️⭐️"></a>成员变量和局部变量的区别⭐️⭐️⭐️</h2><ul><li>成员变量是属于类的，而局部变量是在代码块或方法中定义的变量或是方法的参数；成员变量可以被访问控制修饰符修饰，局部变量不能；但是两者都可以被final修饰。</li><li>生命周期上，成员变量是对象的一部分，生命周期和对象一致，而局部变量是方法的，随着方法的调用和调用结束产生和消亡</li><li>默认值:成员变量如果没被赋值那么会有默认值(final修饰的成员变量必须显示赋值)；而局部变量不会被自动赋值。</li></ul><h2 id="面向对象三大特性是什么。并解释这三大特性。⭐️⭐️⭐️⭐️"><a href="#面向对象三大特性是什么。并解释这三大特性。⭐️⭐️⭐️⭐️" class="headerlink" title="面向对象三大特性是什么。并解释这三大特性。⭐️⭐️⭐️⭐️"></a>面向对象三大特性是什么。并解释这三大特性。⭐️⭐️⭐️⭐️</h2><ul><li>三大特性是封装、继承和多态</li></ul><p>封装是把一个对象的属性隐藏在对象内部，不允许外部对象直接访问对象的内部信息</p><ul><li>继承</li></ul><ol><li>子类继承父类对象所有的属性和方法，但是父类中的私有属性和方法子类只是拥有不能访问。</li><li>子类可以对父类的属性和方法进行扩展(子承父业，发扬广大)</li><li>子类可以重写(overwrite)父类的方法, 在其基础之上实现功能的扩展</li></ol><ul><li>多态</li></ul><p>一个对象拥有多种状态，父类的引用指向子类的实现</p><ol><li>对象类型和引用类型之间存在继承&#x2F;实现接口的关系；</li><li>引用类型变量发出的方法调用的到底是哪个类中的方法，必须到程序运行时才能确定;3. 多态不能调用“只在子类中有，但是父类中没有的”的方法；</li><li>如果子类重写了父类的方法，真正执行的是子类中重写的方法，如果子类没有重写父类的方法，执行的是父类的方法。(就近原则)</li></ol><h2 id="String、StringBuffer-和-StringBuilder-的区别。-⭐⭐⭐⭐"><a href="#String、StringBuffer-和-StringBuilder-的区别。-⭐⭐⭐⭐" class="headerlink" title="String、StringBuffer 和 StringBuilder 的区别。 ⭐⭐⭐⭐"></a>String、StringBuffer 和 StringBuilder 的区别。 ⭐⭐⭐⭐</h2><p>从可变性上来说，String是不可变的。而StringBuffer和StringBuilder是继承于AbstractStringBuilder类，虽然三者都是用字符数组保存字符串,但AbstractStringBuilder 中没有使用final 和private关键字修饰，而且还提供了许多修改字符串的方法(比如append等等)</p><p>从线程安全性上来说，String中的对象是不变的，所以线程安全（可理解为常量<br>而StringBuffer虽然可变，但是对AbstractStringBuilder中的方法添加了同步锁，所以线程安全<br>而StringBuilder没有加锁，所以线程不安全</p><h2 id="Java异常⭐️⭐️⭐️"><a href="#Java异常⭐️⭐️⭐️" class="headerlink" title="Java异常⭐️⭐️⭐️"></a>Java异常⭐️⭐️⭐️</h2><p>Java中，所有的异常都有一个共同的祖先Throwable类，这个类主要有两个重要的子类</p><p>Exception 和 Error</p><ul><li>Exception 是程序本身可以处理的异常，可以通过catch来捕获。<ul><li>Exception又可以分为 Checked Exception可检异常(必须要处理)和Unchecked Exception不可检异常(可以不处理)</li><li>可检异常有：ClassNotFoundException(加载不存在的类时抛出的异常)、SQLException(与数据库交互时候的抛出的异常)、IOException(输入输出操作时候的异常)、ParseException(对日期和时间解析时可能抛出的异常)、FileNoteFoundException(尝试打开一个存在的文件时抛出的异常)</li><li>不可检异常：<ul><li>NullPointerException(空指针错误)</li><li>IllegalArgumentException(参数错误比如方法入参类型错误)</li><li>NumberFormatException（字符串转换为数字格式错误，IllegalArgumentException的子类）</li><li>ArrayIndexOutOfBoundsException（数组越界错误）</li><li>ClassCastException（类型转换错误）</li><li>ArithmeticException（算术错误）</li><li>SecurityException （安全错误比如权限不够）</li><li>UnsupportedOperationException(不支持的操作错误比如重复创建同一用户)</li></ul></li></ul></li><li>Error: Error属于程序无法处理的错误，没法通过catch来捕获。异常发生时Java虚拟机一般会选择终止。</li></ul><p>TODO: 异常捕获的代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">catch</span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">finally</span>&#123;</span><br><span class="line"></span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure><h2 id="🆗序列化和反序列化-⭐️⭐️"><a href="#🆗序列化和反序列化-⭐️⭐️" class="headerlink" title="🆗序列化和反序列化 ⭐️⭐️"></a>🆗序列化和反序列化 ⭐️⭐️</h2><p>序列化：将数据结构对象转化为<strong>二进制字节流</strong>的过程<br>反序列化：将在序列化过程中生成的二进制字节流转化成数据结构或者对象的过程</p><p>序列化的主要目的是通过网络对象或者是将对象存储到文件系统、数据库、内存中。</p><h2 id="反射-⭐⭐-面试官可能会问你什么是反射，它的优缺点是什么，有哪些应用场景"><a href="#反射-⭐⭐-面试官可能会问你什么是反射，它的优缺点是什么，有哪些应用场景" class="headerlink" title="反射 ⭐⭐ 面试官可能会问你什么是反射，它的优缺点是什么，有哪些应用场景"></a>反射 ⭐⭐ 面试官可能会问你什么是反射，它的优缺点是什么，有哪些应用场景</h2><p>通过反射可以获取任意一个类的所有属性和方法，并且可以调用这些方法和属性</p><p>优点：</p><ul><li>反射可以让代码更加灵活、为各种框架开发提供了遍历</li></ul><p>缺点：</p><ul><li>安全问题，可以无视泛型参数的安全检查(泛型参数的安全检查发生在编译时)</li><li>性能稍微差点</li></ul><p>反射的应用场景：</p><ul><li>框架中大量使用了动态代理，而动态代理的实现依赖反射</li><li>注解的实现也用到了反射</li></ul><h2 id="List、Set、Map、Queue的区别-⭐⭐"><a href="#List、Set、Map、Queue的区别-⭐⭐" class="headerlink" title="List、Set、Map、Queue的区别 ⭐⭐"></a>List、Set、Map、Queue的区别 ⭐⭐</h2><ul><li>List: 存储的元素是有序的、可重复的。</li><li>Set: 存储的元素不可重复的。</li><li>Queue: 按特定的排队规则来确定先后顺序，存储的元素是有序的、可重复的。</li><li>Map: 使用键值对（key-value）存储，类似于数学上的函数 y&#x3D;f(x)，”x” 代表 key，”y” 代表 value，key 是无序的、不可重复的，value 是无序的、可重复的，每个键最多映射到一个值</li></ul><h2 id="ArrayList-和-LinkedList-的区别。⭐⭐⭐⭐"><a href="#ArrayList-和-LinkedList-的区别。⭐⭐⭐⭐" class="headerlink" title="ArrayList 和 LinkedList 的区别。⭐⭐⭐⭐"></a>ArrayList 和 LinkedList 的区别。⭐⭐⭐⭐</h2><p>线程安全性：ArrayList 和 LinkedList 都是线程不安全的。</p><p>底层数据结构：ArrayList底层采用object数组存储，LinkedList底层采用的是双向链表</p><p>插入和删除元素：</p><ul><li>ArrayList采用数组存储，所以插入和删除元素的复杂度受到元素位置的影响</li><li>而LinkedList 采用双向链表 所以再头尾插入元素不受元素位置的影响。而在其他位置插入元素的话需要先遍历到那个位置。</li></ul><p>随机访问：ArrayList支持随机访问，而LinkedList不支持随机访问。</p><p>内存占用：ArrayList占用连续的内存空间，且在list列表的表尾会预留一部分空间导致内存的浪费；而LinkedList中的每一个元素都会占据比ArrayList更多的空间，因为要存放前驱+后继+元素</p><blockquote><p>我们在项目中一般是不会使用到 LinkedList 的，需要用到 LinkedList 的场景几乎都可以使用 ArrayList 来代替，并且，性能通常会更好！</p></blockquote><h2 id="比较HashSet、LinkedHashSet-和-TreeSet-三者的异同。【⭐⭐⭐】"><a href="#比较HashSet、LinkedHashSet-和-TreeSet-三者的异同。【⭐⭐⭐】" class="headerlink" title="比较HashSet、LinkedHashSet 和 TreeSet 三者的异同。【⭐⭐⭐】"></a>比较HashSet、LinkedHashSet 和 TreeSet 三者的异同。【⭐⭐⭐】</h2><ul><li>HashSet、LinkedHashSet 和 TreeSet 都是 Set 接口的实现类，都能保证元素唯一，并且都不是线程安全的。</li><li>HashSet、LinkedHashSet 和 TreeSet 的主要区别在于底层数据结构不同。<br>HashSet 的底层数据结构是哈希表（基于 HashMap 实现）。<br>LinkedHashSet 的底层数据结构是链表和哈希表，元素的插入和取出顺序满足 FIFO。<br>TreeSet 底层数据结构是红黑树，元素是有序的，排序的方式有自然排序和定制排序。</li><li>底层数据结构不同又导致这三者的应用场景不同。<br>HashSet 用于不需要保证元素插入和取出顺序的场景<br>LinkedHashSet 用于保证元素的插入和取出顺序满足 FIFO 的场景<br>TreeSet 用于支持对元素自定义排序规则的场景</li></ul><h2 id="HashMap-多线程操作导致死循环问题。【⭐⭐⭐】"><a href="#HashMap-多线程操作导致死循环问题。【⭐⭐⭐】" class="headerlink" title="HashMap 多线程操作导致死循环问题。【⭐⭐⭐】"></a>HashMap 多线程操作导致死循环问题。【⭐⭐⭐】</h2><p>Java1.7之前 HashMap在多线程的环境下扩容操作可能存在死循环的问题，因为当有多个元素需要扩容的时候，多个线程同时对链表进行操作，头插法可能会导致链表中的节点指向错误的位置，形成环形链表。Java1.8之后改为尾插法解决了这个问题。<br>但是多线程使用HashMap还容易导致数据覆盖的问题，并发环境下可以使用<code>ConcurrentHashMap</code></p><h2 id="HashMap-的长度为什么是-2-的幂次方。【⭐⭐⭐】"><a href="#HashMap-的长度为什么是-2-的幂次方。【⭐⭐⭐】" class="headerlink" title="HashMap 的长度为什么是 2 的幂次方。【⭐⭐⭐】"></a>HashMap 的长度为什么是 2 的幂次方。【⭐⭐⭐】</h2><p>为了尽量减少hash冲突，hash值的范围很大，但是这么大的映射空间的数组内存是放不下的，所以用之前会对数组进行取模运算，得到的余数才是对应的最终的数组下标，所以这样操作主要是考虑到了对运算效率的提升。<br>在设计算法的时候取余操作只有当除数是 2 的幂次才等价于与其除数减一的与(&amp;)操作<br>（也就是说 hash%length&#x3D;&#x3D;hash&amp;(length-1)的前提是 length 是 2 的 n 次方；）</p><h2 id="HashMap、HashTable、以及-ConcurrentHashMap-的区别⭐⭐⭐⭐⭐"><a href="#HashMap、HashTable、以及-ConcurrentHashMap-的区别⭐⭐⭐⭐⭐" class="headerlink" title="HashMap、HashTable、以及 ConcurrentHashMap 的区别⭐⭐⭐⭐⭐"></a>HashMap、HashTable、以及 ConcurrentHashMap 的区别⭐⭐⭐⭐⭐</h2><ol><li>首先HashMap和HashTable</li></ol><p>从线程安全性上来说：<br>HashMap是非线程安全的，HashTable是线程安全的，因为Hash的大部分方法都使用了synchronized修饰(但是如果想保证线程安全 还是要用ConcurrentHashMap)</p><p>从效率上来说：<br>因为线程安全问题，hashMap比HashTable效率高，而且hashtable有上位替代ConcurrentHashMap</p><p>从null key 和 null value 的支持上来说：HashMap可以存储null的key和value，但是null作为key只能有一个，作为值可以有多个；HashTable不允许有NUll键和Null值，否则会抛<code>NullPointerException</code></p><p>从初始容量大小和每次扩充的的容量大小上来说：</p><ol><li>如果不指定容量的初始，Hashtable默认为11 ，之后每次扩充扩充为原来容量的2N+1；HashMap默认大小为16,之后每次扩充为原来两倍。</li><li>如果指定容量的初始值，hashtable会直接用你指定的大小，而hashmap会将其扩充为2的幂次方大小。</li></ol><p>从底层数据结构上来说：<br>Java1.8之后的HashMap在解决哈希冲突时有了很大变化，当链表长度大于阈值的时候，将链表转化为红黑树以减少搜索的时间(在转化成红黑树之前会先判断当前数组的长度是否小于64，如果小于则先进行扩容,而不是转化成红黑树),而HashTable没有这样的机制。</p><ol start="2"><li>ConcurrentHashMap 和 Hashtable 的区别</li></ol><p>两者主要的区别是实现线程安全的方式不同</p><p>从底层数据结构上来说： JDK1.7 的ConcurrentHashMap采用<code>分段数组+链表</code>实现，JDK1.8采用的数据结构和HashMap1.8一样，采用数组+链表&#x2F;红黑二叉树。Hashtable 和 JDK1.8 之前的 HashMap 的底层数据结构类似,都是采用 数组+链表 的形式，<strong>数组是 HashMap 的主体，链表则是主要为了解决哈希冲突而存在的</strong></p><p>从实现线程安全的方式上来说：并发HashMap有多把锁，而Hashtable共用一把锁<br>在 JDK1.7 的时候，ConcurrentHashMap 对整个桶数组进行了分割(segment)，每一把锁只锁容器其中一部分数据，多线程访问容器里不同数据段的数据，就不会存在锁竞争，提高并发访问率。<br>到了 JDK1.8 的时候，ConcurrentHashMap不用segment了，而是直接用 Node 数组+链表+红黑树的数据结构来实现，并发控制使用 synchronized 和 CAS 来操作</p><p>Hashtable(同一把锁) :使用 synchronized 来保证线程安全，效率非常低下。当一个线程访问同步方法时，其他线程也访问同步方法，可能会进入阻塞或轮询状态，效率十分低下</p><blockquote><p>什么是 CAS? CAS 即比较并替换（Compare And Swap)，是实现并发算法时常用到的一种技术。CAS 操作包含三个操作数——内存位置、预期原值及新值。执行 CAS 操作的时候，将内存位置的值与预期原值比较，如果相匹配，那么处理器会自动将该位置值更新为新值，否则，处理器不做任何操作。我们都知道，CAS 是一条 CPU 的原子指令（cmpxchg 指令），不会造成所谓的数据不一致问题，Unsafe 提供的 CAS 方法（如 compareAndSwapXXX）底层实现即为 CPU 指令 cmpxchg 。</p></blockquote><h3 id="JDK-1-7-和-JDK-1-8-的-ConcurrentHashMap-实现有什么不同？"><a href="#JDK-1-7-和-JDK-1-8-的-ConcurrentHashMap-实现有什么不同？" class="headerlink" title="JDK 1.7 和 JDK 1.8 的 ConcurrentHashMap 实现有什么不同？"></a>JDK 1.7 和 JDK 1.8 的 ConcurrentHashMap 实现有什么不同？</h3><ul><li>线程安全实现方式：JDK 1.7 采用 Segment 分段锁来保证安全， Segment 是继承自 ReentrantLock。JDK1.8 放弃了 Segment 分段锁的设计，采用 Node + CAS + synchronized 保证线程安全，锁粒度更细，synchronized 只锁定当前链表或红黑二叉树的首节点。</li><li>Hash 碰撞解决方法 : JDK 1.7 采用拉链法，JDK1.8 采用拉链法结合红黑树（链表长度超过一定阈值时，将链表转换为红黑树）。</li><li>并发度：JDK 1.7 最大并发度是 Segment 的个数，默认是 16。JDK 1.8 最大并发度是 Node 数组的大小，并发度更大。</li></ul><h3 id="为什么要用红黑树"><a href="#为什么要用红黑树" class="headerlink" title="为什么要用红黑树"></a>为什么要用红黑树</h3><p>主要目的是解决哈希冲突<br>当哈希冲突发生时，通常会使用链表将具有相同哈希值的键值对存储在同一个桶中。<br>然而，当链表中的元素达到一定的阈值的时候，Java1.8会将链表转化为红黑树，红黑树是一种平衡二叉搜索树，具有更快的查找效率，可以解决链表过长的时候查找效率低下的问题</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Charles抓包测试工具</title>
      <link href="/undefined/326450ee.html"/>
      <url>/undefined/326450ee.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>接口自动化测试</title>
      <link href="/undefined/829df0fe.html"/>
      <url>/undefined/829df0fe.html</url>
      
        <content type="html"><![CDATA[<h2 id="URL-Uniform-Resource-Locator"><a href="#URL-Uniform-Resource-Locator" class="headerlink" title="URL(Uniform Resource Locator)"></a>URL(Uniform Resource Locator)</h2><p>统一资源定位符的组成: 协议、域名或ip 、端口号(协议默认端口可省略 常用:80(http)、443(https)) 、 请求路径、参数</p><h2 id="HTTP协议"><a href="#HTTP协议" class="headerlink" title="HTTP协议"></a>HTTP协议</h2><h3 id="HTTP请求"><a href="#HTTP请求" class="headerlink" title="HTTP请求"></a>HTTP请求</h3><p>请求行 请求头 请求体</p><p>请求报文中可以没有请求体数据</p><h3 id="HTTP相应"><a href="#HTTP相应" class="headerlink" title="HTTP相应"></a>HTTP相应</h3><p>状态行 响应头 响应体</p><p>状态行是响应数据的第一行，里面的状态码由三位数字组成，其中第一个数字定义响应类别：</p><ul><li>2:成功</li><li>4:客户端错误</li><li>5.服务端错误</li></ul><h2 id="接口规范"><a href="#接口规范" class="headerlink" title="接口规范"></a>接口规范</h2><h2 id="postman实现接口测试"><a href="#postman实现接口测试" class="headerlink" title="postman实现接口测试"></a>postman实现接口测试</h2><p>拿到一个项目之后,我们是先测业务流程还是先测单模块?</p><ul><li>先测试<strong>业务流程</strong>，确保核心功能正常</li><li>再测试单个模块</li></ul><h3 id="如何设计业务流程测试用例"><a href="#如何设计业务流程测试用例" class="headerlink" title="如何设计业务流程测试用例?"></a>如何设计业务流程测试用例?</h3><ul><li>根据流程图、找出业务路径</li><li>根据业务路径分析对应的接口请求</li><li>根据业务路径分析对应的接口请求</li></ul><h3 id="多消息体数据类型"><a href="#多消息体数据类型" class="headerlink" title="多消息体数据类型"></a>多消息体数据类型</h3><p>多用来上传文件</p><h3 id="批量执行"><a href="#批量执行" class="headerlink" title="批量执行"></a>批量执行</h3><p>通过运行测试集的方式批量运行测试用例。</p><p>如何针对单个接口设计测试用例?</p><ul><li>正向:必填参数、全部参数</li><li>逆向:空、类型错误、长度错误、规则不符</li></ul><h3 id="postman断言"><a href="#postman断言" class="headerlink" title="postman断言"></a>postman断言</h3><p>作用:让Postman工具代替人工<strong>自动判定</strong>预期结果和实际结果是否一致</p><ol><li>响应状态码断言</li><li>包含指定字符串断言</li><li>JSON数据断言</li></ol><blockquote><p>[!TIP]<br>断言一般用于常量，例如<code>token</code>这种随着每次登录都会变化的值</p></blockquote><h3 id="参数化"><a href="#参数化" class="headerlink" title="参数化"></a>参数化</h3><p>场景:测试脚本中仅<strong>测试数据</strong>不一样,使用参数化提高脚本复用</p><p>步骤：</p><ol><li>测试数据保存在数据文件(JSON格式)</li><li>引用数据文件使用脚本实现循环调用</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1. 请求参数中获取</span><br><span class="line">&#123;&#123;&#125;&#125;引用相关对象的key</span><br><span class="line">eg:&#123;&#123;username&#125;&#125;</span><br><span class="line">2. 代码中获取</span><br><span class="line">Postman内置data对象引用key</span><br><span class="line">eg. data.status</span><br></pre></td></tr></table></figure><p>批量执行+测试数据文件</p><h2 id="接口自动化测试"><a href="#接口自动化测试" class="headerlink" title="接口自动化测试"></a>接口自动化测试</h2><ul><li>接口自动化:使用工具或代码代替人对接口进行测试的技术。</li><li>测试目的:防止开发修改代码时引入新的问题。</li></ul><h3 id="接口自动化测试框架"><a href="#接口自动化测试框架" class="headerlink" title="接口自动化测试框架"></a>接口自动化测试框架</h3><ul><li><p>根据承担的职责存放对应的代码</p></li><li><p>使用allure生成在线测试报告</p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">allure serve report</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>测试基础</title>
      <link href="/undefined/322e93bb.html"/>
      <url>/undefined/322e93bb.html</url>
      
        <content type="html"><![CDATA[<h2 id="2024-05-25"><a href="#2024-05-25" class="headerlink" title="2024-05-25"></a>2024-05-25</h2><h3 id="记住测试流程-6个步骤"><a href="#记住测试流程-6个步骤" class="headerlink" title="记住测试流程(6个步骤)"></a>记住测试流程(6个步骤)</h3><ul><li>需求分析</li><li>测试计划</li><li>用例设计</li><li>用例执行</li><li>缺陷管理</li><li>测试报告</li></ul><h3 id="测试分类-7个"><a href="#测试分类-7个" class="headerlink" title="测试分类(7个)"></a>测试分类(7个)</h3><h3 id="给你一个测试对象-如何设计测试用例？"><a href="#给你一个测试对象-如何设计测试用例？" class="headerlink" title="给你一个测试对象 如何设计测试用例？"></a>给你一个测试对象 如何设计测试用例？</h3><p>首先分析这个测试对象使用于什么场景(如穷举场景、边界限制场景。。。)，根据场景选择对应的测试方法</p><p>在使用测试用例的过程中，可以用质量模型来思考测试时应该考虑的方面。<br>质量模型从以下几个方面来思考：功能、性能、兼容、易用性、安全</p><p>例题：如何去测试一个花瓶？</p><ol><li>功能： 插花、装水、养鱼、种菜</li><li>性能：防摔、耐高温、耐低温、耐腐蚀</li><li>易用：防滑、便携</li><li>属性：长、宽、高、样式、材质</li><li>……</li></ol><h3 id="穷举场景"><a href="#穷举场景" class="headerlink" title="穷举场景"></a>穷举场景</h3><p>使用”等价类划分法”</p><p>重点：有效等价和单个无效等价各取<strong>1个</strong>即可。</p><p>步骤：</p><ol><li>明确需求</li><li>确定有效和无效等价</li><li>根据有效和无效造数据编写用例(划分等价)</li></ol><p>重点：</p><ol><li>正向用例：一条尽可能覆盖多条</li><li>逆向用例：每一条数据，都是一条单独用例。</li></ol><p>针对：</p><ol><li>需要有大量数据测试输入，但是没法穷举测试的地方。</li><li>输入框</li><li>下拉列表</li><li>单选复选框</li></ol><p>典型代表：页面的输入框类测试。</p><h3 id="边界限制场景"><a href="#边界限制场景" class="headerlink" title="边界限制场景"></a>边界限制场景</h3><p>步骤:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1、明确需求</span><br><span class="line">2、确定有效和无效等价(类型)</span><br><span class="line">3、确定边界范围</span><br><span class="line">  上点(边界点)、离点(边界点两边最近的点)、内点(边界点内)</span><br><span class="line">所以一共有7个点</span><br><span class="line">4、提取数据编写用例</span><br></pre></td></tr></table></figure><p>优化：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">重点：开内闭外（开区间选包含的点，闭区选不包含的点）</span><br><span class="line"></span><br><span class="line">开区间：不包含边界上的点（没有等号）。如：a&lt;10</span><br><span class="line"></span><br><span class="line">闭区间：包含边界上的点（有等号）。 如:a&lt;=10</span><br></pre></td></tr></table></figure><p>典型代表:有边界范围的输入框类测试</p><h2 id="2024-05-26"><a href="#2024-05-26" class="headerlink" title="2024-05-26"></a>2024-05-26</h2><h3 id="多条件依赖问题"><a href="#多条件依赖问题" class="headerlink" title="多条件依赖问题"></a>多条件依赖问题</h3><p>使用判定表</p><p>步骤:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">1、明确需求</span><br><span class="line">2、画出判定表</span><br><span class="line">  1）、列出条件桩和动作桩 </span><br><span class="line">  2）、填写条件项，对条件进行全组合 </span><br><span class="line">  3）、根据条件项的组合确定动作项 </span><br><span class="line">  4）、简化、合并相似规则(有相同的动作)</span><br><span class="line">3、根据规则编写测试用例</span><br></pre></td></tr></table></figure><p>使用场景：</p><ol><li>有多个输入条件，多个输出结果，输入条件之间有组合关系，输入条件和输出结果之间有依赖关系</li><li>判定表一般适用于条件组合数量较少的情况(4个以下)</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"> 提示：</span><br><span class="line">1、多条件之间有依赖关系，使用判定表来进行测试覆盖。</span><br><span class="line">2、判定表一般适合4个以内条件依赖关系</span><br><span class="line">3、如果条件超过4个，就不适合覆盖所有条件，应采用（正交法）来解决。</span><br></pre></td></tr></table></figure><h3 id="业务测试"><a href="#业务测试" class="headerlink" title="业务测试"></a>业务测试</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">  重点:</span><br><span class="line">1、覆盖业务测试,需要使用流程图法</span><br><span class="line"></span><br><span class="line">2、先测试业务，在测试单功能、单模块、单页面</span><br></pre></td></tr></table></figure><p>⭐️ 面试题：任何测试都应该先走<strong>业务</strong></p><p>而测业务需要使用场景法</p><h3 id="错误推荐法"><a href="#错误推荐法" class="headerlink" title="错误推荐法"></a>错误推荐法</h3><p>应用场景：当项目用例都执行完毕，且BUG修复完成，离上线还有一段时间，在这段时间中可是使用错误推荐法复测主要业务或测试未覆盖的功能。</p><p>⭐️面试题：时间紧任务重不能加人的情况怎么尽最大努力测试? 答：1. 不写测试用例，先和产品人员沟通覆盖主要业务，选出重要的模块先正向后逆向2. 可以使用错误推荐法<strong>根据经验复测</strong>。</p><h2 id="缺陷"><a href="#缺陷" class="headerlink" title="缺陷"></a>缺陷</h2><h3 id="缺陷的描述"><a href="#缺陷的描述" class="headerlink" title="缺陷的描述"></a>缺陷的描述</h3><h4 id="缺陷的核心六要素"><a href="#缺陷的核心六要素" class="headerlink" title="缺陷的核心六要素"></a>缺陷的核心六要素</h4><ul><li>标题</li><li>预期结果</li><li>预置条件</li><li>实际结果</li><li>复现步骤</li><li>必要附件</li></ul><h4 id="缺陷类型"><a href="#缺陷类型" class="headerlink" title="缺陷类型"></a>缺陷类型</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">1、功能错误</span><br><span class="line">2、UI页面错误</span><br><span class="line">3、兼容性</span><br><span class="line">4、数据（数据库）</span><br><span class="line">5、易用性</span><br><span class="line">6、建议</span><br><span class="line">7、架构缺陷</span><br></pre></td></tr></table></figure><h4 id="工作流程小结"><a href="#工作流程小结" class="headerlink" title="工作流程小结"></a>工作流程小结</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">设计用例-&gt;执行用例（执行测试）-&gt;缺陷（提交、验证、关闭）</span><br><span class="line">缺陷定义：任何问题（Bug）</span><br><span class="line">缺陷标准：多功能、少功能、错误、缺少隐性功能、易用性</span><br><span class="line">描述缺陷重点：缺陷标题、前置条件、复现步骤、预期结果、实际结果、附件备注</span><br><span class="line">提交缺陷信息：指派人、缺陷等级、修复优先级、类型、状态（统计缺陷）</span><br></pre></td></tr></table></figure><h3 id="⭐️写用例的套路"><a href="#⭐️写用例的套路" class="headerlink" title="⭐️写用例的套路"></a>⭐️写用例的套路</h3><p>见xmind</p><ul><li>记住验证码测试用例永远是四条</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">  </span><br><span class="line">正向：</span><br><span class="line">  正确+未过期</span><br><span class="line">逆向： </span><br><span class="line">  为空</span><br><span class="line">  过期</span><br><span class="line">  错误</span><br></pre></td></tr></table></figure><ul><li>浏览器测试兼容性(显示输入操作)</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">五大浏览器内核：谷歌 火狐 IE 苹果 欧朋</span><br></pre></td></tr></table></figure><h3 id="提交注意事项"><a href="#提交注意事项" class="headerlink" title="提交注意事项"></a>提交注意事项</h3><p>当你发现缺陷后，首先会怎么办？</p><p>答案：确定Bug可复现，确定是Bug，提交时，要检查缺陷是否已存在。</p><h3 id="缺陷管理工具"><a href="#缺陷管理工具" class="headerlink" title="缺陷管理工具"></a>缺陷管理工具</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1、项目管理工具-管理缺陷 (禅道、JIRA、TFS)</span><br><span class="line">2、Excel管理缺陷</span><br></pre></td></tr></table></figure><h2 id="2024-05-27"><a href="#2024-05-27" class="headerlink" title="2024-05-27"></a>2024-05-27</h2><h3 id="登录界面的测试"><a href="#登录界面的测试" class="headerlink" title="登录界面的测试"></a>登录界面的测试</h3><h4 id="分析需求和提取测试点"><a href="#分析需求和提取测试点" class="headerlink" title="分析需求和提取测试点"></a>分析需求和提取测试点</h4><p>使用xmind</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>MySql</title>
      <link href="/undefined/6cac71de.html"/>
      <url>/undefined/6cac71de.html</url>
      
        <content type="html"><![CDATA[<h2 id="单表查询"><a href="#单表查询" class="headerlink" title="单表查询"></a>单表查询</h2><h3 id="1757可回收且低脂的产品"><a href="#1757可回收且低脂的产品" class="headerlink" title="1757可回收且低脂的产品"></a>1757可回收且低脂的产品</h3><ul><li>注意要返回的是什么那么就去select什么</li></ul><h3 id="584寻找用户推荐人"><a href="#584寻找用户推荐人" class="headerlink" title="584寻找用户推荐人"></a>584寻找用户推荐人</h3><ul><li><p>MySQL是三值逻辑，分别为TRUE、FALSE和UNKNOWN，逻辑判断是如果逻辑运算符一端为NULL，则为UNKNOWN； 这段代码 referee_id &#x3D;2 为TRUE，则NOT TURE为FALSE和UNKNOWN，即&lt;&gt;2 OR 为NULL</p></li><li><p>null不可以和数值类直接比较，其结果为unkonwn</p></li><li><p>⭐️IFNULL(referee_id, 0) &lt;&gt; 2:意思是如果 referee_id 列的值为 NULL，则将其替换为 0，然后与 2 进行比较。如果 referee_id 列的值不等于 2，那么这一行将被包含在结果中</p></li></ul><h3 id="1148文章浏览-1"><a href="#1148文章浏览-1" class="headerlink" title="1148文章浏览 1"></a>1148文章浏览 1</h3><ul><li>我们可以在 SELECT 语句中使用 DISTINCT 关键字来从表 Views 中检索唯一元素</li><li>select 可以给列取别名</li></ul><h3 id="1683-无效的推文"><a href="#1683-无效的推文" class="headerlink" title="1683.无效的推文"></a>1683.无效的推文</h3><ul><li>获取某列字符长度的函数： CHAR_LENGTH ()</li></ul><h2 id="多表查询"><a href="#多表查询" class="headerlink" title="多表查询"></a>多表查询</h2><p>多表之间的业务关系主要有以下三种：</p><ol><li>一对多(部门与部门员工的关系):多的一方建立外键，指向一的一方的主键</li><li>多对多(学生与课程的关系):建立第三张中间表,中间表至少包含两个外键,分别关联两方主键</li><li>一对一(用户与用户详情的关系):在任意一方加入外键,关联另外一方的主键,并且设置外键为唯一的(UNIQUE)</li></ol><h3 id="多表查询分类"><a href="#多表查询分类" class="headerlink" title="多表查询分类"></a>多表查询分类</h3><h4 id="连接"><a href="#连接" class="headerlink" title="连接"></a>连接</h4><h5 id="内连接"><a href="#内连接" class="headerlink" title="内连接"></a>内连接</h5><p>查询两个表之间的交集</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">1). 隐式内连接</span><br><span class="line">SELECT</span><br><span class="line">字段列表</span><br><span class="line">FROM</span><br><span class="line">表1 , 表2</span><br><span class="line">WHERE</span><br><span class="line">条件 ... ;</span><br></pre></td></tr></table></figure><p>2). 显式内连接</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">SELECT</span><br><span class="line">字段列表</span><br><span class="line">FROM</span><br><span class="line">表1</span><br><span class="line">[ INNER ]</span><br><span class="line">JOIN 表2</span><br><span class="line">ON</span><br><span class="line">连接条件 ... ;</span><br></pre></td></tr></table></figure><h5 id="外连接"><a href="#外连接" class="headerlink" title="外连接"></a>外连接</h5><p>外连接将两个表按照匹配条件合成一张表</p><ul><li>左外连接：查询左表所有数据,以及两张表交集部分数据   <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">   表1</span><br><span class="line">LEFT</span><br><span class="line">[ OUTER ]</span><br><span class="line">JOIN 表2</span><br><span class="line">ON</span><br><span class="line">条件 ... ;</span><br></pre></td></tr></table></figure></li><li>右外连接：查询右表所有数据,以及两张表交集部分数据<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"> 表1</span><br><span class="line">RIGHT</span><br><span class="line">[ OUTER ]</span><br><span class="line">JOIN 表2</span><br><span class="line">ON</span><br><span class="line">条件 ... ;</span><br></pre></td></tr></table></figure></li></ul><h5 id="自连接"><a href="#自连接" class="headerlink" title="自连接"></a>自连接</h5><p>当前表与自身的连接查询,自连接必须使用表别名</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"> 表A</span><br><span class="line">别名A</span><br><span class="line">JOIN</span><br><span class="line">表A</span><br><span class="line">别名B</span><br><span class="line">ON</span><br><span class="line">条件 ... ;</span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><p>[!TIP]<br>在自连接查询中,必须要为表起别名,要不然我们不清楚所指定的条件、返回的字段,到底<br>是哪一张表的字段。</p></blockquote><h5 id="联合查询"><a href="#联合查询" class="headerlink" title="联合查询"></a>联合查询</h5><h4 id="子查询"><a href="#子查询" class="headerlink" title="子查询"></a>子查询</h4><p>指嵌套在主查询中的一个查询</p><h3 id="1378-使用唯一标识码替换员工ID"><a href="#1378-使用唯一标识码替换员工ID" class="headerlink" title="1378.使用唯一标识码替换员工ID"></a>1378.使用唯一标识码替换员工ID</h3><p>使用outer join会保留主表的全部，以及次表与主表能匹配的记录，没有匹配时返回null</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">表1 left join 表2 on 连接条件</span><br></pre></td></tr></table></figure><p>左外连接表示保留表1的所有数据，表2中没有的记录返回null</p><h3 id="产品销售分析"><a href="#产品销售分析" class="headerlink" title="产品销售分析"></a>产品销售分析</h3><h3 id=""><a href="#" class="headerlink" title=""></a></h3>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>算法</title>
      <link href="/undefined/b7e144d1.html"/>
      <url>/undefined/b7e144d1.html</url>
      
        <content type="html"><![CDATA[<h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><ul><li>数组的元素在内存地址中是连续的，不能单独删除数组中的某个元素，只能覆盖。</li></ul><h3 id="704-二分查找"><a href="#704-二分查找" class="headerlink" title="704 二分查找"></a>704 二分查找</h3><p>要注意选取的是左闭右闭的区间还是左闭右开的区间</p><h3 id="27-原地移除数组中的元素"><a href="#27-原地移除数组中的元素" class="headerlink" title="27 原地移除数组中的元素"></a>27 原地移除数组中的元素</h3><p>双指针思路:</p><ul><li>快指针用于寻找”新“数组中的元素</li><li>慢指针是新数组的下标值</li><li>快指针遍历数组，当遇见不为val的数值（即新数组中的元素）则赋值给nums[slow]，遍历完就可得到新数组</li></ul><h3 id="977-有序数组的平方"><a href="#977-有序数组的平方" class="headerlink" title="977 有序数组的平方"></a>977 有序数组的平方</h3><ul><li>思路：因为数组中有负数，所以平方之后最大值就在数组的两端，那么定义两个指针从两边往中间遍历</li></ul><h3 id="209-长度最小的子数组"><a href="#209-长度最小的子数组" class="headerlink" title="209 长度最小的子数组"></a>209 长度最小的子数组</h3><ul><li>滑动窗口:</li></ul><p>窗口就是 满足其和 ≥ s 的长度最小的 连续 子数组。</p><p>窗口的起始位置如何移动：如果当前窗口的值大于等于s了，窗口就要向前移动了（也就是该缩小了,此时移动左边界）。</p><p>窗口的结束位置如何移动：窗口的结束位置就是遍历数组的右指针，也就是for循环里的索引。</p><p>整体思路：<br>  右指针遍历数组，将遍历到的值添加进结果数组<br>  每当添加一个新的值之后，判断当前数组中的值是否大于目标值，若是大于则判断当前的长度是比已记录的长度小 然后移动左指针缩写窗口，并将窗口左端的值移出结果</p><h3 id="⭐️54螺旋矩阵"><a href="#⭐️54螺旋矩阵" class="headerlink" title="⭐️54螺旋矩阵"></a>⭐️54螺旋矩阵</h3><p>略</p><p>算法思路:</p><ol><li>空值处理： 当 matrix 为空时，直接返回空列表 [] 即可。</li><li>初始化： 矩阵 左、右、上、下 四个边界 l , r , t , b ，用于打印的结果列表 res 。</li><li>循环打印： “从左向右、从上向下、从右向左、从下向上” 四个方向循环打印。<ol><li>根据边界打印，即将元素按顺序添加至列表 res 尾部。</li><li>边界向内收缩 1 （代表已被打印）。</li><li>判断边界是否相遇（是否打印完毕），若打印完毕则跳出。<br>&#x2F;&#x2F;            对左子表进行排序</li></ol></li><li>返回值： 返回 res 即可。</li></ol><h3 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h3><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><ul><li>是基于分治的思想的排序算法，一次排序确定一个元素（枢轴元素）的位置，将整个表划分为左右两个子表</li><li>使用递归的思想，算法的输入数据是：最左下标、最右下标、数组</li><li>一趟划分的算法中，要注意循环跳出条件是low &lt; high ,要注意在每次移动指针之前，都要判断low &lt; high,最终返回的是排序好的枢轴元素的下标low</li></ul><h3 id="数组章节总结"><a href="#数组章节总结" class="headerlink" title="数组章节总结"></a>数组章节总结</h3><ul><li>数组是存放在连续内存空间上的相同类型数据的集合。</li><li>数组下标都是从0开始的。</li><li>数组内存空间的地址是连续的；因为数组的在内存空间的地址是连续的，所以我们在删除或者增添元素的时候，就难免要移动其他元素的地址。</li></ul><h2 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h2><h3 id="链表理论基础"><a href="#链表理论基础" class="headerlink" title="链表理论基础"></a>链表理论基础</h3><p>Java中链表的定义</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ListNode</span> &#123;</span><br><span class="line">    <span class="comment">// 结点的值</span></span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 下一个结点</span></span><br><span class="line">    ListNode next;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 节点的构造函数(无参)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ListNode</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 节点的构造函数(有一个参数)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ListNode</span><span class="params">(<span class="type">int</span> val)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.val = val;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 节点的构造函数(有两个参数)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ListNode</span><span class="params">(<span class="type">int</span> val, ListNode next)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.val = val;</span><br><span class="line">        <span class="built_in">this</span>.next = next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>链表操作的两种方式：</p><ul><li><p>直接使用原来的链表来进行删除操作。</p></li><li><p>设置一个虚拟头结点在进行删除操作。(推荐)</p></li></ul><h3 id="206-反转链表"><a href="#206-反转链表" class="headerlink" title="206 反转链表"></a>206 反转链表</h3><ul><li>申请两个指针pre和cur</li><li>申请一个temp记录cur的位置</li><li>原地反转链表指针</li><li>同时向后平移两个指针</li></ul><h3 id="203-移除链表元素"><a href="#203-移除链表元素" class="headerlink" title="203 移除链表元素"></a>203 移除链表元素</h3><p>设置一个虚拟头结点，这样原链表的所有节点就都可以按照统一的方式进行移除了。</p><ul><li><p>注意遍历终止的条件是当前指针指向的节点为空</p></li><li><p>每一次判断之后同时移动两个指针</p></li><li><p>最后返回虚拟头结点的下一个节点即为新节点的头</p></li></ul><h3 id="707-设计链表"><a href="#707-设计链表" class="headerlink" title="707 设计链表"></a>707 设计链表</h3><ul><li>首先设计链表节点</li><li>然后用单链表+虚拟头结点实现需求</li></ul><h3 id="21-合并两个有序链表"><a href="#21-合并两个有序链表" class="headerlink" title="21 合并两个有序链表"></a>21 合并两个有序链表</h3><ul><li>依次比较两个链表的节点值做就行</li><li>注意一个链表遍历完了之后将另一个链表的剩余部分直接拼接到新链表尾部即可</li></ul><h2 id="哈希表理论基础和总结"><a href="#哈希表理论基础和总结" class="headerlink" title="哈希表理论基础和总结"></a>哈希表理论基础和总结</h2><p>哈希表是根据关键码的值而直接进行访问的数据结构</p><ul><li><p>需要 <strong>判断一个元素是否出现过</strong> 或者<strong>一个元素出现的频次</strong>场景应该第一时间想到哈希法。</p></li><li><p>数组就是一张简单的hash表</p></li><li><p>使用哈希表的时候注意数据结构的选择</p><ul><li>数组 : 适用于元素不是太大的情况,将数据转换成哈希数组的效率较高，建议优先使用。</li><li>set :转变成set需要进行hash运算，效率较低。</li><li>map :要存放两个元素（数值和频率）（key和value）</li></ul></li><li><p>解题思路</p><ul><li>先想到用哈希表</li><li>考虑用什么存储结构</li></ul></li></ul><h3 id="242-有效的字母异位词"><a href="#242-有效的字母异位词" class="headerlink" title="242 有效的字母异位词"></a>242 有效的字母异位词</h3><ul><li>申请一个长为26位的数组用来记录字符串中字母出现的次数，然后将字符串s的频次依次存入数组 数组下标对应26个字母， 数组的值对应频次；然后遍历字符串t减去对应频次；最后遍历数组，只要有位置上值不为0，就说明当前字母的出现频次不一样多</li><li>字母运算时会自动取 ASCII 码。</li><li>在Java中，s.charAt(i) 是一个常用的字符串（String）方法，用于获取字符串 s 中索引位置为 i 的字符</li></ul><h3 id="数组交集"><a href="#数组交集" class="headerlink" title="数组交集"></a>数组交集</h3><ul><li><p>思路是记录两个数组中相同元素出现的次数，只要都&gt;1就证明是有交集 ; 因为记录频次所以想到用hash 因为不清楚数值的范围且哈希值比较少比较分散 所以不选择数组，而是使用set ， 在java中对应的数据结构就是hashset</p></li><li><p>Java 基础回顾</p></li></ul><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">在Java中，List是一个接口，它代表了一个有序的集合，允许重复的元素。List接口继承自Collection接口，它是集合框架中的一部分，用于存储一组元素，并且可以对这些元素进行访问、添加、删除和修改等操作。</span><br><span class="line"></span><br><span class="line">Java中常用的List实现类包括：</span><br><span class="line"></span><br><span class="line">ArrayList：基于数组实现的动态数组，支持随机访问，但在插入和删除操作时可能会涉及元素的移动。大小可以动态增长。</span><br><span class="line">LinkedList：基于链表实现的双向链表，插入和删除操作性能较好，但随机访问效率较低。</span><br><span class="line">Vector：与ArrayList类似，但是它是线程安全的，因此在多线程环境下使用较为安全，但性能相对较低。</span><br><span class="line">List接口定义了一系列方法，包括但不限于：</span><br><span class="line"></span><br><span class="line">int size()：返回列表中的元素数量。</span><br><span class="line">boolean isEmpty()：检查列表是否为空。</span><br><span class="line">boolean contains(Object o)：检查列表是否包含指定的元素。</span><br><span class="line">boolean add(E e)：将指定的元素添加到列表的末尾。</span><br><span class="line">void add(int index, E element)：将指定的元素插入到列表的指定位置。</span><br><span class="line">E remove(int index)：移除列表中指定位置的元素。</span><br><span class="line">void clear()：清空列表中的所有元素。</span><br><span class="line">E get(int index)：返回列表中指定位置的元素。</span><br><span class="line">E set(int index, E element)：将列表中指定位置的元素替换为指定的元素。</span><br></pre></td></tr></table></figure><ul><li>使用数组来做哈希的题目，是因为题目都限制了数值的大小;而且如果哈希值比较少、特别分散、跨度非常大，使用数组就造成空间的极大浪费。此时就要使用另一种结构体了，set。</li></ul><h3 id="1-两数之和"><a href="#1-两数之和" class="headerlink" title="1 两数之和"></a>1 两数之和</h3><ul><li><p>思路：一边遍历，一边将其存入哈希表，在遍历时判断我们要找的元素之前是否出现过。</p></li><li><p>我们既要知道元素的值，还要知道元素的下标所以此时用set 和 数组都不合适 要使用map ，Java中对应的数据结构是hashmap</p></li><li><p>注意：map是要存放 <strong>遍历过</strong> 的元素, 我们是要判断元素是否出现过，所以元素得作为key ，而value用来存放元素在数组中对应的下标，因为最后要返回的是元素的下标</p></li><li><p>在遍历数组的时候，只需要去map查询目标元素是否已出现过，有的话就找到了，没有则将当前遍历的元素放入map中</p></li></ul><h3 id="202-快乐数"><a href="#202-快乐数" class="headerlink" title="202 快乐数"></a>202 快乐数</h3><ul><li>无限循环，即求和的过程中,如果求出的和反复出现了，那么就说明这个数永远不可能是快乐数了 所以无限循环的终止条件是<strong>n &#x3D; 1 或着n重复出现过了</strong> ,因为这里出现了判断一个数是否出现过的情况，所以用hash法</li><li>求和的过程中需要取出数值各个位上的数，这个算法经常用到，要记熟:用<code>n % 10</code>取出最小位上的数，然后<code>n / 10</code>舍去这一位</li></ul><h3 id="四数相加"><a href="#四数相加" class="headerlink" title="四数相加"></a>四数相加</h3><ul><li>思路：前两个数组遍历相加，把所有的和存到一个数组A里，同时要记录出现的次数；后两个数组遍历相加，把所有的和存在一个数组B里,同时要记录出现的次数；遍历A看看想要的数在B中是否存在</li><li>因为既要知道数，还要统计次数，所以使用map（键值对）作为hash表的存储结构，此时key是值，value是出现的次数</li><li>注意：两两分组的复杂度是n^2, 一三分组是n^3。</li><li>每次配对成功后，count计数应该是加value里的值</li></ul><h3 id="三数相加"><a href="#三数相加" class="headerlink" title="三数相加"></a>三数相加</h3><ul><li>先排序</li><li>去重逻辑（有了再考虑去重，而不是还没有用就去考虑去重）</li><li>双指针解  i left right</li></ul><h3 id="四数之和"><a href="#四数之和" class="headerlink" title="四数之和"></a>四数之和</h3><ul><li>思路类似三数之和 i j left right</li><li>注意剪枝操作和去重操作</li></ul><h2 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h2><h3 id="替换空格"><a href="#替换空格" class="headerlink" title="替换空格"></a>替换空格</h3><p>实现一个函数，将一个字符串中的所有空格替换为”%20”</p><p>这里关于字符串操作要注意:</p><ul><li>String 是不可变的，所以没有类似append、delete、replace等增删改的方法,需要操作的话必须先转化为StringBuffer类型</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">solution</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//法1</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">replaceSpace</span><span class="params">( StringBuffer str)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> str.toString().replace(<span class="string">&quot; &quot;</span>,<span class="string">&quot;%20&quot;</span>);<span class="comment">//转换成字符串String类型，然后调用方法replace</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 法2 遍历字符串</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">replaceSpace2</span><span class="params">(StringBuffer str)</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="variable">length</span> <span class="operator">=</span> str.length();</span><br><span class="line">    <span class="type">StringBuffer</span> <span class="variable">result</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuffer</span>();</span><br><span class="line">    <span class="comment">// 遍历字符串</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; length; i++) &#123;</span><br><span class="line">      <span class="type">char</span> <span class="variable">b</span> <span class="operator">=</span> str.charAt(i);<span class="comment">//取出当前index下的字符</span></span><br><span class="line">      <span class="keyword">if</span> (String.valueOf(b).equals(<span class="string">&quot; &quot;</span>)) &#123; <span class="comment">//此处 String.valueOf方法用于将其他类型转化为字符串类型String</span></span><br><span class="line">        result.append(<span class="string">&quot;%20&quot;</span>); <span class="comment">//如果为空格 则在result后方插入%20</span></span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        result.append(b); <span class="comment">//如果不是则直接append</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result.toString(); <span class="comment">//由于result是StringBuffer类型 ， 所以要转化为String类型返回</span></span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="1768合并字符串"><a href="#1768合并字符串" class="headerlink" title="1768合并字符串"></a>1768合并字符串</h3><ul><li>不可便字符序列<code>String</code>以及常用api</li></ul><p>（1）boolean isEmpty()：字符串是否为空</p><p>（2）int length()：返回字符串的长度</p><p>（3）String concat(xx)：拼接</p><p> （4）boolean equals(Object obj)：比较字符串是否相等，区分大小写</p><p>（5）boolean equalsIgnoreCase(Object obj)：比较字符串是否相等，不区分大小写</p><p>（6）int compareTo(String other)：比较字符串大小，区分大小写，按照Unicode编码值比较大小</p><p>（7）int compareToIgnoreCase(String other)：比较字符串大小，不区分大小写</p><p>（8）String toLowerCase()：将字符串中大写字母转为小写</p><p>（9）String toUpperCase()：将字符串中小写字母转为大写</p><p>（10）String trim()：去掉字符串前后空白符</p><p>（11）public String intern()：结果在常量池中共享</p><ul><li>可变字符序列<code>StringBuilder</code>和<code>StringBuffer</code> 前者线程不安全，后者线程安全 两者常用api一致</li></ul><p>（1）StringBuffer append(xx)：提供了很多的append()方法，用于进行字符串追加的方式拼接</p><p>（2）StringBuffer delete(int start, int end)：删除[start,end)之间字符</p><p>（3）StringBuffer deleteCharAt(int index)：删除[index]位置字符</p><p>（4）StringBuffer replace(int start, int end, String str)：替换[start,end)范围的字符序列为str</p><p>（5）void setCharAt(int index, char c)：替换[index]位置字符</p><p>（6）char charAt(int index)：查找指定index位置上的字符</p><p>（7）StringBuffer insert(int index, xx)：在[index]位置插入xx</p><p>（8）int length()：返回存储的字符数据的长度</p><p>（9）StringBuffer reverse()：反转</p><h4 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h4><p>直接模拟过程就行</p><h3 id="1071字符串的最大公因子"><a href="#1071字符串的最大公因子" class="headerlink" title="1071字符串的最大公因子"></a>1071字符串的最大公因子</h3><h3 id="344-反转字符串"><a href="#344-反转字符串" class="headerlink" title="344 反转字符串"></a>344 反转字符串</h3><ul><li>双指针秒了</li></ul><h3 id="541-反转字符串2"><a href="#541-反转字符串2" class="headerlink" title="541 反转字符串2"></a>541 反转字符串2</h3><p>难点就在如何去除多余的空格：这其实就是删除元素的算法，需要使用<strong>快慢指针</strong>的方法: 快指针寻找符合要求的字母（要收集的字母）、慢指针就是来表示要更新在哪里</p><p>题目要求：</p><ul><li>输入: “the sky is blue”</li><li>输出: “blue is sky the”</li><li>输入字符串可以在前面或者后面包含多余的空格，但是反转后的字符不能包括。</li><li>如果两个单词间有多余的空格，将反转后单词间的空格减少到只含一个。</li></ul><p>解题思路：</p><ul><li>将整个字符串都反转过来，那么单词的顺序指定是倒序了，只不过单词本身也倒序了，那么再把单词反转一下，单词不就正过来了。</li></ul><p>所以解题思路如下：</p><ul><li>移除多余空格</li><li>将整个字符串反转</li><li>将每个单词反转</li></ul><h3 id="KMP算法"><a href="#KMP算法" class="headerlink" title="KMP算法"></a>KMP算法</h3><ul><li>用以解决字符串匹配的问题 <strong>我直接放弃</strong></li></ul><h2 id="双指针法"><a href="#双指针法" class="headerlink" title="双指针法"></a>双指针法</h2><h3 id="27-移除元素"><a href="#27-移除元素" class="headerlink" title="27 移除元素"></a>27 移除元素</h3><ul><li><p>暴力法：两层for循环</p></li><li><p>双指针法:</p><ul><li>快指针：遍历旧数组</li><li>慢指针：指向新数组下标</li></ul></li></ul><h3 id="19-移除链表倒数第N个元素"><a href="#19-移除链表倒数第N个元素" class="headerlink" title="19 移除链表倒数第N个元素"></a>19 移除链表倒数第N个元素</h3><ul><li>双指针法,让fast先移动n个，然后同时移动fast和slow直到fast指向链表尾部，然后删除slow指向的节点即可</li></ul><h3 id="459-重复的子字符串"><a href="#459-重复的子字符串" class="headerlink" title="459 重复的子字符串"></a>459 重复的子字符串</h3><ul><li>暴力法：一个for循环获取字串的终止位置，然后另一个for循环判断字串是否能重复构成字符串；不需要遍历到结尾，只需要遍历到中间位置，因为子串结束位置大于中间位置的话，一定不能重复组成字符串。</li></ul><h3 id="链表相交"><a href="#链表相交" class="headerlink" title="链表相交"></a>链表相交</h3><ul><li><p>两链表相交的起始节点，代表指针相同，而不是值相同</p></li><li><p>如下图 只要定义两个指针 同时移动，如若有交点 一定会左a+c+b步之后相遇</p><p><img src="/home/time/%E6%96%87%E6%A1%A3/Notes/%E5%90%8E%E7%AB%AF%E5%BC%80%E5%8F%91%E6%B1%82%E8%81%8C%E7%AC%94%E8%AE%B0/%E7%AE%97%E6%B3%95.assets/image-20240628210035695.png" alt="image-20240628210035695"></p></li></ul><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><h3 id="9-回文数"><a href="#9-回文数" class="headerlink" title="9. 回文数"></a>9. 回文数</h3><ul><li>反转后看是否和原来的数字相等</li></ul><p>将整数反转的代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">reverseNum</span><span class="params">(<span class="type">int</span> x )</span>&#123;</span><br><span class="line">  <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> x;</span><br><span class="line">  <span class="type">int</span> <span class="variable">rev</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">while</span> (temp != <span class="number">0</span>)&#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">p</span> <span class="operator">=</span> temp % <span class="number">10</span>;</span><br><span class="line">    temp = temp / <span class="number">10</span>;</span><br><span class="line">    rev = rev * <span class="number">10</span> + p;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> rev;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Docker笔记</title>
      <link href="/undefined/5c266b64.html"/>
      <url>/undefined/5c266b64.html</url>
      
        <content type="html"><![CDATA[<h2 id="docker-是什么？"><a href="#docker-是什么？" class="headerlink" title="docker 是什么？"></a>docker 是什么？</h2><ul><li>docker 独立的容器（container），可以跨系统的运行打包好的程序</li></ul><h2 id="docker-常见命令"><a href="#docker-常见命令" class="headerlink" title="docker 常见命令"></a>docker 常见命令</h2><p>停止所有正在运行的容器并且删除所有容器</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker stop $(docker ps -aq) &amp;&amp; docker rm $(docker ps -aq)</span><br></pre></td></tr></table></figure><p><img src="/home/time/%E6%96%87%E6%A1%A3/Notes/%E5%90%8E%E7%AB%AF%E5%BC%80%E5%8F%91%E6%B1%82%E8%81%8C%E7%AC%94%E8%AE%B0/Docker%E7%AC%94%E8%AE%B0.assets/image-20240702142158297.png" alt="image-20240702142158297"></p><h2 id="使用docker的demo"><a href="#使用docker的demo" class="headerlink" title="使用docker的demo"></a>使用docker的demo</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">从dockerhub镜像仓库拉取镜像（image）</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">第1步，去DockerHub查看nginx镜像仓库及相关信息</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">第2步，拉取Nginx镜像</span></span><br><span class="line">docker pull nginx</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">第3步，查看镜像</span></span><br><span class="line">docker images</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">结果如下：</span></span><br><span class="line">REPOSITORY   TAG       IMAGE ID       CREATED         SIZE</span><br><span class="line">nginx        latest    605c77e624dd   16 months ago   141MB</span><br><span class="line">mysql        latest    3218b38490ce   17 months ago   516MB</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">第4步，创建并运行Nginx容器</span></span><br><span class="line">docker run -d --name nginx -p 80:80 nginx</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">第5步，查看运行中容器</span></span><br><span class="line">docker ps</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">也可以加格式化方式访问，格式会更加清爽</span></span><br><span class="line">docker ps --format &quot;table &#123;&#123;.ID&#125;&#125;\t&#123;&#123;.Image&#125;&#125;\t&#123;&#123;.Ports&#125;&#125;\t&#123;&#123;.Status&#125;&#125;\t&#123;&#123;.Names&#125;&#125;&quot;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">第6步，访问网页，地址：http://虚拟机地址</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">第7步，停止容器</span></span><br><span class="line">docker stop nginx</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">第8步，查看所有容器,将还指令<span class="built_in">alias</span> 为dps 格式化查看容器</span></span><br><span class="line">docker ps -a --format &quot;table &#123;&#123;.ID&#125;&#125;\t&#123;&#123;.Image&#125;&#125;\t&#123;&#123;.Ports&#125;&#125;\t&#123;&#123;.Status&#125;&#125;\t&#123;&#123;.Names&#125;&#125;&quot;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">第9步，再次启动nginx容器</span></span><br><span class="line">docker start nginx</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">第10步，再次查看容器</span></span><br><span class="line">docker ps --format &quot;table &#123;&#123;.ID&#125;&#125;\t&#123;&#123;.Image&#125;&#125;\t&#123;&#123;.Ports&#125;&#125;\t&#123;&#123;.Status&#125;&#125;\t&#123;&#123;.Names&#125;&#125;&quot;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">第11步，查看容器详细信息</span></span><br><span class="line">docker inspect nginx</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">第12步，进入容器,查看容器内目录</span></span><br><span class="line">docker exec -it nginx bash</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">或者，可以进入MySQL</span></span><br><span class="line">docker exec -it mysql mysql -uroot -p</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">第13步，删除容器</span></span><br><span class="line">docker rm nginx</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">发现无法删除，因为容器运行中，强制删除容器</span></span><br><span class="line">docker rm -f nginx</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="挂载宿主机目录和容器内目录"><a href="#挂载宿主机目录和容器内目录" class="headerlink" title="挂载宿主机目录和容器内目录"></a>挂载宿主机目录和容器内目录</h2><h3 id="方法1-通过数据卷间接挂载（较为繁琐-不常用）"><a href="#方法1-通过数据卷间接挂载（较为繁琐-不常用）" class="headerlink" title="方法1:通过数据卷间接挂载（较为繁琐 不常用）"></a>方法1:通过数据卷间接挂载（较为繁琐 不常用）</h3><ul><li>数据卷（volume）是一个虚拟目录，是容器内目录与宿主机目录之间映射的桥梁。</li><li>容器与数据卷的挂载要在创建容器时配置，对于创建好的容器，是不能设置数据卷的。而且创建容器的过程中，数据卷会自动创建。</li></ul><h4 id="demo"><a href="#demo" class="headerlink" title="demo"></a>demo</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">1.首先创建容器并指定数据卷，注意通过 -v 参数来指定数据卷</span></span><br><span class="line">docker run -d --name nginx -p 80:80 -v html:/usr/share/nginx/html nginx</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">2.然后查看数据卷</span></span><br><span class="line">docker volume ls</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">结果</span></span><br><span class="line">DRIVER    VOLUME NAME</span><br><span class="line">local     29524ff09715d3688eae3f99803a2796558dbd00ca584a25a4bbc193ca82459f</span><br><span class="line">local     html</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">3.查看数据卷详情</span></span><br><span class="line">docker volume inspect html</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">结果</span></span><br><span class="line">[</span><br><span class="line">&#123;</span><br><span class="line">  &quot;CreatedAt&quot;: &quot;2024-05-17T19:57:08+08:00&quot;,</span><br><span class="line">    &quot;Driver&quot;: &quot;local&quot;,</span><br><span class="line">    &quot;Labels&quot;: null,</span><br><span class="line">    &quot;Mountpoint&quot;: &quot;/var/lib/docker/volumes/html/_data&quot;,</span><br><span class="line">    &quot;Name&quot;: &quot;html&quot;,</span><br><span class="line">    &quot;Options&quot;: null,</span><br><span class="line">    &quot;Scope&quot;: &quot;local&quot;</span><br><span class="line">&#125;</span><br><span class="line">]</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">4.查看/var/lib/docker/volumes/html/_data目录</span></span><br><span class="line">ll /var/lib/docker/volumes/html/_data</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">可以看到与nginx的html目录内容一样，结果如下：</span></span><br><span class="line">总用量 8</span><br><span class="line">-rw-r--r--. 1 root root 497 12月 28 2021 50x.html</span><br><span class="line">-rw-r--r--. 1 root root 615 12月 28 2021 index.html</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">5.进入该目录，并随意修改index.html内容</span></span><br><span class="line">cd /var/lib/docker/volumes/html/_data</span><br><span class="line">vi index.html</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">6.打开页面，查看效果</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">7.进入容器内部，查看/usr/share/nginx/html目录内的文件是否变化</span></span><br><span class="line">docker exec -it nginx bash</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="法二：不通过数据卷直接挂载"><a href="#法二：不通过数据卷直接挂载" class="headerlink" title="法二：不通过数据卷直接挂载"></a>法二：不通过数据卷直接挂载</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">挂载本地目录</span></span><br><span class="line">-v 本地目录:容器内目录</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">挂载本地文件</span></span><br><span class="line">-v 本地文件:容器内文件</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="构建docker镜像"><a href="#构建docker镜像" class="headerlink" title="构建docker镜像"></a>构建docker镜像</h2><ol><li>编写<code>Dockerfile</code> 文件，其对应的语法可以参考官方文档：<a href="https://docs.docker.com/engine/reference/builder/">官方文档</a></li><li>构建镜像</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 进入镜像目录</span></span><br><span class="line"><span class="built_in">cd</span> /root/demo</span><br><span class="line"><span class="comment"># 开始构建</span></span><br><span class="line">docker build -t [镜像名称]:[TAG(不写默认为latest)] [Dockerfile所在目录]</span><br></pre></td></tr></table></figure><h2 id="Docker自定义网络"><a href="#Docker自定义网络" class="headerlink" title="Docker自定义网络"></a>Docker自定义网络</h2><p>自定义网络，在同一个网络中的容器可以互联</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 1.首先通过命令创建一个网络</span></span><br><span class="line">docker network create hmall</span><br><span class="line"></span><br><span class="line"><span class="comment"># 2.然后查看网络</span></span><br><span class="line">docker network <span class="built_in">ls</span></span><br><span class="line"><span class="comment"># 结果：</span></span><br><span class="line">NETWORK ID     NAME      DRIVER    SCOPE</span><br><span class="line">639bc44d0a87   bridge    bridge    <span class="built_in">local</span></span><br><span class="line">403f16ec62a2   hmall     bridge    <span class="built_in">local</span></span><br><span class="line">0dc0f72a0fbb   host      host      <span class="built_in">local</span></span><br><span class="line">cd8d3e8df47b   none      null      <span class="built_in">local</span></span><br><span class="line"><span class="comment"># 其中，除了hmall以外，其它都是默认的网络</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 3.让dd和mysql都加入该网络，注意，在加入网络时可以通过--alias给容器起别名</span></span><br><span class="line"><span class="comment"># 这样该网络内的其它容器可以用别名互相访问！</span></span><br><span class="line"><span class="comment"># 3.1.mysql容器，指定别名为db，另外每一个容器都有一个别名是容器名</span></span><br><span class="line">docker network connect hmall mysql --<span class="built_in">alias</span> db</span><br><span class="line"><span class="comment"># 3.2.db容器，也就是我们的java项目</span></span><br><span class="line">docker network connect hmall <span class="built_in">dd</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 4.进入dd容器，尝试利用别名访问db</span></span><br><span class="line"><span class="comment"># 4.1.进入容器</span></span><br><span class="line">docker <span class="built_in">exec</span> -it <span class="built_in">dd</span> bash</span><br><span class="line"><span class="comment"># 4.2.用db别名访问</span></span><br><span class="line">ping db</span><br><span class="line"><span class="comment"># 结果</span></span><br><span class="line">PING db (172.18.0.2) 56(84) bytes of data.</span><br><span class="line">64 bytes from mysql.hmall (172.18.0.2): icmp_seq=1 ttl=64 time=0.070 ms</span><br><span class="line">64 bytes from mysql.hmall (172.18.0.2): icmp_seq=2 ttl=64 time=0.056 ms</span><br><span class="line"><span class="comment"># 4.3.用容器名访问</span></span><br><span class="line">ping mysql</span><br><span class="line"><span class="comment"># 结果：</span></span><br><span class="line">PING mysql (172.18.0.2) 56(84) bytes of data.</span><br><span class="line">64 bytes from mysql.hmall (172.18.0.2): icmp_seq=1 ttl=64 time=0.044 ms</span><br><span class="line">64 bytes from mysql.hmall (172.18.0.2): icmp_seq=2 ttl=64 time=0.054 ms</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Java新特性</title>
      <link href="/undefined/9ac696fa.html"/>
      <url>/undefined/9ac696fa.html</url>
      
        <content type="html"><![CDATA[<h2 id="函数式接口-functional-interface"><a href="#函数式接口-functional-interface" class="headerlink" title="函数式接口(functional interface)"></a>函数式接口(functional interface)</h2><p>定义：也称 SAM 接口，即 Single Abstract Method interfaces，有且只有一个抽象方法，但可以有多个非抽象方法的接口。</p><p>在 java 8 中专门有一个包放函数式接口java.util.function，该包下的所有接口都有 @FunctionalInterface 注解，提供函数式编程。在其他包中也有函数式接口，其中一些没有@FunctionalInterface 注解，但是只要符合函数式接口的定义就是函数式接口，与是否有@FunctionalInterface注解无关，注解只是在编译时起到强制规范定义的作用。其在 Lambda 表达式中有广泛的应用。</p><p>基本上，函数式编程是一种编程风格，它将计算看作为是数学函数的求值。</p><p>在数学中，函数是将输入集与输出集相关联的表达式。函数的输出仅取决于其输入。我们也可以将两个或多个函数组合在一起得到一个新函数</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Linux系统疑难杂症</title>
      <link href="/undefined/c66bafdb.html"/>
      <url>/undefined/c66bafdb.html</url>
      
        <content type="html"><![CDATA[<h2 id="ideaVim中英文输入法切换问题"><a href="#ideaVim中英文输入法切换问题" class="headerlink" title="ideaVim中英文输入法切换问题"></a>ideaVim中英文输入法切换问题</h2><ol><li>安装ideaVimExtension 插件</li><li>.ideavimrc中开启</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">set keep-english-in-normal</span><br><span class="line">set keep-english-in-normal-and-restore-in-insert</span><br></pre></td></tr></table></figure><h2 id="idea中输入法不跟随鼠标的问题"><a href="#idea中输入法不跟随鼠标的问题" class="headerlink" title="idea中输入法不跟随鼠标的问题"></a>idea中输入法不跟随鼠标的问题</h2><h3 id="问题原因"><a href="#问题原因" class="headerlink" title="问题原因"></a>问题原因</h3><p>具体问题官方其实七年前就有了（参考 <a href="https://youtrack.jetbrains.com/issue/JBR-2460%EF%BC%89%EF%BC%8C%E4%BD%86%E6%98%AF%E6%AF%94%E8%BE%83%E5%9D%91%E7%9A%84%E6%98%AF%E5%AE%98%E6%96%B9%E4%B9%9F%E4%B8%80%E7%9B%B4%E6%B2%A1%E6%9C%89%E8%A7%A3%E5%86%B3%E8%BF%99%E4%B8%AA%E9%97%AE%E9%A2%98%F0%9F%90%B6%EF%BC%88%E6%AD%A4%E5%A4%84%E5%BF%8D%E4%B8%8D%E4%BD%8F%E5%90%90%E6%A7%BD%E4%B8%80%E4%B8%8B%E5%93%88%EF%BC%89%E3%80%82%E7%AE%80%E5%8D%95%E6%9D%A5%E8%AF%B4%E5%B0%B1%E6%98%AF">https://youtrack.jetbrains.com/issue/JBR-2460），但是比较坑的是官方也一直没有解决这个问题🐶（此处忍不住吐槽一下哈）。简单来说就是</a> Idea 的 jre 运行环境一个 bug，导致输入法无法定位到鼠标位置。因此，我们要解决该问题必须要修改 JetBrainsRuntime 的运行代码。</p><h3 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h3><ul><li>下载已经修改好的 JRE 环境<br><a href="https://www.jianguoyun.com/p/De33XAgQ89jhCRjDh8EFIAA%EF%BC%9A">下载地址</a></li><li>替换idea目录的JRE</li></ul><h2 id="无法识别移动硬盘和U盘"><a href="#无法识别移动硬盘和U盘" class="headerlink" title="无法识别移动硬盘和U盘"></a>无法识别移动硬盘和U盘</h2><h3 id="问题原因-1"><a href="#问题原因-1" class="headerlink" title="问题原因"></a>问题原因</h3><p>文件系统不兼容</p><h3 id="解决方法-1"><a href="#解决方法-1" class="headerlink" title="解决方法"></a>解决方法</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo pacman -S ntfs-3g</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="steam加速"><a href="#steam加速" class="headerlink" title="steam加速"></a>steam加速</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">yay -S watt-toolkit-bin</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Java常见面试题总结</title>
      <link href="/undefined/ec262441.html"/>
      <url>/undefined/ec262441.html</url>
      
        <content type="html"><![CDATA[<h2 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h2><h3 id="Java基础概念和知识"><a href="#Java基础概念和知识" class="headerlink" title="Java基础概念和知识"></a>Java基础概念和知识</h3><h4 id="Java语言的特点"><a href="#Java语言的特点" class="headerlink" title="Java语言的特点"></a>Java语言的特点</h4><h4 id="Java-SE-Standard-Edition-VS-Java-EE-Enterprise-Edition"><a href="#Java-SE-Standard-Edition-VS-Java-EE-Enterprise-Edition" class="headerlink" title="Java SE(Standard Edition) VS Java EE(Enterprise Edition)"></a>Java SE(Standard Edition) VS Java EE(Enterprise Edition)</h4><p>简单来说，Java SE 是 Java 的基础版本，Java EE 是 Java 的高级版本。Java SE 更适合开发桌面应用程序或简单的服务器应用程序，Java EE 更适合开发复杂的企业级应用程序或 Web 应用程序。</p><h4 id="JVM-vs-JDK-vs-JRE"><a href="#JVM-vs-JDK-vs-JRE" class="headerlink" title="JVM vs JDK vs JRE"></a>JVM vs JDK vs JRE</h4><ul><li><p>JVM(Java Virtual Machine) Java虚拟机是运行java字节码的虚拟机，是Java的核心，提供了Java的跨平台特性。</p></li><li><p>JDK(Java Development Kit) Java开发工具包，是Java的开发工具包，提供了Java的开发环境。它包含了 JRE，同时还包含了编译 Java 源码的编译器 javac 以及一些其他工具比如 javadoc（文档注释工具）、jdb（调试器）、jconsole（基于 JMX 的可视化监控⼯具）、javap（反编译工具）等等。</p></li><li><p>JRE(Java Runtime Environment) Java运行时环境，是Java程序的运行环境，包含了JVM和一些核心类库。</p></li></ul><p>总结：JDK 包含了 JRE 和开发工具，JRE 包含了 JVM 和核心类库。</p><h4 id="字节码是什么？字节码的好处是什么？"><a href="#字节码是什么？字节码的好处是什么？" class="headerlink" title="字节码是什么？字节码的好处是什么？"></a>字节码是什么？字节码的好处是什么？</h4><p>在 Java 中，JVM 可以理解的代码就叫做字节码（即扩展名为 .class 的文件）</p><p>Java 语言通过字节码的方式，在一定程度上解决了传统解释型语言执行效率低的问题，同时又保留了解释型语言可移植的特点。</p><p>而且，由于字节码并不针对一种特定的机器，因此，Java 程序无须重新编译便可在多种不同操作系统的计算机上运行。</p><p>Java程序从源码到运行的过程：.java -&gt; javac编译 -&gt; .class（字节码） -&gt; 解释器&amp;JIT编译器 -&gt; 机器码</p><p>补充：我们需要格外注意的是 .class-&gt;机器码 这一步。在这一步 JVM 类加载器首先加载字节码文件，然后通过解释器逐行解释执行，这种方式的执行速度会相对比较慢。而且，有些方法和代码块是经常需要被调用的(也就是所谓的热点代码)，所以后面引进了 JIT（Just in Time Compilation） 编译器，而 JIT 属于<strong>运行时编译</strong>。当 JIT 编译器完成第一次编译后，其会将字节码对应的机器码保存下来，下次可以直接使用。而我们知道，机器码的运行效率肯定是高于 Java 解释器的。这也解释了我们为什么经常会说 Java 是编译与解释共存的语言 。</p><h4 id="为什么说-Java-语言“编译与解释并存”？"><a href="#为什么说-Java-语言“编译与解释并存”？" class="headerlink" title="为什么说 Java 语言“编译与解释并存”？"></a>为什么说 Java 语言“编译与解释并存”？</h4><p>高级编程语言按照程序的执行方式分为两种:</p><p>编译型：编译型语言 会通过<strong>编译器</strong>将源代码一次性翻译成可被该平台执行的机器码。一般情况下，编译语言的执行速度比较快，开发效率比较低。常见的编译性语言有 C、C++、Go、Rust 等等。</p><p>解释型：解释型语言会通过<strong>解释器</strong>一句一句的将代码解释（interpret）为机器代码后再执行。解释型语言开发效率比较快，执行速度比较慢。常见的解释性语言有 Python、JavaScript、PHP 等等。</p><p>为什么说 Java 语言“编译与解释并存”？</p><p>这是因为 Java 语言既具有编译型语言的特征，也具有解释型语言的特征。因为 Java 程序要经过先编译，后解释两个步骤，由 Java 编写的程序需要先经过编译步骤，生成字节码（.class 文件），这种字节码必须由 Java 解释器来解释执行。</p><h4 id="AOT-有什么优点？为什么不全部使用-AOT-呢？"><a href="#AOT-有什么优点？为什么不全部使用-AOT-呢？" class="headerlink" title="AOT 有什么优点？为什么不全部使用 AOT 呢？"></a>AOT 有什么优点？为什么不全部使用 AOT 呢？</h4><p>JDK 9 引入了一种新的编译模式 AOT(Ahead of Time Compilation) 。和 JIT 不同的是，这种编译模式会在程序<strong>被执行前</strong>就将其编译成机器码，属于静态编译（C、 C++，Rust，Go 等语言就是静态编译）。</p><p>然而，AOP编译无法支持 Java 的一些动态特性，如反射、动态代理、动态加载、JNI（Java Native Interface）等</p><h4 id="Java-和-C-的区别"><a href="#Java-和-C-的区别" class="headerlink" title="Java 和 C++ 的区别?"></a>Java 和 C++ 的区别?</h4><p>Java 和 C++ 都是面向对象的语言，都支持封装、继承和多态，但是，它们还是有挺多不相同的地方：</p><ul><li>Java 不提供指针来直接访问内存，程序内存更加安全</li><li>Java 的类是单继承的，C++ 支持多重继承；虽然 Java 的类不可以多继承，但是接口可以多继承。</li><li>Java 有自动内存管理垃圾回收机制(GC)，不需要程序员手动释放无用内存。</li><li>C++同时支持方法重载和操作符重载，但是 Java 只支持方法重载（操作符重载增加了复杂性，这与 Java 最初的设计思想不符）。</li></ul><h3 id="Java基本语法"><a href="#Java基本语法" class="headerlink" title="Java基本语法"></a>Java基本语法</h3><h4 id="标识符和关键字的区别是什么？"><a href="#标识符和关键字的区别是什么？" class="headerlink" title="标识符和关键字的区别是什么？"></a>标识符和关键字的区别是什么？</h4><p>在我们编写程序的时候，需要大量地为程序、类、变量、方法等取名字，于是就有了标识符 。简单来说，标识符就是程序员在开发的时候自己起的一个名字 。</p><p>有一些标识符，Java 语言已经赋予了其特殊的含义，只能用于特定的地方，这些特殊的标识符就是 关键字 。简单来说，关键字是被Java语言赋予特殊含义的标识符 。</p><h4 id="自增资减运算符"><a href="#自增资减运算符" class="headerlink" title="自增资减运算符"></a>自增资减运算符</h4><p>移位运算符是最基本的运算符之一，几乎每种编程语言都包含这一运算符。<strong>移位操作中，被操作的数据被视为二进制数，移位就是将其向左或向右移动若干位的运算</strong>。</p><p>在 Java 代码里使用 &lt;&lt;、 &gt;&gt; 和&gt;&gt;&gt;转换成的指令码运行起来会更高效些。</p><p>Java 中有三种移位运算符：</p><ul><li>&lt;&lt; :左移运算符，向左移若干位，高位丢弃，低位补零。x &lt;&lt; 1,相当于 x 乘以 2(不溢出的情况下)。</li><li><blockquote><blockquote><p>:带符号右移，向右移若干位，高位补符号位，低位丢弃。正数高位补 0,负数高位补 1。x &gt;&gt; 1,相当于 x 除以 2。</p></blockquote></blockquote></li><li><blockquote><blockquote><blockquote><p>:无符号右移，忽略符号位，空位都以 0 补齐。</p></blockquote></blockquote></blockquote></li></ul><p>注意：由于 double，float 在二进制中的表现比较特殊，因此不能来进行移位操作。</p><h5 id="如果移位的位数超过数值所占有的位数会怎样？"><a href="#如果移位的位数超过数值所占有的位数会怎样？" class="headerlink" title="如果移位的位数超过数值所占有的位数会怎样？"></a>如果移位的位数超过数值所占有的位数会怎样？</h5><p>当 int 类型左移&#x2F;右移位数大于等于 32 位操作时，会先求余（%）后再进行左移&#x2F;右移操作。也就是说左移&#x2F;右移 32 位相当于不进行移位操作（32%32&#x3D;0）。左移&#x2F;右移 42 位相当于左移&#x2F;右移 10 位（42%32&#x3D;10）。当 long 类型进行左移&#x2F;右移操作时，由于 long 对应的二进制是 64 位，因此求余操作的基数也变成了 64。</p><h4 id="continue、break-和-return-的区别是什么？"><a href="#continue、break-和-return-的区别是什么？" class="headerlink" title="continue、break 和 return 的区别是什么？"></a>continue、break 和 return 的区别是什么？</h4><p>需要在循环的过程中，当发生了某种条件之后 ，提前终止循环，这就需要用到下面几个关键词：</p><ul><li>continue：指跳出当前的这一次循环，继续下一次循环。</li><li>break：指跳出整个循环体，继续执行循环下面的语句。</li></ul><p>return 用于跳出所在方法，结束该方法的运行。<br>return 一般有两种用法：</p><ol><li>return;：直接使用 return 结束方法执行，用于没有返回值函数的方法</li><li>return value;：return 一个特定值，用于有返回值函数的方法</li></ol><h3 id="基本数据类型"><a href="#基本数据类型" class="headerlink" title="基本数据类型"></a>基本数据类型</h3><p>Java中有8种基本数据类型，分别是：</p><ul><li>6种数字类型：<ul><li>4种整形：byte short int long(位数依次为8 16 32 64)</li><li>2种浮点型：float double(位数依次为32 64)</li></ul></li><li>1种字符型：char</li><li>1种布尔型：boolean</li></ul><p>二进制补码表示法中，最高位是用来表示符号的（0 表示正数，1 表示负数），其余位表示数值部分。</p><p>注意：</p><ul><li><p>Java 里使用 long 类型的数据一定要在数值后面加上 L，否则将作为整型解析。</p></li><li><p>char a &#x3D; ‘h’char :单引号，String a &#x3D; “hello” :双引号。这八种基本类型都有对应的包装类分别为：Byte、Short、Integer、Long、Float、Double、Character、Boolean 。</p></li></ul><h4 id="基本类型和包装类型的区别？"><a href="#基本类型和包装类型的区别？" class="headerlink" title="基本类型和包装类型的区别？"></a>基本类型和包装类型的区别？</h4><p>基本数据类型是”数”，包装类型是”对象”。</p><ul><li>用途：除了定义一些常量和局部变量之外，我们在其他地方比如方法参数、对象属性中很少会使用基本类型来定义变量。并且，包装类型可用于泛型，而基本类型不可以。</li><li>存储方式：基本数据类型的局部变量存放在 Java 虚拟机栈中的局部变量表中，基本数据类型的成员变量（未被 static 修饰 ）存放在 Java 虚拟机的堆中。包装类型属于对象类型，我们知道几乎所有对象实例都存在于堆中。</li><li>占用空间：相比于包装类型（对象类型）， 基本数据类型占用的空间往往非常小。默认值：成员变量包装类型不赋值就是 null ，而基本类型有默认值且不是 null。</li><li>比较方式：对于基本数据类型来说，&#x3D;&#x3D; 比较的是值。对于包装数据类型来说，&#x3D;&#x3D; 比较的是对象的内存地址。<br>所有整型包装类对象之间值的比较，全部使用 equals() 方法。\</li></ul><p>⚠️ 注意：基本数据类型存放在栈中是一个常见的误区！ 基本数据类型的存储位置取决于它们的作用域和声明方式。如果它们是局部变量，那么它们会存放在栈中；如果它们是成员变量，那么它们会存放在堆中。</p><h4 id="自动装箱和拆箱"><a href="#自动装箱和拆箱" class="headerlink" title="自动装箱和拆箱"></a>自动装箱和拆箱</h4><p>什么是自动拆装箱？</p><ul><li>装箱：将基本数据类型转换为包装类型。</li><li>拆箱：将包装类型转换为基本数据类型。</li></ul><p>注意：如果频繁拆装箱的话，也会严重影响系统的性能。我们应该尽量避免不必要的拆装箱操作。</p><h4 id="为什么浮点数运算的时候会有精度丢失的风险？"><a href="#为什么浮点数运算的时候会有精度丢失的风险？" class="headerlink" title="为什么浮点数运算的时候会有精度丢失的风险？"></a>为什么浮点数运算的时候会有精度丢失的风险？</h4><p>计算机是二进制的，在标识一个数字的时候宽度是有限的，所以浮点数的精度是有限的，在表示无限不循环小数到时候，只能被截断。这也就是解释了为什么浮点数没有办法用二进制精确表示。</p><h4 id="如何解决浮点数运算的精度丢失问题？"><a href="#如何解决浮点数运算的精度丢失问题？" class="headerlink" title="如何解决浮点数运算的精度丢失问题？"></a>如何解决浮点数运算的精度丢失问题？</h4><p>BigDecimal 可以实现对浮点数的运算，不会造成精度丢失。通常情况下，大部分需要浮点数精确运算结果的业务场景（比如涉及到钱的场景）都是通过 BigDecimal 来做的。</p><h4 id="超过-long-整型的数据应该如何表示？"><a href="#超过-long-整型的数据应该如何表示？" class="headerlink" title="超过 long 整型的数据应该如何表示？"></a>超过 long 整型的数据应该如何表示？</h4><p>BigInteger 内部使用 int[] 数组来存储任意大小的整形数据。</p><p>相对于常规整数类型的运算来说，BigInteger 运算的效率会相对较低。</p><h3 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h3><h4 id="局部变量和成员变量的区别？"><a href="#局部变量和成员变量的区别？" class="headerlink" title="局部变量和成员变量的区别？"></a>局部变量和成员变量的区别？</h4><ul><li>语法形式：从语法形式上看，成员变量是属于类的，而局部变量是在代码块或方法中定义的变量或是方法的参数；成员变量可以被 public,private,static 等修饰符所修饰，而局部变量不能被访问控制修饰符及 static 所修饰；但是，成员变量和局部变量都能被 final 所修饰。</li><li>存储方式：从变量在内存中的存储方式来看，如果成员变量是使用 static 修饰的，那么这个成员变量是属于类的，如果没有使用 static 修饰，这个成员变量是属于实例的。而对象存在于堆内存，局部变量则存在于栈内存。</li><li>生存时间：从变量在内存中的生存时间上看，成员变量是<strong>对象</strong>的一部分，它随着对象的创建而存在，而局部变量随着<strong>方法</strong>的调用而自动生成，随着方法的调用结束而消亡。</li><li>默认值：从变量是否有默认值来看，成员变量如果没有被赋初始值，则会自动以类型的默认值而赋值（一种情况例外:被 final 修饰的成员变量也必须显式地赋值），而局部变量则不会自动赋值。</li></ul><h4 id="静态变量有什么作用？"><a href="#静态变量有什么作用？" class="headerlink" title="静态变量有什么作用？"></a>静态变量有什么作用？</h4><p>静态变量也就是被 static 关键字修饰的变量。它可以被类的所有实例共享，无论一个类创建了多少个对象，它们都共享同一份静态变量。也就是说，静态变量只会被分配一次内存，即使创建多个对象，这样可以节省内存。</p><h4 id="字符型常量和字符串常量的区别"><a href="#字符型常量和字符串常量的区别" class="headerlink" title="字符型常量和字符串常量的区别?"></a>字符型常量和字符串常量的区别?</h4><ul><li>形式 : 字符常量是<strong>单引号</strong>引起的一个字符，字符串常量是<strong>双引号</strong>引起的 0 个或若干个字符。</li><li>⭐️含义 : 字符常量相当于一个<strong>整型值</strong>( ASCII 值),可以参加表达式运算; 字符串常量代表一个<strong>地址值</strong>(该字符串在内存中存放位置)。占内存大小：字符常量只占 2 个字节; 字符串常量占若干个字节。</li></ul><h3 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h3><h4 id="静态方法为什么不能调用非静态成员"><a href="#静态方法为什么不能调用非静态成员" class="headerlink" title="静态方法为什么不能调用非静态成员"></a>静态方法为什么不能调用非静态成员</h4><p>这个需要结合 JVM 的相关知识，主要原因如下：</p><ol><li>静态方法是属于类的，在类加载的时候就会分配内存，可以通过类名直接访问。而非静态成员属于实例对象，只有在对象实例化之后才存在，需要通过类的实例对象去访问。</li><li>在类的非静态成员不存在的时候静态方法就已经存在了，此时调用在内存中还不存在的非静态成员，属于非法操作。</li></ol><p>简言之，静态方法先类加载时就有了，而非静态成员得创建对象实例之后才有，所以静态方法不能直接调用非静态成员。</p><h4 id="静态方法和实例方法的区别？"><a href="#静态方法和实例方法的区别？" class="headerlink" title="静态方法和实例方法的区别？"></a>静态方法和实例方法的区别？</h4><ol><li><p>调用方式<br>在外部调用静态方法时，可以使用 类名.方法名 的方式，也可以使用 对象.方法名 的方式(但一般使用前者，因为静态方法是属于类的)，而实例方法只有后面这种方式。也就是说，调用静态方法可以无需创建对象 。</p></li><li><p>访问类成员限制<br>静态方法在访问本类的成员时，只允许访问静态成员（即静态成员变量和静态方法），不允许访问实例成员（即实例成员变量和实例方法），而实例方法不存在这个限制。</p></li></ol><h4 id="方法的重载和重写有什么区别？"><a href="#方法的重载和重写有什么区别？" class="headerlink" title="方法的重载和重写有什么区别？"></a>方法的重载和重写有什么区别？</h4><ul><li><p>重载就是同样的一个方法能够根据输入数据的不同，做出不同的处理.(同一个方法名，但是有不同输入数据类型)重载就是同一个类中多个同名方法根据不同的传参来执行不同的逻辑处理。</p></li><li><p>重写就是当子类继承自父类的相同方法，输入数据一样，但要做出有别于父类的响应时，你就要覆盖父类方法(重写发生在运行期，是子类对父类的<strong>允许访问的方法</strong>的实现过程进行重新编写。)重写就是子类对父类方法的重新改造，外部样子不能改变，内部逻辑可以改变。</p></li></ul><h4 id="什么是可变长参数"><a href="#什么是可变长参数" class="headerlink" title="什么是可变长参数"></a>什么是可变长参数</h4><p>所谓可变长参数就是允许在调用方法时传入不定长度的参数。就比如下面这个方法就可以接受 0 个或者多个参数。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">method1</span><span class="params">(String... args)</span> &#123;</span><br><span class="line">   <span class="comment">//......</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当存在重载方法时，可变长参数的方法会被当做最后的选择。</p><h3 id="面向对象基础"><a href="#面向对象基础" class="headerlink" title="面向对象基础"></a>面向对象基础</h3><h4 id="面向对象和面向过程的区别"><a href="#面向对象和面向过程的区别" class="headerlink" title="面向对象和面向过程的区别"></a>面向对象和面向过程的区别</h4><ul><li>一步步</li><li>对象执行方法</li></ul><h4 id="对象实体与对象引用有何不同"><a href="#对象实体与对象引用有何不同" class="headerlink" title="对象实体与对象引用有何不同?"></a>对象实体与对象引用有何不同?</h4><p>new 创建对象实例（对象实例在堆内存中），对象引用指向对象实例（对象引用存放在栈内存中）。</p><ul><li>一个对象引用可以指向 0 个或 1 个对象（一根绳子可以不系气球，也可以系一个气球）；</li><li>一个对象可以有 n 个引用指向它（可以用 n 条绳子系住一个气球）。</li></ul><h4 id="如果一个类没有声明构造方法，该程序能正确执行吗"><a href="#如果一个类没有声明构造方法，该程序能正确执行吗" class="headerlink" title="如果一个类没有声明构造方法，该程序能正确执行吗?"></a>如果一个类没有声明构造方法，该程序能正确执行吗?</h4><p>可以执行！因为一个类即使没有声明构造方法也会有默认的不带参数的构造方法。如果我们自己添加了类的构造方法（无论是否有参），Java 就不会添加默认的无参数的构造方法了。</p><h4 id="构造方法是否可被-override"><a href="#构造方法是否可被-override" class="headerlink" title="构造方法是否可被 override?"></a>构造方法是否可被 override?</h4><p>构造方法不能被 override（重写）,但是可以 overload（重载）,所以你可以看到一个类中有多个构造函数的情况。</p><h4 id="面向对象的三大特征"><a href="#面向对象的三大特征" class="headerlink" title="面向对象的三大特征"></a>面向对象的三大特征</h4><ul><li>封装</li></ul><p>封装是指把一个对象的状态信息（也就是属性）隐藏在对象内部，不允许外部对象直接访问对象的内部信息</p><ul><li>继承</li></ul><p>关于继承如下 3 点请记住：</p><ol><li>子类拥有父类对象所有的属性和方法（包括私有属性和私有方法），但是父类中的私有属性和方法子类是无法访问，只是拥有。</li><li>子类可以拥有自己属性和方法，即子类可以对父类进行扩展。</li><li>子类可以用自己的方式实现父类的方法。</li></ol><ul><li>多态:多态，顾名思义，表示一个对象具有多种的状态，具体表现为父类的引用指向子类的实例。</li></ul><p>多态的特点:</p><ol><li>对象类型和引用类型之间具有继承（类）&#x2F;实现（接口）的关系；</li><li>引用类型变量发出的方法调用的到底是哪个类中的方法，必须在程序运行期间才能确定；</li><li>多态不能调用“只在子类存在但在父类不存在”的方法；</li><li>如果子类重写了父类的方法，真正执行的是子类重写的方法，如果子类没有重写父类的方法，执行的是父类的方法。(就近)</li></ol><h4 id="接口和抽象类有什么共同点和区别？"><a href="#接口和抽象类有什么共同点和区别？" class="headerlink" title="接口和抽象类有什么共同点和区别？"></a>接口和抽象类有什么共同点和区别？</h4><p>共同点：</p><ul><li>都不能被实例化。</li><li>能可包含抽象方法</li><li>都可以有默认实现方法</li></ul><p>不同点:</p><ul><li>接口主要用于对类的行为进行约束，你实现了某个接口就具有了对应的行为。(接口是一种规范);抽象类主要用于代码复用，强调的是所属关系。</li><li>一个类只能继承一个类，但是可以实现多个接口</li><li>接口中的成员变量只能是 public static final 类型的，不能被修改且必须有初始值，而抽象类的成员变量默认 default，可在子类中被重新定义，也可被重新赋值。</li></ul><h4 id="深拷贝和浅拷贝区别了解吗？什么是引用拷贝？"><a href="#深拷贝和浅拷贝区别了解吗？什么是引用拷贝？" class="headerlink" title="深拷贝和浅拷贝区别了解吗？什么是引用拷贝？"></a>深拷贝和浅拷贝区别了解吗？什么是引用拷贝？</h4><ul><li>浅拷贝：浅拷贝会在堆上创建一个新的对象（区别于引用拷贝的一点）;<br>不过，如果原对象内部的属性是引用类型的话，浅拷贝会直接复制内部对象的引用地址，也就是说拷贝对象和原对象<strong>共用同一个内部对象</strong>。<br>总结：会在堆上创建一个新对象，但是对象内部的引用类型的对象不拷贝对象本身，而是只拷贝地址引用。</li><li>深拷贝：深拷贝会<strong>完全复制整个对象</strong>，包括这个对象所包含的内部对象。</li></ul><h3 id="Object"><a href="#Object" class="headerlink" title="Object"></a>Object</h3><p>Object类是一个特殊的类，是所有类的父类</p><h4 id="和-equals-的区别是什么？"><a href="#和-equals-的区别是什么？" class="headerlink" title="&#x3D;&#x3D; 和 equals() 的区别是什么？"></a>&#x3D;&#x3D; 和 equals() 的区别是什么？</h4><p>&#x3D;&#x3D; 对于基本类型和引用类型的作用效果是不同的(本质比较的是值)：</p><ul><li>对于基本数据类型来说，&#x3D;&#x3D; 比较的是值。</li><li>对于引用数据类型来说，&#x3D;&#x3D; 比较的是对象的内存地址。</li></ul><p>因为 Java 只有值传递，所以，对于 &#x3D;&#x3D; 来说，不管是比较基本数据类型，还是引用数据类型的变量，其本质比较的都是值，只是引用类型变量存的值是对象的地址。</p><p>equals() 不能用于判断基本数据类型的变量，只能用来判断两个<strong>对象</strong>是否相等。</p><p>equals() 方法存在两种使用情况：</p><ul><li>类没有重写 equals()方法：通过equals()比较该类的两个对象时，等价于通过“&#x3D;&#x3D;”比较这两个对象，使用的默认是 Object类equals()方法。</li><li>类重写了 equals()方法：一般我们都重写 equals()方法来比较两个对象中的属性是否相等；若它们的属性相等，则返回 true(即，认为这两个对象相等)。</li></ul><h4 id="hashCode-有什么用？"><a href="#hashCode-有什么用？" class="headerlink" title="hashCode() 有什么用？"></a>hashCode() 有什么用？</h4><p>hashCode() 的作用是获取哈希码（int 整数），也称为散列码。这个哈希码的作用是确定该对象在哈希表中的索引位置。散列表存储的是键值对(key-value)，它的特点是：能根据“键”快速的检索出对应的“值”。这其中就利用到了散列码！（可以快速找到所需要的对象）</p><h4 id="为什么要有-hashCode？"><a href="#为什么要有-hashCode？" class="headerlink" title="为什么要有 hashCode？"></a>为什么要有 hashCode？</h4><p>当你把对象加入 HashSet 时，HashSet 会先计算对象的 hashCode 值来判断对象加入的位置，同时也会与其他已经加入的对象的 hashCode 值作比较，如果没有相符的 hashCode，HashSet 会假设对象没有重复出现。<br>但是如果发现有相同 hashCode 值的对象，这时会调用 equals() 方法来检查 hashCode 相等的对象是否真的相同。<br>如果两者相同，HashSet 就不会让其加入操作成功。如果不同的话，就会重新散列到其他位置。这样我们就大大减少了 equals 的次数，相应就大大提高了执行速度。</p><p>本质山， hashCode() 和 equals()都是用于比较两个对象是否相等。</p><h5 id="那为什么-JDK-还要同时提供这两个方法呢？"><a href="#那为什么-JDK-还要同时提供这两个方法呢？" class="headerlink" title="那为什么 JDK 还要同时提供这两个方法呢？"></a>那为什么 JDK 还要同时提供这两个方法呢？</h5><p>hashCode 在一些容器中(如HashSet HashyMap)中的判断元素是否在对应容器中的效率更高</p><h5 id="那为什么不只提供-hashCode-方法呢？"><a href="#那为什么不只提供-hashCode-方法呢？" class="headerlink" title="那为什么不只提供 hashCode() 方法呢？"></a>那为什么不只提供 hashCode() 方法呢？</h5><p>两个对象的hashCode值相等不代表两个对象就一定相等</p><h5 id="那为什么两个对象有相同的-hashCode-值，它们也不一定是相等的？"><a href="#那为什么两个对象有相同的-hashCode-值，它们也不一定是相等的？" class="headerlink" title="那为什么两个对象有相同的 hashCode 值，它们也不一定是相等的？"></a>那为什么两个对象有相同的 hashCode 值，它们也不一定是相等的？</h5><p>因为 hashCode() 所使用的哈希算法也许刚好会让多个对象传回相同的哈希值。越糟糕的哈希算法越容易碰撞，但这也与数据值域分布的特性有关（所谓哈希碰撞也就是指的是不同的对象得到相同的 hashCode )。</p><p>总结下来就是:</p><ul><li>如果两个对象的hashCode 值相等，那这两个对象不一定相等（哈希碰撞）。</li><li>如果两个对象的hashCode 值相等并且equals()方法也返回 true，我们才认为这两个对象相等。如果两个对象的hashCode 值不相等，我们就可以直接认为这两个对象不相等。<br>(hashCode相等是两个对象相等的必要不充分条件)</li></ul><h4 id="为什么重写-equals-时必须重写-hashCode-方法？"><a href="#为什么重写-equals-时必须重写-hashCode-方法？" class="headerlink" title="为什么重写 equals() 时必须重写 hashCode() 方法？"></a>为什么重写 equals() 时必须重写 hashCode() 方法？</h4><p>为什么重写 equals() 时必须重写 hashCode() 方法？因为两个相等的对象的 hashCode 值必须是相等。也就是说如果 equals 方法判断两个对象是相等的，那这两个对象的 hashCode 值也要相等。如果重写 equals() 时没有重写 hashCode() 方法的话就可能会导致 equals 方法判断是相等的两个对象，hashCode 值却不相等。</p><h3 id="String"><a href="#String" class="headerlink" title="String"></a>String</h3><h4 id="String、StringBuffer、StringBuilder-的区别？"><a href="#String、StringBuffer、StringBuilder-的区别？" class="headerlink" title="String、StringBuffer、StringBuilder 的区别？"></a>String、StringBuffer、StringBuilder 的区别？</h4><ul><li><p>可变性:<br>String是不可变的。而StringBuilder 与 StringBuffer 都继承自 AbstractStringBuilder 类，在 AbstractStringBuilder 中也是使用字符数组保存字符串，不过没有使用 final 和 private 关键字修饰，最关键的是这个 AbstractStringBuilder 类还提供了很多修改字符串的方法比如 append 方法。</p></li><li><p>线程安全性:<br>String 中的对象是不可变的，也就可以理解为常量，线程安全。<br>AbstractStringBuilder 是 StringBuilder 与 StringBuffer 的公共父类，定义了一些字符串的基本操作，如 expandCapacity、append、insert、indexOf 等公共方法。<br>StringBuffer 对方法加了同步锁或者对调用的方法加了同步锁，所以是线程安全的。<br>StringBuilder 并没有对方法进行加同步锁，所以是非线程安全的。</p></li><li><p>性能:<br>每次对 String 类型进行改变的时候，都会生成一个新的 String 对象，然后将指针指向新的 String 对象。<br>StringBuffer 每次都会对 StringBuffer 对象本身进行操作，而不是生成新的对象并改变对象引用。<br>相同情况下使用 StringBuilder 相比使用 StringBuffer 仅能获得 10%~15% 左右的性能提升，但却要冒多线程不安全的风险。</p></li><li><p>对于三者的使用</p></li><li><p>操作少量的数据: 适用 String</p></li><li><p>单线程操作字符串缓冲区下操作大量数据: 适用 StringBuilder</p></li><li><p>多线程操作字符串缓冲区下操作大量数据: 适用 StringBuffer</p></li></ul><h4 id="String为什么是不可变的"><a href="#String为什么是不可变的" class="headerlink" title="String为什么是不可变的"></a>String为什么是不可变的</h4><p>String 类中使用 final 关键字修饰字符数组</p><h4 id="String-equals-和-Object-equals-有何区别？"><a href="#String-equals-和-Object-equals-有何区别？" class="headerlink" title="String#equals() 和 Object#equals() 有何区别？"></a>String#equals() 和 Object#equals() 有何区别？</h4><p>String 中的 equals 方法是被重写过的，比较的是 String 字符串的值是否相等。 Object 的 equals 方法是比较的对象的内存地址。</p><h4 id="字符串常量池的作用"><a href="#字符串常量池的作用" class="headerlink" title="字符串常量池的作用"></a>字符串常量池的作用</h4><p>字符串常量池 是 JVM 为了提升性能和减少内存消耗针对字符串（String 类）专门开辟的一块区域，主要目的是为了避免字符串的重复创建。</p><h4 id="String-s1-new-String-“abc”-这句话创建了几个字符串对象？"><a href="#String-s1-new-String-“abc”-这句话创建了几个字符串对象？" class="headerlink" title="String s1 &#x3D; new String(“abc”);这句话创建了几个字符串对象？"></a>String s1 &#x3D; new String(“abc”);这句话创建了几个字符串对象？</h4><p>这句话包含了两个对象 字符串常量对象”abc”和字符串对象s1</p><p>字符串对象s1一定会创建在堆里(看见了new则一定会在堆中创建对象)</p><p>如果 字符串常量池中 不存在字符串对象“abc”的引用，那么它会在堆上创建两个字符串对象，其中一个字符串对象的引用会被保存在字符串常量池中。<br>如果字符串常量池中已存在字符串对象“abc”的引用，则只会在堆中创建 1 个字符串对象“abc”。</p><h4 id="String-intern-方法有什么作用"><a href="#String-intern-方法有什么作用" class="headerlink" title="String#intern 方法有什么作用?"></a>String#intern 方法有什么作用?</h4><p>String.intern() 是一个 native（本地）方法，其作用是将指定的字符串对象的引用保存在字符串常量池中，可以简单分为两种情况：</p><ul><li>如果字符串常量池中保存了对应的字符串对象的引用，就直接返回该引用。</li><li>如果字符串常量池中没有保存了对应的字符串对象的引用，那就在常量池中创建一个指向该字符串对象的引用并返</li></ul><h3 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h3><h4 id="Java中exception和error有什么区别"><a href="#Java中exception和error有什么区别" class="headerlink" title="Java中exception和error有什么区别"></a>Java中exception和error有什么区别</h4><p>在 Java 中，所有的异常都有一个共同的祖先 java.lang 包中的 Throwable 类。Throwable 类有两个重要的子类:</p><ul><li>Exception :程序本身可以处理的异常，可以通过 catch 来进行捕获。Exception 又可以分为 Checked Exception (受检查异常，必须处理) 和 Unchecked Exception (不受检查异常，可以不处理)。</li><li>Error：Error 属于程序无法处理的错误 ，我们没办法通过 catch 来进行捕获不建议通过catch捕获 。例如 Java 虚拟机运行错误（Virtual MachineError）、虚拟机内存不够错误(OutOfMemoryError)、类定义错误（NoClassDefFoundError）等 。这些异常发生时，Java 虚拟机（JVM）一般会选择线程终止。</li></ul><h4 id="受检异常-checked-exception-和未受检异常-Unchecked-exception-有什么区别"><a href="#受检异常-checked-exception-和未受检异常-Unchecked-exception-有什么区别" class="headerlink" title="受检异常(checked exception)和未受检异常(Unchecked exception)有什么区别"></a>受检异常(checked exception)和未受检异常(Unchecked exception)有什么区别</h4><ul><li>Checked Exception 即受检查异常 ，Java 代码在编译过程中，如果受检查异常没有被 catch或者throws 关键字处理的话，就没办法通过编译。<br>除了RuntimeException及其子类以外，其他的Exception类及其子类都属于受检查异常 。常见的受检查异常有：IO 相关的异常、ClassNotFoundException、SQLException…。</li><li>Unchecked Exception 即 不受检查异常 ，Java 代码在编译过程中 ，我们即使不处理不受检查异常也可以正常通过编译。<br>RuntimeException 及其子类都统称为非受检查异常，常见的有：</li><li>NullPointerException(空指针错误)</li><li>IllegalArgumentException(参数错误比如方法入参类型错误)</li><li>NumberFormatException（字符串转换为数字格式错误，IllegalArgumentException的子类）</li><li>ArrayIndexOutOfBoundsException（数组越界错误）</li><li>ClassCastException（类型转换错误）</li><li>ArithmeticException（算术错误）</li><li>SecurityException （安全错误比如权限不够）</li><li>UnsupportedOperationException(不支持的操作错误比如重复创建同一用户)</li><li>…</li></ul><h4 id="Throwable-类常用方法有哪些？"><a href="#Throwable-类常用方法有哪些？" class="headerlink" title="Throwable 类常用方法有哪些？"></a>Throwable 类常用方法有哪些？</h4><ul><li>String getMessage(): 返回异常发生时的简要描述</li><li>String toString(): 返回异常发生时的详细信息</li><li>String getLocalizedMessage(): 返回异常对象的本地化信息。使用 Throwable 的子类覆盖这个方法，可以生成本地化信息。如果子类没有覆盖该方法，则该方法返回的信息与 getMessage()返回的结果相同</li><li>void printStackTrace(): 在控制台上打印 Throwable 对象封装的异常信息</li></ul><h4 id="try-catch-finally-如何使用？"><a href="#try-catch-finally-如何使用？" class="headerlink" title="try-catch-finally 如何使用？"></a>try-catch-finally 如何使用？</h4><ul><li>try:用于捕获异常。后面可跟一个或多个catch，如果没有catch则必须跟一个finally</li><li>catch:用于处理try捕获的异常</li><li>finally：无论是否捕获或处理异常，finally 块里的语句都会被执行。<br>当在 try 块或 catch 块中遇到 return 语句时，finally 语句块将在方法返回之前被执行。</li></ul><p>⚠️注意：不要在 finally 语句块中使用 return! 当 try 语句和 finally 语句中都有 return 语句时，try 语句块中的 return 语句会被忽略。这是因为 try 语句中的 return 返回值会先被暂存在一个本地变量中，当执行到 finally 语句中的 return 之后，这个本地变量的值就变为了 finally 语句中的 return 返回值。</p><h4 id="finally-中的代码一定会执行吗？"><a href="#finally-中的代码一定会执行吗？" class="headerlink" title="finally 中的代码一定会执行吗？"></a>finally 中的代码一定会执行吗？</h4><p>不一定，finally 之前虚拟机被终止运行的话(例如System.exit(1)，finally 中的代码就不会被执行。</p><p>另外，在以下 2 种特殊情况下，finally 块的代码也不会被执行：</p><ul><li>程序所在的线程死亡。</li><li>关闭 CPU。</li></ul><h4 id="如何使用-try-with-resources-代替try-catch-finally？"><a href="#如何使用-try-with-resources-代替try-catch-finally？" class="headerlink" title="如何使用 try-with-resources 代替try-catch-finally？"></a>如何使用 try-with-resources 代替try-catch-finally？</h4><ul><li>适用范围（资源的定义）： 任何实现 <code>java.lang.AutoCloseable</code>或者 <code>java.io.Closeable</code> 的对象</li><li>finally 块的执行顺序： 在 try-with-resources 语句中，任何 catch 或 finally 块在声明的资源关闭后运行</li></ul><p>简单来说，当有类似于InputStream、OutputStream、Scanner、PrintWriter等的资源都需要我们调用close()方法来手动关闭时，可以用try-with-resources来代码让更简短，更清晰，产生的异常对我们也更有用</p><h4 id="异常使用有哪些需要注意的地方？"><a href="#异常使用有哪些需要注意的地方？" class="headerlink" title="异常使用有哪些需要注意的地方？"></a>异常使用有哪些需要注意的地方？</h4><ul><li>每次手动抛出异常，我们都需要手动 new 一个异常对象抛出。</li><li>抛出的异常信息一定要有意义。</li><li>建议抛出更加具体的异常</li></ul><h3 id="⭐️泛型-Generics"><a href="#⭐️泛型-Generics" class="headerlink" title="⭐️泛型(Generics)"></a>⭐️泛型(Generics)</h3><!-- TODO: 看一下《Java面试指北中的泛型和通配符的面试题 --><h4 id="泛型的使用方式有几种？"><a href="#泛型的使用方式有几种？" class="headerlink" title="泛型的使用方式有几种？"></a>泛型的使用方式有几种？</h4><ul><li>泛型类</li><li>泛型接口</li><li>泛型方法</li></ul><h4 id="项目中哪里遇到了泛型"><a href="#项目中哪里遇到了泛型" class="headerlink" title="项目中哪里遇到了泛型?"></a>项目中哪里遇到了泛型?</h4><!-- TODO: 项目中哪里用到了泛型？--><ul><li><p>自定义接口通用返回结果 <code>CommonResult&lt;T&gt;</code> 通过参数 T 可根据具体的返回类型动态指定结果的数据类型</p></li><li><p>定义 Excel 处理类 <code>ExcelUtil&lt;T&gt;</code> 用于动态指定 Excel 导出的数据类型</p></li><li><p>构建集合工具类（参考 Collections 中的 sort, binarySearch 方法）。</p></li><li><p>……</p></li></ul><h3 id="⭐️反射"><a href="#⭐️反射" class="headerlink" title="⭐️反射"></a>⭐️反射</h3><h4 id="什么是反射？"><a href="#什么是反射？" class="headerlink" title="什么是反射？"></a>什么是反射？</h4><p>反射赋予了我们在运行时分析类以及执行类中方法的能力。<br>通过反射可以获取任意一个类的所有属性和方法，你还可以调用这些方法和属性。</p><h4 id="反射的优缺点？"><a href="#反射的优缺点？" class="headerlink" title="反射的优缺点？"></a>反射的优缺点？</h4><p>优点：</p><ul><li>反射可以让我们的代码更加灵活、为各种框架提供开箱即用的功能提供了便利。</li></ul><p>缺点：</p><ul><li>安全问题，比如可以无视泛型参数的安全检查（泛型参数的安全检查发生在编译时）</li><li>性能也要稍差点</li></ul><h4 id="反射的应用场景？"><a href="#反射的应用场景？" class="headerlink" title="反射的应用场景？"></a>反射的应用场景？</h4><ul><li>框架中大量使用了动态代理，而动态代理的实现也依赖反射。</li><li>注解的实现也用到了反射。</li></ul><h3 id="注解-Annotation"><a href="#注解-Annotation" class="headerlink" title="注解(Annotation)"></a>注解(Annotation)</h3><h4 id="注解是什么"><a href="#注解是什么" class="headerlink" title="注解是什么"></a>注解是什么</h4><p>可以看作是一种特殊的注释，主要用于修饰类、方法或者变量，提供某些信息供程序在编译或者运行时使用。</p><h4 id="注解的解析方法有哪几种？"><a href="#注解的解析方法有哪几种？" class="headerlink" title="注解的解析方法有哪几种？"></a>注解的解析方法有哪几种？</h4><ul><li>编译期直接扫描：编译器在编译 Java 代码的时候扫描对应的注解并处理，比如某个方法使用@Override 注解，编译器在编译的时候就会检测当前的方法是否重写了父类对应的方法。</li><li>运行期通过反射处理：像框架中自带的注解(比如 Spring 框架的 @Value、@Component)都是通过反射来进行处理的。</li></ul><h3 id="⭐️SPI-Service-Provider-Interface"><a href="#⭐️SPI-Service-Provider-Interface" class="headerlink" title="⭐️SPI(Service Provider Interface)"></a>⭐️SPI(Service Provider Interface)</h3><h4 id="什么是SPI"><a href="#什么是SPI" class="headerlink" title="什么是SPI"></a>什么是SPI</h4><p>专门提供给服务提供者或者扩展框架功能的开发者去使用的一个接口。SPI 将服务接口和具体的服务实现分离开来，将服务调用方和服务实现者解耦，能够提升程序的扩展性、可维护性。</p><h4 id="SPI-和-API-有什么区别？"><a href="#SPI-和-API-有什么区别？" class="headerlink" title="SPI 和 API 有什么区别？"></a>SPI 和 API 有什么区别？</h4><p>广义上来说它们都属于接口,API是接口存在于实现方，SPI是接口存在于调用方</p><h4 id="SPI-的优缺点？"><a href="#SPI-的优缺点？" class="headerlink" title="SPI 的优缺点？"></a>SPI 的优缺点？</h4><ul><li>通过 SPI 机制能够大大地提高接口设计的灵活性，<br>但是 SPI 机制也存在一些缺点，比如：</li><li>需要遍历加载所有的实现类，不能做到按需加载，这样效率还是相对较低的。</li><li>当多个 ServiceLoader 同时 load 时，会有并发问题。</li></ul><h3 id="⭐️序列化和反序列化"><a href="#⭐️序列化和反序列化" class="headerlink" title="⭐️序列化和反序列化"></a>⭐️序列化和反序列化</h3><h4 id="什么是序列化-什么是反序列化"><a href="#什么是序列化-什么是反序列化" class="headerlink" title="什么是序列化?什么是反序列化?"></a>什么是序列化?什么是反序列化?</h4><p>简单来说：</p><ul><li>序列化：将数据结构或对象转换成二进制字节流的过程</li><li>反序列化：将在序列化过程中所生成的二进制字节流转换成数据结构或者对象的过程</li></ul><p>序列化的主要目的是通过网络传输对象或者说是将对象存储到文件系统、数据库、内存中。</p><h4 id="如果有些字段不想进行序列化怎么办？"><a href="#如果有些字段不想进行序列化怎么办？" class="headerlink" title="如果有些字段不想进行序列化怎么办？"></a>如果有些字段不想进行序列化怎么办？</h4><p>使用transient关键字<br>transient 关键字的作用是：阻止实例中那些用此关键字修饰的的变量序列化；当对象被反序列化时，被 transient 修饰的变量值不会被持久化和恢复。</p><h4 id="JDK自带的序列化方式"><a href="#JDK自带的序列化方式" class="headerlink" title="JDK自带的序列化方式"></a>JDK自带的序列化方式</h4><p>JDK 自带的序列化，只需实现 java.io.Serializable接口即可。</p><h4 id="为什么不推荐使用-JDK-自带的序列化？"><a href="#为什么不推荐使用-JDK-自带的序列化？" class="headerlink" title="为什么不推荐使用 JDK 自带的序列化？"></a>为什么不推荐使用 JDK 自带的序列化？</h4><ul><li>不支持跨语言调用</li><li>性能差</li><li>存在安全问题:输入的反序列化的数据可被用户控制，那么攻击者即可通过构造恶意输入，让反序列化产生非预期的对象，在此过程中执行构造的任意代码</li></ul><h4 id="常见的序列化协议有哪些？"><a href="#常见的序列化协议有哪些？" class="headerlink" title="常见的序列化协议有哪些？"></a>常见的序列化协议有哪些？</h4><p>比较常用的序列化协议有 Hessian、Kryo、Protobuf、ProtoStuff，这些都是基于二进制的序列化协议。</p><p>像 JSON 和 XML 这种属于文本类序列化方式。虽然可读性比较好，但是性能较差，一般不会选择。</p><h4 id="序列化协议对应于-TCP-IP-4-层模型的哪一层？"><a href="#序列化协议对应于-TCP-IP-4-层模型的哪一层？" class="headerlink" title="序列化协议对应于 TCP&#x2F;IP 4 层模型的哪一层？"></a>序列化协议对应于 TCP&#x2F;IP 4 层模型的哪一层？</h4><p>OSI 七层协议模型中，表示层做的事情主要就是对应用层的用户数据进行处理转换为二进制流。反过来的话，就是将二进制流转换成应用层的用户数据，就对应的是序列化和反序列化么</p><p>又因为OSI 七层协议模型中的应用层、表示层和会话层对应的都是 TCP&#x2F;IP 四层模型中的应用层，所以序列化协议属于 TCP&#x2F;IP 协议<strong>应用层</strong>的一部分。</p><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>Kryo 是专门针对 Java 语言序列化方式并且性能非常好，如果你的应用是专门针对 Java 语言的话可以考虑使用，并且 Dubbo 官网的一篇文章中提到说推荐使用 Kryo 作为生产环境的序列化方式。</p><p>像 Protobuf、 ProtoStuff、hessian 这类都是跨语言的序列化方式，如果有跨语言需求的话可以考虑使用。</p><h3 id="IO"><a href="#IO" class="headerlink" title="IO"></a>IO</h3><h4 id="Java-IO-流了解吗？"><a href="#Java-IO-流了解吗？" class="headerlink" title="Java IO 流了解吗？"></a>Java IO 流了解吗？</h4><p>数据输入到计算机内存的过程即输入，反之输出到外部存储（比如数据库，文件，远程主机）的过程即输出</p><p>数据传输过程类似于水流，因此称为 IO 流</p><p>IO 流在 Java 中分为输入流和输出流，而根据数据的处理方式又分为字节流和字符流。</p><p>Java IO 流的 40 多个类都是从如下 4 个抽象类基类中派生出来的:</p><p>InputStream&#x2F;Reader:前者是字节输入流，后者是字符输入流。<br>OutputStream&#x2F;Writer:前者是字节输出流，后者是字符输出流。</p><h4 id="Java-IO-中的设计模式有哪些？"><a href="#Java-IO-中的设计模式有哪些？" class="headerlink" title="Java IO 中的设计模式有哪些？"></a>Java IO 中的设计模式有哪些？</h4><ul><li>[ ]</li></ul><h4 id="BIO、NIO-和-AIO-的区别？"><a href="#BIO、NIO-和-AIO-的区别？" class="headerlink" title="BIO、NIO 和 AIO 的区别？"></a>BIO、NIO 和 AIO 的区别？</h4><ul><li>[ ]</li></ul><h3 id="⭐️语法糖"><a href="#⭐️语法糖" class="headerlink" title="⭐️语法糖"></a>⭐️语法糖</h3><h4 id="什么是语法糖"><a href="#什么是语法糖" class="headerlink" title="什么是语法糖"></a>什么是语法糖</h4><p>语法糖（Syntactic sugar） 代指的是编程语言为了方便程序员开发程序而设计的一种特殊语法，这种语法对编程语言的功能并没有影响。实现相同的功能，基于语法糖写出来的代码往往更简单简洁且更易阅读。</p><p>不过，JVM 其实并不能识别语法糖，Java 语法糖要想被正确执行，需要先通过编译器进行解糖，也就是在程序编译阶段将其转换成 JVM 认识的基本语法</p><h4 id="Java中常见的语法糖有哪些？"><a href="#Java中常见的语法糖有哪些？" class="headerlink" title="Java中常见的语法糖有哪些？"></a>Java中常见的语法糖有哪些？</h4><h5 id="switch-支持-String-与枚举"><a href="#switch-支持-String-与枚举" class="headerlink" title="switch 支持 String 与枚举"></a>switch 支持 String 与枚举</h5><p>java中的switch本身支持基本类型，switch中其实只能使用整型，任何类型的比较都要转换成整型。比如byte。short，char(ascii 码是整型)以及int。</p><p>Java 7 中switch开始支持String。字符串的 switch 是通过equals()和hashCode()方法来实现的(hashCode()方法返回的是int)</p><h5 id="自动装箱与拆箱"><a href="#自动装箱与拆箱" class="headerlink" title="自动装箱与拆箱"></a>自动装箱与拆箱</h5><p>装箱过程是通过调用包装器的 valueOf 方法实现的，而拆箱过程是通过调用包装器的 xxxValue 方法实现的。</p><h5 id="可变长参数"><a href="#可变长参数" class="headerlink" title="可变长参数"></a>可变长参数</h5><h5 id="枚举类"><a href="#枚举类" class="headerlink" title="枚举类"></a>枚举类</h5><p>枚举类型不能被继承,当我们使用enum来定义一个枚举类型的时候，编译器会自动帮我们创建一个<strong>final类型</strong>的类继承Enum类，</p><h5 id="内部类"><a href="#内部类" class="headerlink" title="内部类"></a>内部类</h5><p>可以把内部类理解为外部类的一个普通成员</p><p>内部类之所以是语法糖，是因为踏仅仅是一个编译时的概念，一旦编译成功，就会生成两个完全不同.class文件。</p><h5 id="条件编译"><a href="#条件编译" class="headerlink" title="条件编译"></a>条件编译</h5><p>让编译器只对满足条件的代码进行编译，将不满足条件的代码舍弃，这就是条件编译。</p><h5 id="断言assert"><a href="#断言assert" class="headerlink" title="断言assert"></a>断言assert</h5><p>在Java中，断言是一种用于在代码中插入检查条件的机制。它允许程序员在代码中插入一些断言语句，用于检查程序的某些假设是否为真。如果断言的条件为假，系统会抛出一个 AssertionError 异常。<br>例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AssertExample</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">        <span class="keyword">assert</span> x == <span class="number">10</span> : <span class="string">&quot;x should be 10&quot;</span>; <span class="comment">// 断言 x 是否等于 10</span></span><br><span class="line">        System.out.println(<span class="string">&quot;Assertion passed.&quot;</span>); <span class="comment">// 如果断言通过，将会打印这条消息</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="⭐️基础重要知识点"><a href="#⭐️基础重要知识点" class="headerlink" title="⭐️基础重要知识点"></a>⭐️基础重要知识点</h3><h4 id="Java中的值传递详解"><a href="#Java中的值传递详解" class="headerlink" title="Java中的值传递详解"></a>Java中的值传递详解</h4><h5 id="形参vs实参"><a href="#形参vs实参" class="headerlink" title="形参vs实参"></a>形参vs实参</h5><p>参数在程序设计语言中可分为：</p><ul><li>实参:Arguments,用于传递给函数或方法的参数，必须要有确定的值</li><li>形参:Parameters,用于定义函数&#x2F;方法，接受实参</li></ul><h5 id="值传递vs引用传递"><a href="#值传递vs引用传递" class="headerlink" title="值传递vs引用传递"></a>值传递vs引用传递</h5><p>程序设计语言将<code>实参</code>传递给方法的方法有两种：</p><ul><li>引用传递：方法接受的是实参所引用的对象在<code>堆</code>中的<strong>地址</strong>，对<code>形参</code>的修改会影响到实参(类似linux中的硬连结)</li><li>值传递：方法接受的是实际参数的<code>拷贝副本</code>(类似linux中的软链接)</li></ul><p>Java中只有值传递</p><h5 id="为什么Java中只有值传递？"><a href="#为什么Java中只有值传递？" class="headerlink" title="为什么Java中只有值传递？"></a>为什么Java中只有值传递？</h5><p>例1:传递基本类型参数</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">num1</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">num2</span> <span class="operator">=</span> <span class="number">20</span>;</span><br><span class="line">    swap(num1, num2);</span><br><span class="line">    System.out.println(<span class="string">&quot;num1 = &quot;</span> + num1);</span><br><span class="line">    System.out.println(<span class="string">&quot;num2 = &quot;</span> + num2);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> a;</span><br><span class="line">    a = b;</span><br><span class="line">    b = temp;</span><br><span class="line">    System.out.println(<span class="string">&quot;a = &quot;</span> + a);</span><br><span class="line">    System.out.println(<span class="string">&quot;b = &quot;</span> + b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">a = 20</span><br><span class="line">b = 10</span><br><span class="line">num1 = 10</span><br><span class="line">num2 = 20</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>可以看到方法的修改并没有生效,因为swap方法中的a和b是num1和num2的副本，并不是本体,由此可知一个方法不能修改一个基本数据类型的参数</li></ul><p>例2:传递引用类型参数</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">int</span>[] arr = &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span> &#125;;</span><br><span class="line">    System.out.println(arr[<span class="number">0</span>]);</span><br><span class="line">    change(arr);</span><br><span class="line">    System.out.println(arr[<span class="number">0</span>]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">change</span><span class="params">(<span class="type">int</span>[] array)</span> &#123;</span><br><span class="line">    <span class="comment">// 将数组的第一个元素变为0</span></span><br><span class="line">    array[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1</span><br><span class="line">0</span><br></pre></td></tr></table></figure><ul><li>对于引用类型的数据,也是传递的值，但是引用类型（如数组对象)保存的是实参的地址。</li></ul><p>例3:传递引用类型参数2</p><h5 id="Conclusion"><a href="#Conclusion" class="headerlink" title="Conclusion"></a>Conclusion</h5><p>Java 中将实参传递给方法（或函数）的方式是 值传递：</p><ul><li>如果参数是基本类型的话，很简单，传递的就是基本类型的字面量值的拷贝，会创建副本。</li><li>如果参数是引用类型，传递的就是实参所引用的对象在堆中地址值的拷贝，同样也会创建副本。</li></ul><h4 id="代理模式"><a href="#代理模式" class="headerlink" title="代理模式"></a>代理模式</h4><h5 id="代理模式是什么？"><a href="#代理模式是什么？" class="headerlink" title="代理模式是什么？"></a>代理模式是什么？</h5><p>简单来说就是我们使用代理对象来代替对真实对象(real object)的访问，这样就可以在不修改原目标对象的前提下，提供额外的功能操作，扩展目标对象的功能。</p><p>代理模式的主要作用是扩展目标对象的功能，比如说在目标对象的某个方法执行前后你可以增加一些自定义的操作。(结合现实生活中的代理人来理解)</p><h5 id="静态代理"><a href="#静态代理" class="headerlink" title="静态代理"></a>静态代理</h5><p>静态代理中，我们对目标对象的每个方法的增强都是手动完成的,非常不灵活（比如接口一旦新增加方法，目标对象和代理对象都要进行修改），而且麻烦(需要对每个目标类都单独写一个代理类），实际开发中基本不用。</p><p>静态代理实现步骤:</p><ol><li>定义一个接口及其实现类；</li><li>创建一个代理类同样实现这个接口</li><li>将目标对象注入进代理类，然后在代理类的对应方法调用目标类中的对应方法。这样的话，我们就可以通过代理类屏蔽对目标对象的访问，并且可以在目标方法执行前后做一些自己想做的事情。</li></ol><h5 id="动态代理"><a href="#动态代理" class="headerlink" title="动态代理"></a>动态代理</h5><!-- TODO: 项目中哪里用到了代理？ --><p>我们不需要针对每个目标类都单独创建一个代理类，并且也不需要我们必须实现接口，我们可以直接代理实现类( CGLIB 动态代理机制)。</p><p>动态代理在我们日常开发中使用的相对较少，但是在框架中的几乎是必用的一门技术。</p><h6 id="JDK动态代理机制"><a href="#JDK动态代理机制" class="headerlink" title="JDK动态代理机制"></a>JDK动态代理机制</h6><h6 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h6><p>在 Java 动态代理机制中 InvocationHandler 接口和 Proxy 类是核心。<br>Proxy 类中使用频率最高的方法是：newProxyInstance() ，这个方法主要用来生成一个代理对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title function_">newProxyInstance</span><span class="params">(ClassLoader loader,</span></span><br><span class="line"><span class="params">                                      Class&lt;?&gt;[] interfaces,</span></span><br><span class="line"><span class="params">                                      InvocationHandler h)</span></span><br><span class="line">    <span class="keyword">throws</span> IllegalArgumentException</span><br><span class="line">&#123;</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>这个方法一共有 3 个参数：</p><ol><li>loader :类加载器，用于加载代理对象。</li><li>interfaces : 被代理类实现的一些接口；</li><li>h: 实现了 InvocationHandler 接口的对象；</li></ol><p>要实现动态代理的话，还必须需要实现InvocationHandler 来自定义处理逻辑。 当我们的动态代理对象调用一个方法时，这个方法的调用就会被转发到实现InvocationHandler 接口类的 invoke 方法来调用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">InvocationHandler</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 当你使用代理对象调用方法的时候实际会调用到这个方法</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span></span><br><span class="line">        <span class="keyword">throws</span> Throwable;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>invoke() 方法有下面三个参数：</p><ol><li>proxy :动态生成的代理类</li><li>method : 与代理类对象调用的方法相对应</li><li>args : 当前 method 方法的参数</li></ol><h6 id="JDK-动态代理类使用步骤"><a href="#JDK-动态代理类使用步骤" class="headerlink" title="JDK 动态代理类使用步骤"></a>JDK 动态代理类使用步骤</h6><ol><li>定义一个接口及其实现类；</li><li>自定义 InvocationHandler 并重写invoke方法，在 invoke 方法中我们会调用原生方法（被代理类的方法）并自定义一些处理逻辑；invoke() 方法: 当我们的动态代理对象调用原生方法的时候，最终实际上调用到的是 invoke() 方法，然后 invoke() 方法代替我们去调用了被代理对象的原生方法。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"> <span class="keyword">public</span> Object <span class="title function_">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> InvocationTargetException, IllegalAccessException &#123;</span><br><span class="line">     <span class="comment">//调用方法之前，我们可以添加自己的操作</span></span><br><span class="line">     System.out.println(<span class="string">&quot;before method &quot;</span> + method.getName());</span><br><span class="line">     <span class="type">Object</span> <span class="variable">result</span> <span class="operator">=</span> method.invoke(target, args);</span><br><span class="line">     <span class="comment">//调用方法之后，我们同样可以添加自己的操作</span></span><br><span class="line">     System.out.println(<span class="string">&quot;after method &quot;</span> + method.getName());</span><br><span class="line">     <span class="keyword">return</span> result;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><ol start="3"><li>通过 Proxy.newProxyInstance(ClassLoader loader,Class&lt;?&gt;[] interfaces,InvocationHandler h) 方法创建代理对象；</li></ol><h5 id="CGLIB-动态代理机制"><a href="#CGLIB-动态代理机制" class="headerlink" title="CGLIB 动态代理机制"></a>CGLIB 动态代理机制</h5><h6 id="介绍-1"><a href="#介绍-1" class="headerlink" title="介绍"></a>介绍</h6><p>JDK 动态代理有一个最致命的问题是其只能代理实现了接口的类。</p><p>为了解决这个问题，我们可以用 CGLIB 动态代理机制来避免。</p><p>在 CGLIB 动态代理机制中 MethodInterceptor(拦截被代理类中的方法) 接口和 Enhancer(实现对拦截方法的增强) 类是核心。</p><h5 id="JDK动态代理和CGLIB动态代理的对比"><a href="#JDK动态代理和CGLIB动态代理的对比" class="headerlink" title="JDK动态代理和CGLIB动态代理的对比"></a>JDK动态代理和CGLIB动态代理的对比</h5><ol><li><p>JDK 动态代理只能代理实现了接口的类或者直接代理接口，而 CGLIB 可以代理未实现任何接口的类。</p></li><li><p>就二者的效率来说，大部分情况都是 JDK 动态代理更优秀，随着 JDK 版本的升级，这个优势更加明显。</p></li></ol><h5 id="静态代理和动态代理的对比"><a href="#静态代理和动态代理的对比" class="headerlink" title="静态代理和动态代理的对比"></a>静态代理和动态代理的对比</h5><ul><li>灵活性：动态代理更加灵活，不需要必须实现接口，可以直接代理实现类，并且可以不需要针对每个目标类都创建一个代理类。另外，静态代理中，接口一旦新增加方法，目标对象和代理对象都要进行修改，这是非常麻烦的</li><li>JVM 层面：静态代理在编译时就将接口、实现类、代理类这些都变成了一个个实际的 class 文件。而动态代理是在运行时动态生成类字节码，并加载到 JVM 中的。</li></ul><h4 id="BigDecimal"><a href="#BigDecimal" class="headerlink" title="BigDecimal"></a>BigDecimal</h4><p>介绍:BigDecimal 可以实现对浮点数的运算，不会造成精度丢失。通常情况下，大部分需要浮点数精确运算结果的业务场景（比如涉及到钱的场景）都是通过 BigDecimal 来做的。</p><p>浮点数之间的等值判断，基本数据类型不能用 &#x3D;&#x3D; 来比较，包装数据类型不能用 equals 来判断。</p><p>这是因为浮点数在计算机中的存储方式和精度问题。浮点数采用二进制的形式存储，而在二进制中，一些十进制的小数是无法精确表示的，就像在十进制中无法精确表示 1&#x2F;3 一样。这会导致在进行浮点数计算时产生一些微小的舍入误差。这些微小的误差可能会在不同的计算中累积，导致我们不能简单地依赖直接相等性比较来判断两个浮点数是否相等。</p><p>当我们使用 &#x3D;&#x3D; 运算符比较两个浮点数时，它会比较它们的存储值，而存储值是有舍入误差的。</p><p>而对于包装数据类型，例如 Double、Float 等，它们是对象，使用 equals() 方法进行比较时，默认情况下比较的是对象的<strong>引用地址</strong>，而不是比较对象所代表的值是否相等。因此，使用 equals() 方法进行包装数据类型的相等性比较可能不会得到正确的结果，除非你重写了 equals() 方法来进行值比较。</p><h5 id="BigDecimal等值比较问题"><a href="#BigDecimal等值比较问题" class="headerlink" title="BigDecimal等值比较问题"></a>BigDecimal等值比较问题</h5><p>BigDecimal的等值比较应使用<code>compareTo()</code>方法，而不是<code>equals()</code>方法。compareTo() 方法可以比较两个 BigDecimal 的值。</p><h4 id="Java魔法类Unsafe"><a href="#Java魔法类Unsafe" class="headerlink" title="Java魔法类Unsafe"></a>Java魔法类Unsafe</h4><p>Unsafe 是位于 sun.misc 包下的一个类，主要提供一些用于执行<strong>低级别</strong>、<strong>不安全操作</strong>的方法，如直接访问系统内存资源、自主管理内存资源等，这些方法在提升 Java 运行效率、增强 Java 语言底层资源操作能力方面起到了很大的作用。但由于 Unsafe 类使 Java 语言拥有了类似 C 语言指针一样操作内存空间的能力，这无疑也增加了程序发生相关指针问题的风险。在程序中过度、不正确使用 Unsafe 类会使得程序出错的概率变大，使得 Java 这种安全的语言变得不再“安全”，因此对 Unsafe 的使用一定要慎重。</p><h3 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h3><h3 id="并发编程"><a href="#并发编程" class="headerlink" title="并发编程"></a>并发编程</h3><h4 id="ThreadLocal"><a href="#ThreadLocal" class="headerlink" title="ThreadLocal"></a>ThreadLocal</h4><h5 id="ThreadLocal有什么用？"><a href="#ThreadLocal有什么用？" class="headerlink" title="ThreadLocal有什么用？"></a>ThreadLocal有什么用？</h5><p>通常情况下，我们创建的变量是可以被任何一个线程访问并修改的。<br>如果想实现每一个线程都有自己的专属本地变量该如何解决呢？</p><p>DK 中自带的ThreadLocal类正是为了解决这样的问题。 ThreadLocal类主要解决的就是让每个线程绑定自己的值，可以将ThreadLocal类形象的比喻成存放数据的盒子，盒子中可以存储每个线程的私有数据。</p><p>如果你创建了一个ThreadLocal变量，那么访问这个变量的每个线程都会有这个变量的本地副本，这也是ThreadLocal变量名的由来。他们可以使用 get() 和 set() 方法来获取默认值或将其值更改为当前线程所存的副本的值，从而避免了线程安全问题。</p><h5 id="ThreadLocal内存泄露问题是怎么倒置的？"><a href="#ThreadLocal内存泄露问题是怎么倒置的？" class="headerlink" title="ThreadLocal内存泄露问题是怎么倒置的？"></a>ThreadLocal内存泄露问题是怎么倒置的？</h5><blockquote><p>[!TIP]<br>待施工</p></blockquote><h4 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h4><p>线程池就是管理一系列线程的资源池。<br>当有任务要处理时，直接从线程池中获取线程来处理，处理完之后线程并不会立即被销毁，而是等待下一个任务。</p><h5 id="为什么要用线程池？"><a href="#为什么要用线程池？" class="headerlink" title="为什么要用线程池？"></a>为什么要用线程池？</h5><p>池化技术想必大家已经屡见不鲜了，线程池、数据库连接池、HTTP 连接池等等都是对这个思想的应用。池化技术的思想主要是为了减少每次获取资源的消耗，提高对资源的利用率。</p><p>使用线程池的好处：</p><ul><li>降低资源消耗。通过重复利用已创建的线程降低线程创建和销毁造成的消耗。</li><li>提高响应速度。当任务到达时，任务可以不需要等到线程创建就能立即执行。</li><li>提高线程的可管理性。线程是稀缺资源，如果无限制的创建，不仅会消耗系统资源，还会降低系统的稳定性，使用线程池可以进行统一的分配，调优和监控。</li></ul><h5 id="如何创建线程池"><a href="#如何创建线程池" class="headerlink" title="如何创建线程池"></a>如何创建线程池</h5><p>法一：通过ThreadPoolExecutor构造函数来创建（推荐）。</p><p>法二：通过 Executor 框架的工具类 Executors 来创建。</p><p>Executors工具类可以创建多种类型的线程池，包括：</p><ul><li>FixedThreadPool：固定线程数量的线程池。该线程池中的线程数量始终不变。当有一个新的任务提交时，线程池中若有空闲线程，则立即执行。若没有，则新的任务会被暂存在一个任务队列中，待有线程空闲时，便处理在任务队列中的任务。</li><li>SingleThreadExecutor： 只有一个线程的线程池。若多余一个任务被提交到该线程池，任务会被保存在一个任务队列中，待线程空闲，按先入先出(队列)的顺序执行队列中的任务。</li><li>CachedThreadPool： 可根据实际情况调整线程数量的线程池。线程池的线程数量不确定，但若有空闲线程可以复用，则会优先使用可复用的线程。若所有线程均在工作，又有新的任务提交，则会创建新的线程处理任务。所有线程在当前任务执行完毕后，将返回线程池进行复用。</li><li>ScheduledThreadPool：给定的延迟后运行任务或者定期执行任务的线程池。</li></ul><h5 id="为什么不推荐使用内置线程池"><a href="#为什么不推荐使用内置线程池" class="headerlink" title="为什么不推荐使用内置线程池"></a>为什么不推荐使用内置线程池</h5><p>《阿里巴巴 Java 开发手册》“并发处理”这一章节，明确指出线程资源必须通过线程池提供，不允许在应用中自行显式创建线程。</p><ul><li>使用线程池的好处是减少在创建和销毁线程上所消耗的时间以及系统资源开销，解决资源不足的问题。如果不使用线程池，有可能会造成系统创建大量同类线程而导致消耗完内存或者“过度切换”的问题。</li></ul><p>另外，《阿里巴巴 Java 开发手册》中强制线程池不允许使用 Executors 去创建，而是通过 ThreadPoolExecutor 构造函数的方式，因为<code>Executors</code>容易导致OOM(out of memory)问题</p><h5 id="线程池常见参数"><a href="#线程池常见参数" class="headerlink" title="线程池常见参数"></a>线程池常见参数</h5><h5 id="线程池的拒绝策略有哪些？"><a href="#线程池的拒绝策略有哪些？" class="headerlink" title="线程池的拒绝策略有哪些？"></a>线程池的拒绝策略有哪些？</h5><h5 id="如果不允许丢弃任务任务，应该选择哪个拒绝策略？"><a href="#如果不允许丢弃任务任务，应该选择哪个拒绝策略？" class="headerlink" title="如果不允许丢弃任务任务，应该选择哪个拒绝策略？"></a>如果不允许丢弃任务任务，应该选择哪个拒绝策略？</h5><h5 id="CallerRunsPolicy-拒绝策略有什么风险？如何解决？"><a href="#CallerRunsPolicy-拒绝策略有什么风险？如何解决？" class="headerlink" title="CallerRunsPolicy 拒绝策略有什么风险？如何解决？"></a>CallerRunsPolicy 拒绝策略有什么风险？如何解决？</h5><h5 id="线程池常用的阻塞队列有哪些？"><a href="#线程池常用的阻塞队列有哪些？" class="headerlink" title="线程池常用的阻塞队列有哪些？"></a>线程池常用的阻塞队列有哪些？</h5><h5 id="线程池处理任务的流程"><a href="#线程池处理任务的流程" class="headerlink" title="线程池处理任务的流程"></a>线程池处理任务的流程</h5><h5 id="如何给线程池命名？"><a href="#如何给线程池命名？" class="headerlink" title="如何给线程池命名？"></a>如何给线程池命名？</h5><h5 id="如何设定线程池的大小？"><a href="#如何设定线程池的大小？" class="headerlink" title="如何设定线程池的大小？"></a>如何设定线程池的大小？</h5><h5 id="如何动态修改线程池的参数？"><a href="#如何动态修改线程池的参数？" class="headerlink" title="如何动态修改线程池的参数？"></a>如何动态修改线程池的参数？</h5><h5 id="如何设计一个能够根据任务的优先级来执行的线程池？"><a href="#如何设计一个能够根据任务的优先级来执行的线程池？" class="headerlink" title="如何设计一个能够根据任务的优先级来执行的线程池？"></a>如何设计一个能够根据任务的优先级来执行的线程池？</h5><blockquote><p>[!TIP]<br>待施工</p></blockquote><h3 id="IO-1"><a href="#IO-1" class="headerlink" title="&gt; IO"></a>&gt; IO</h3><h3 id="JVM"><a href="#JVM" class="headerlink" title="JVM"></a>JVM</h3><h3 id="新特性"><a href="#新特性" class="headerlink" title="新特性"></a>新特性</h3><h2 id="计算机基础"><a href="#计算机基础" class="headerlink" title="计算机基础"></a>计算机基础</h2><h3 id="计算机网络"><a href="#计算机网络" class="headerlink" title="计算机网络"></a>计算机网络</h3><h3 id="操作系统"><a href="#操作系统" class="headerlink" title="操作系统"></a>操作系统</h3><h4 id="操作系统基础"><a href="#操作系统基础" class="headerlink" title="操作系统基础"></a>操作系统基础</h4><h5 id="什么是操作系统？"><a href="#什么是操作系统？" class="headerlink" title="什么是操作系统？"></a>什么是操作系统？</h5><p>操作系统本质上是一个运行在计算机上的软件程序 ，<strong>主要用于管理计算机硬件和软件资源。</strong> 举例：运行在你电脑上的所有应用程序都通过操作系统来调用系统内存以及磁盘等等硬件。</p><h5 id="内核（Kernel）和中央处理器（CPU，Central-Processing-Unit）"><a href="#内核（Kernel）和中央处理器（CPU，Central-Processing-Unit）" class="headerlink" title="内核（Kernel）和中央处理器（CPU，Central Processing Unit）"></a>内核（Kernel）和中央处理器（CPU，Central Processing Unit）</h5><ol><li>操作系统的内核（Kernel）属于操作系统层面，而 CPU 属于硬件。</li><li>CPU 主要提供运算，处理各种指令的能力。内核（Kernel）主要负责系统管理比如内存管理，它屏蔽了对硬件的操作。</li></ol><h5 id="操作系统主要有哪些功能"><a href="#操作系统主要有哪些功能" class="headerlink" title="操作系统主要有哪些功能"></a>操作系统主要有哪些功能</h5><ol><li>进程和线程的管理：进程的创建、撤销、阻塞、唤醒，进程间的通信等。</li><li>存储管理：内存的分配和管理、外存（磁盘等）的分配和管理等。</li><li>文件管理：文件的读、写、创建及删除等。</li><li>设备管理：完成设备（输入输出设备和外部存储设备等）的请求或释放，以及设备启动等功能。</li><li>网络管理：操作系统负责管理计算机网络的使用。网络是计算机系统中连接不同计算机的方式，操作系统需要管理计算机网络的配置、连接、通信和安全等，以提供高效可靠的网络服务。</li><li>安全管理：用户的身份认证、访问控制、文件加密等，以防止非法用户对系统资源的访问和操作。</li></ol><h5 id="用户态和内核态？"><a href="#用户态和内核态？" class="headerlink" title="用户态和内核态？"></a>用户态和内核态？</h5><p>主要是访问权限的区别，可以理解为root用户和普通用户</p><p>进程访问资源的特点，我们可以把进程在系统上的运行分为两个级别：</p><ul><li>用户态(User Mode) : 用户态运行的进程可以直接读取用户程序的数据，拥有较低的权限。当应用程序需要执行某些需要特殊权限的操作，例如读写磁盘、网络通信等，就需要向操作系统发起系统调用请求，进入内核态。</li><li>内核态(Kernel Mode)：内核态运行的进程几乎可以访问计算机的任何资源包括系统的内存空间、设备、驱动程序等，不受限制，拥有非常高的权限。当操作系统接收到进程的系统调用请求时，就会从用户态切换到内核态，执行相应的系统调用，并将结果返回给进程，最后再从内核态切换回用户态。</li></ul><h5 id="为什么要有用户态和内核态？只有一个内核态不行么？"><a href="#为什么要有用户态和内核态？只有一个内核态不行么？" class="headerlink" title="为什么要有用户态和内核态？只有一个内核态不行么？"></a>为什么要有用户态和内核态？只有一个内核态不行么？</h5><ul><li>限制危险指令</li><li>所有程序或进程都必须共享系统资源将导致系统资源的竞争和冲突，从而影响系统性能和效率。<br>并且，这样也会让系统的安全性降低。</li></ul><h5 id="用户态和内核态是如何切换的？"><a href="#用户态和内核态是如何切换的？" class="headerlink" title="用户态和内核态是如何切换的？"></a>用户态和内核态是如何切换的？</h5><ol><li>系统调用（Trap）:用户态进程<strong>主动</strong>要求切换到内核态的一种方式。我们运行的程序基本都是运行在用户态，如果我们调用操作系统提供的内核态级别的子功能咋办呢？那就需要系统调用了。</li></ol><p>系统调用是应用程序与操作系统之间进行交互的一种方式，通过系统调用，应用程序可以访问操作系统底层资源例如文件、设备、网络等。</p><ol start="2"><li>中断（Interrupt)：用户态执行操作的时候有外围设备干完活了突然插队，那么用户态就切换到内核态。比如硬盘读写操作完成，系统会切换到硬盘读写的中断处理程序中执行后续操作等。</li><li>异常（Exception）:用户态运行时发生了事先不可知的某些异常（如缺页异常）会触发由当前运行进程切换到处理此异常的内核相关程序中，也就转到了内核态</li></ol><h4 id="系统调用的过程"><a href="#系统调用的过程" class="headerlink" title="系统调用的过程"></a>系统调用的过程</h4><ol><li>用户态执行程序时权限不足，中断执行（Trap），发起系统调用</li><li>发生中断后，当前 CPU 执行的程序会中断，跳转到中断处理程序。内核程序开始执行，开始处理系统调用。</li><li>内核处理完成后，主动触发 Trap，这样会再次发生中断，切换回用户态工作。</li></ol><p>总结：用户态发起系统调用-&gt;Trap-&gt;CPU跳转中断处理程序，处理系统调用-&gt;Trap-&gt;返回用户态</p><h4 id="进程和线程"><a href="#进程和线程" class="headerlink" title="进程和线程"></a>进程和线程</h4><h5 id="什么是进程和线程"><a href="#什么是进程和线程" class="headerlink" title="什么是进程和线程"></a>什么是进程和线程</h5><ul><li><p>进程（Process） 是指计算机中正在运行的一个程序实例。举例：你打开的微信就是一个进程。</p></li><li><p>线程（Thread） 也被称为轻量级进程，更加轻量。多个线程可以在同一个进程中同时执行，并且共享进程的资源比如内存空间、文件句柄、网络连接等。举例：你打开的微信里就有一个线程专门用来拉取别人发你的最新的消息。</p></li></ul><h5 id="进程和线程的区别是什么"><a href="#进程和线程的区别是什么" class="headerlink" title="进程和线程的区别是什么"></a>进程和线程的区别是什么</h5><p>从JVM的角度而言 ，在运行时数据区中,一个进程中可以有多个线程，多个线程共享进程的堆和方法区 (JDK1.8 之后的元空间)资源，但是每个线程有自己的程序计数器、虚拟机栈 和 本地方法栈。</p><p>总结：</p><ol><li>线程是进程划分成的更小的运行单位,一个进程在其执行的过程中可以产生多个线程。</li><li>线程和进程最大的不同在于基本上各进程是独立的，而各线程则不一定，因为同一进程中的线程极有可能会相互影响。</li><li>线程执行开销小，但不利于资源的管理和保护；而进程正相反。</li></ol><h5 id="有了进程为什么还需要线程？"><a href="#有了进程为什么还需要线程？" class="headerlink" title="有了进程为什么还需要线程？"></a>有了进程为什么还需要线程？</h5><ul><li>进程切换是一个开销很大的操作，线程切换的成本较低。</li><li>线程更轻量，一个进程可以创建多个线程。</li><li>多个线程可以并发处理不同的任务，更有效地利用了多处理器和多核计算机。而进程只能在一个时间干一件事，如果在执行过程中遇到阻塞问题比如 IO 阻塞就会挂起直到结果返回。</li><li>同一进程内的线程共享内存和文件，因此它们之间相互通信无须调用内核。</li></ul><h5 id="为什么要使用多线程"><a href="#为什么要使用多线程" class="headerlink" title="为什么要使用多线程"></a>为什么要使用多线程</h5><p>从总体上而言:</p><ul><li>从计算机底层而言：线程可看作轻量级的进程，是程序执行的最小单位线程间的切换和调度的成本远远小于进程。另外，多核 CPU 时代意味着多个线程可以同时运行，这减少了线程上下文切换的开销。</li><li>从当代互联网发展趋势来说： 现在的系统动不动就要求百万级甚至千万级的并发量，而多线程并发编程正是开发高并发系统的基础，利用好多线程机制可以大大提高系统整体的并发能力以及性能。</li></ul><p>从计算机底层而言：</p><ul><li>单核：当单核运行的时候，如果进程中只有一个线程，那么IO阻塞的时候，整合进程都被阻塞。而如果有多线程，那么就可以让别的线程继续使用cpu，从而提高了对系统资源的利用效率</li><li>多核：让CPU所有的核心都被不同的线程利用到，提高进程利用多核CPU的能力</li></ul><h5 id="线程间同步的方式有哪些"><a href="#线程间同步的方式有哪些" class="headerlink" title="线程间同步的方式有哪些"></a>线程间同步的方式有哪些</h5><p>线程同步是两个或多个共享关键资源的线程的并发执行。应该同步线程以避免关键的资源使用冲突。</p><p>下面是几种常见的线程同步的方式：</p><ol><li>互斥锁(Mutex)：采用互斥对象机制，只有拥有互斥对象的线程才有访问公共资源的权限。因为互斥对象只有一个，所以可以保证公共资源不会被多个线程同时访问。比如 Java 中的 synchronized 关键词和各种 Lock 都是这种机制。</li><li>读写锁（Read-Write Lock）：允许多个线程同时读取共享资源，但只有一个线程可以对共享资源进行写操作。<br>3, 信号量(Semaphore)：它允许同一时刻多个线程访问同一资源，但是需要控制同一时刻访问此资源的最大线程数量。</li><li>屏障（Barrier）：屏障是一种同步原语，用于等待多个线程到达某个点再一起继续执行。当一个线程到达屏障时，它会停止执行并等待其他线程到达屏障，直到所有线程都到达屏障后，它们才会一起继续执行。比如 Java 中的 CyclicBarrier 是这种机制。</li><li>事件(Event) :Wait&#x2F;Notify：通过通知操作的方式来保持多线程同步，还可以方便的实现多线程优先级的比较操作。</li></ol><h5 id="PCB-是什么？包含哪些信息？"><a href="#PCB-是什么？包含哪些信息？" class="headerlink" title="PCB 是什么？包含哪些信息？"></a>PCB 是什么？包含哪些信息？</h5><p>PCB（Process Control Block） 即进程控制块，是操作系统中用来管理和跟踪进程的数据结构，每个进程都对应着一个独立的 PCB。你可以将 PCB 视为进程的大脑。</p><p>当操作系统创建一个新进程时，会为该进程分配一个唯一的进程 ID，并且为该进程创建一个对应的进程控制块。当进程执行时，PCB 中的信息会不断变化，操作系统会根据这些信息来管理和调度进程。</p><p>PCB主要包括下面几部分内容:</p><ol><li>进程的描述信息，包括进程的名称、标识符等等；</li><li>进程的调度信息，包括进程阻塞原因、进程状态（就绪、运行、阻塞等）、进程优先级（标识进程的重要程度）等等；</li><li>进程对资源的需求情况，包括 CPU 时间、内存空间、I&#x2F;O 设备等等。</li><li>进程打开的文件信息，包括文件描述符、文件类型、打开模式等等。</li><li>处理机的状态信息（由处理机的各种寄存器中的内容组成的），包括通用寄存器、指令计数器、程序状态字 PSW、用户栈指针。</li><li>……</li></ol><h5 id="进程有哪几种状态"><a href="#进程有哪几种状态" class="headerlink" title="进程有哪几种状态"></a>进程有哪几种状态</h5><p>我们一般把进程大致分为 5 种状态，这一点和线程很像,</p><ol><li>创建状态(new)：进程正在被创建</li><li>就绪状态(ready)：进程已处于准备运行状态，即进程获得了除了处理器之外的一切所需资源，一旦得到处理器资源(处理器分配的时间片)即可运行</li><li>运行状态(running)</li><li>阻塞状态(waiting)：又称为等待状态，进程正在等待某一事件而暂停运行如等待某资源为可用或等待 IO 操作完成。即使处理器空闲，该进程也不能运行。</li><li>结束状态(terminated)</li></ol><h5 id="进程间的通信方式有哪些"><a href="#进程间的通信方式有哪些" class="headerlink" title="进程间的通信方式有哪些?"></a>进程间的通信方式有哪些?</h5><ol><li>管道&#x2F;匿名管道(pipes): 有亲缘关系的父子进程间或者兄弟进程之间的通信</li><li>有名管道(Named Pipes) : 匿名管道由于没有名字，只能用于亲缘关系的进程间通信。为了克服这个缺点，提出了有名管道。有名管道严格遵循 先进先出(First In First Out) 。有名管道以磁盘文件的方式存在，可以实现本机任意两个进程通信。</li><li>信号(Signal)：信号是一种比较复杂的通信方式，用于通知接收进程某个事件已经发生；</li><li>消息队列(Message Queuing)：消息队列是消息的链表,具有特定的格式,存放在内存中并由消息队列标识符标识。管道和消息队列的通信数据都是先进先出的原则。与管道（无名管道：只存在于内存中的文件；命名管道：存在于实际的磁盘介质或者文件系统）不同的是消息队列存放在<strong>内核</strong>中，只有在内核重启(即，操作系统重启)或者显式地删除一个消息队列时，该消息队列才会被真正的删除。消息队列可以实现消息的随机查询,消息不一定要以先进先出的次序读取,也可以按消息的类型读取.比 FIFO 更有优势。消息队列克服了信号承载信息量少，管道只能承载无格式字节流以及缓冲区大小受限等缺点。</li><li>信号量(Semaphores)：信号量是一个计数器，用于多进程对共享数据的访问，信号量的意图在于进程间同步。这种通信方式主要用于解决与同步相关的问题并避免竞争条件。</li><li>共享内存(Shared memory)：使得多个进程可以访问同一块内存空间，不同进程可以及时看到对方进程中对共享内存中数据的更新。这种方式需要依靠某种同步操作，如互斥锁和信号量等。可以说这是最有用的进程间通信方式。</li><li>套接字(Sockets) : 此方法主要用于在<strong>客户端和服务器之间通过网络进行通信</strong>。套接字是支持 TCP&#x2F;IP 的网络通信的基本操作单元，可以看做是不同主机之间的进程进行双向通信的端点，简单的说就是通信的两方的一种约定，用套接字中的相关函数来完成通信过程。</li></ol><h5 id="⭐️常见的进程调度算法有哪些"><a href="#⭐️常见的进程调度算法有哪些" class="headerlink" title="⭐️常见的进程调度算法有哪些"></a>⭐️常见的进程调度算法有哪些</h5><ol><li>先来先服务(FCFS)</li><li>短作业优先(SJF, Shortest Job First)：从就绪队列中选出一个估计运行时间最短的进程为之分配资源</li><li>时间片轮转法(RR, Round-Robin)</li><li>⭐️多级反馈队列调度(MFQ, Multi_leveel Feedback Queue)多级反馈队列调度算法既能使高优先级的作业得到响应又能使短作业（进程）迅速完成，因而它是目前被公认的一种较好的进程调度算法，UNIX 操作系统采取的便是这种调度算法。</li><li>优先级调度算法(Priority):为每个流程分配优先级，首先执行具有最高优先级的进程，依此类推。具有相同优先级的进程以 FCFS 方式执行。</li></ol><h5 id="什么是僵尸进程和孤儿进程"><a href="#什么是僵尸进程和孤儿进程" class="headerlink" title="什么是僵尸进程和孤儿进程"></a>什么是僵尸进程和孤儿进程</h5><p>在 Unix&#x2F;Linux 系统中，子进程通常是通过 fork()系统调用创建的，该调用会创建一个新的进程，该进程是原有进程的一个副本。子进程和父进程的运行是相互独立的，它们各自拥有自己的 PCB，即使父进程结束了，子进程仍然可以继续运行。<br>当一个进程调用 exit()系统调用结束自己的生命时，内核会释放该进程的所有资源，包括打开的文件、占用的内存等，但是该进程对应的 PCB 依然存在于系统中。这些信息只有在父进程调用 wait()或 waitpid()系统调用时才会被释放，以便让父进程得到子进程的状态信息。这样的设计可以让父进程在子进程结束时得到子进程的状态信息，并且可以防止出现“僵尸进程”（即子进程结束后 PCB 仍然存在但父进程无法得到状态信息的情况）。</p><p>这两个都是针对子进程的说法</p><ul><li><p>僵尸进程：<br>子进程已经终止，<br>但是其父进程仍在运行，且父进程没有调用 wait()或 waitpid()等系统调用来获取子进程的状态信息，释放子进程占用的资源，导致子进程的 PCB 依然存在于系统中，但无法被进一步使用。<br>这种情况下，子进程被称为“僵尸进程”。<br>避免僵尸进程的产生，父进程需要及时调用 wait()或 waitpid()系统调用来回收子进程。</p></li><li><p>孤儿进程：一个进程的父进程已经终止或者不存在，但是该进程仍在运行。这种情况下，该进程就是孤儿进程。<br>孤儿进程通常是由于父进程意外终止或未及时调用 wait()或 waitpid()等系统调用来回收子进程导致的。为了避免孤儿进程占用系统资源，操作系统会将孤儿进程的父进程设置为 init 进程（进程号为 1），由 init 进程来回收孤儿进程的资源。</p></li></ul><h5 id="如何查看僵尸进程"><a href="#如何查看僵尸进程" class="headerlink" title="如何查看僵尸进程"></a>如何查看僵尸进程</h5><p>Linux 下可以使用 Top 命令查找，zombie 值表示僵尸进程的数量，为 0 则代表没有僵尸进程。</p><p>下面这个命令可以定位僵尸进程以及该僵尸进程的父进程：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">ps -A -ostat,ppid,pid,cmd |grep -e &#x27;^[Zz]&#x27;</span><br><span class="line"></span><br><span class="line"># ps: 用于显示当前正在运行的进程的信息。</span><br><span class="line"># -A: 显示所有进程，而不仅仅是当前用户的进程。</span><br><span class="line"># -o: 指定输出格式。(output)</span><br><span class="line"># stat: 进程状态。</span><br><span class="line"># ppid: 父进程ID。</span><br><span class="line"># pid: 进程ID。</span><br><span class="line"># cmd: 进程的命令行。</span><br><span class="line"># 然后，管道符 | 将 ps 命令的输出传递给 grep 命令。</span><br><span class="line">#</span><br><span class="line"># grep: 用于在文本中搜索指定的模式。</span><br><span class="line"># -e: 指定要匹配的模式。(expression)</span><br><span class="line"># 在这个命令中，grep 用于过滤出状态为僵尸的进程。正则表达式 &#x27;^[Zz]&#x27; 匹配以大写字母 &quot;Z&quot; 或小写字母 &quot;z&quot; 开头的行，这是表示僵尸进程状态的符号。</span><br><span class="line">#</span><br><span class="line"># 所以，整个命令的作用是找到并显示出所有状态为僵尸的进程的相关信息。</span><br><span class="line">#</span><br></pre></td></tr></table></figure><h4 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h4><h5 id="什么是死锁"><a href="#什么是死锁" class="headerlink" title="什么是死锁"></a>什么是死锁</h5><p>多个进程&#x2F;线程同时被阻塞，它们中的一个或者全部都在等待某个资源被释放。由于进程&#x2F;线程被无限期地阻塞，因此程序不可能正常终止。</p><h5 id="产生死锁的四个必要条件"><a href="#产生死锁的四个必要条件" class="headerlink" title="产生死锁的四个必要条件"></a>产生死锁的四个必要条件</h5><ol><li>互斥：资源必须处于非共享模式，即<strong>一次只有一个进程可以使用</strong>a。如果另一进程申请该资源，那么必须等待直到该资源被释放为止。</li><li>占有并等待：一个进程至少应该占有一个资源，并等待另一资源，而该资源被其他进程所占有。</li><li>非抢占：资源不能被抢占。只能在持有资源的进程完成任务后，该资源才会被释放。</li><li>循环等待：有一组等待进程 {P0, P1,…, Pn}， P0 等待的资源被 P1 占有，P1 等待的资源被 P2 占有，……，Pn-1 等待的资源被 Pn 占有，Pn 等待的资源被 P0 占有。</li></ol><p>注意 ⚠️：这四个条件是产生死锁的 必要条件 ，也就是说只要系统发生死锁，这些条件必然成立，而只要上述条件之一不满足，就不会发生死锁。</p><h5 id="解决死锁的方法"><a href="#解决死锁的方法" class="headerlink" title="解决死锁的方法"></a>解决死锁的方法</h5><p>解决死锁的方法可以从多个角度去分析，一般的情况下，有预防，避免，检测和解除四种。</p><ul><li>预防是采用某种策略，限制并发进程对资源的请求，从而使得死锁的必要条件在系统执行的任何时间上都不满足。</li><li>避免则是系统在分配资源时，根据资源的使用情况提前做出预测，从而避免死锁的发生</li><li>检测是指系统设有专门的机构，当死锁发生时，该机构能够检测死锁的发生，并精确地确定与死锁有关的进程和资源。</li><li>解除是与检测相配套的一种措施，用于将进程从死锁状态下解脱出来。</li></ul><h5 id="死锁的预防"><a href="#死锁的预防" class="headerlink" title="死锁的预防"></a>死锁的预防</h5><p>死锁四大必要条件上面都已经列出来了，很显然，只要破坏四个必要条件中的任何一个就能够预防死锁的发生。破坏第一个条件 互斥条件：使得资源是可以同时访问的，这是种简单的方法，磁盘就可以用这种方法管理，但是我们要知道，有很多资源 往往是不能同时访问的 ，所以这种做法在大多数的场合是行不通的。破坏第三个条件 非抢占：也就是说可以采用 剥夺式调度算法，但剥夺式调度方法目前一般仅适用于 主存资源 和 处理器资源 的分配，并不适用于所有的资源，会导致 资源利用率下降。</p><p>预防死锁的方法，是通过考虑破坏第二个条件和第四个条件。</p><ol><li>静态分配策略静态分配策略可以破坏死锁产生的第二个条件（占有并等待）。所谓静态分配策略，就是指一个进程必须在执行前就申请到它所需要的全部资源，并且知道它所要的资源都得到满足之后才开始执行。进程要么占有所有的资源然后开始执行，要么不占有资源，不会出现占有一些资源等待一些资源的情况。静态分配策略逻辑简单，实现也很容易，但这种策略 严重地降低了资源利用率，因为在每个进程所占有的资源中，有些资源是在比较靠后的执行时间里采用的，甚至有些资源是在额外的情况下才使用的，这样就可能造成一个进程占有了一些 几乎不用的资源而使其他需要该资源的进程产生等待 的情况。</li><li>层次分配策略层次分配策略破坏了产生死锁的第四个条件(循环等待)。在层次分配策略下，所有的资源被分成了多个层次，一个进程得到某一次的一个资源后，它只能再申请较高一层的资源；当一个进程要释放某层的一个资源时，必须先释放所占用的较高层的资源，按这种策略，是不可能出现循环等待链的，因为那样的话，就出现了已经申请了较高层的资源，反而去申请了较低层的资源，不符合层次分配策略</li></ol><h5 id="死锁的解除"><a href="#死锁的解除" class="headerlink" title="死锁的解除"></a>死锁的解除</h5><p>常用的解除死锁的方法有以下四种：</p><ol><li>立即结束所有进程的执行，重新启动操作系统：这种方法简单，但以前所在的工作全部作废，损失很大。</li><li>撤销涉及死锁的所有进程，解除死锁后继续运行：这种方法能彻底打破死锁的循环等待条件，但将付出很大代价，例如有些进程可能已经计算了很长时间，由于被撤销而使产生的部分结果也被消除了，再重新执行时还要再次进行计算。</li><li>逐个撤销涉及死锁的进程，回收其资源直至死锁解除。</li><li>抢占资源：从涉及死锁的一个或几个进程中抢占资源，把夺得的资源再分配给涉及死锁的进程直至死锁解除。</li></ol><h3 id="内存管理"><a href="#内存管理" class="headerlink" title="内存管理"></a>内存管理</h3><h4 id="内存管理主要做了什么？"><a href="#内存管理主要做了什么？" class="headerlink" title="内存管理主要做了什么？"></a>内存管理主要做了什么？</h4><ul><li>内存的分配与回收：对进程所需的内存进行分配和释放，malloc 函数：申请内存，free 函数：释放内存。</li><li>地址转换：将程序中的虚拟地址转换成内存中的物理地址。</li><li>内存扩充：当系统没有足够的内存时，利用虚拟内存技术或自动覆盖技术，从逻辑上扩充内存。</li><li>内存映射：将一个文件直接映射到进程的进程空间中，这样可以通过内存指针用读写内存的办法直接存取文件内容，速度更快。</li><li>内存优化：通过调整内存分配策略和回收算法来优化内存使用效率。</li><li>内存安全：保证进程之间使用内存互不干扰，避免一些恶意程序通过修改内存来破坏系统的安全性。</li></ul><h4 id="什么是内存碎片？"><a href="#什么是内存碎片？" class="headerlink" title="什么是内存碎片？"></a>什么是内存碎片？</h4><p>由内存的申请和释放产生的，通常分为内部内存碎片和外部内存碎片</p><ul><li><p>内部内存碎片(Internal Memory Fragmentation，简称为内存碎片)：已经分配给进程使用但未被使用的内存。(进程用剩下的)</p></li><li><p>外部内存碎片(External Memory Fragmentation，简称为外部碎片)：由于未分配的连续内存区域太小，以至于不能满足任意进程所需要的内存分配请求，这些小片段且不连续的内存空间被称为外部碎片。(太小以致没人要的)</p></li></ul><h4 id="常见的内存管理方式有哪些？"><a href="#常见的内存管理方式有哪些？" class="headerlink" title="常见的内存管理方式有哪些？"></a>常见的内存管理方式有哪些？</h4><ul><li>连续内存管理：为一个用户程序分配一个连续的内存空间，内存利用率一般不高。容易产生内存碎片</li><li>非连续内存管理：允许一个程序使用的内存分布在离散或者说不相邻的内存中，相对更加灵活一些。</li></ul><h4 id="虚拟内存"><a href="#虚拟内存" class="headerlink" title="虚拟内存"></a>虚拟内存</h4><p>虚拟内存(Virtual Memory)本质上来说它只是逻辑存在的，是一个假想出来的内存空间<br>它允许程序访问比实际物理内存更大的内存空间。<br>在使用虚拟内存的系统中，每个程序都认为它拥有连续的、私有的内存空间，这被称为虚拟地址空间<br>虚拟内存的主要主要作用：</p><ul><li><p>隔离进程：物理内存通过虚拟地址空间访问，虚拟地址空间与进程一一对应。每个进程都认为自己拥有了整个物理内存，进程之间彼此隔离，一个进程中的代码无法更改正在由另一进程或操作系统使用的物理内存。</p></li><li><p>提升物理内存利用率：有了虚拟地址空间后，操作系统只需要将进程当前正在使用的部分数据或指令加载入物理内存。</p></li><li><p>简化内存管理：进程都有一个一致且私有的虚拟地址空间，程序员不用和真正的物理内存打交道，而是借助虚拟地址空间访问物理内存，从而简化了内存管理。</p></li><li><p>多个进程共享物理内存：进程在运行过程中，会加载许多操作系统的动态库。这些库对于每个进程而言都是公用的，它们在内存中实际只会加载一份，这部分称为共享内存。</p></li><li><p>提高内存使用安全性：控制进程对物理内存的访问，隔离不同进程的访问权限，提高系统的安全性。</p></li><li><p>提供更大的可使用内存空间：可以让程序拥有超过系统物理内存大小的可用内存空间。<br>这是因为<strong>当物理内存不够用时，可以利用磁盘充当</strong>，将物理内存页（通常大小为 4 KB）保存到磁盘文件（会影响读写速度），数据或代码页会根据需要在物理内存与磁盘之间移动。</p></li></ul><h4 id="没有虚拟内存会有什么问题"><a href="#没有虚拟内存会有什么问题" class="headerlink" title="没有虚拟内存会有什么问题"></a>没有虚拟内存会有什么问题</h4><ol><li>用户程序可以直接访问内存，如果不小信息操作到系统运行所需要的内存，造成操作系统崩溃，严重影响系统的安全。</li><li>同时运行多个程序容易崩溃。因为不同的程序容易有相同内存地址导致冲突<br>比如你想同时运行一个微信和一个 QQ 音乐，微信在运行的时候给内存地址 1xxx 赋值后，QQ 音乐也同样给内存地址 1xxx 赋值，那么 QQ 音乐对内存的赋值就会覆盖微信之前所赋的值，这就可能会造成微信这个程序会崩溃。</li><li>程序运行过程中使用的所有数据或指令都要载入物理内存，但是很大部分都是不会用到的，会浪费内存空间</li></ol><h4 id="什么是虚拟地址和物理地址？"><a href="#什么是虚拟地址和物理地址？" class="headerlink" title="什么是虚拟地址和物理地址？"></a>什么是虚拟地址和物理地址？</h4><p>物理地址（Physical Address） 是真正的物理内存中地址，更具体点来说是内存地址寄存器中的地址。</p><p>但程序中访问的内存地址不是物理地址，而是虚拟地址（Virtual Address）。</p><p>操作系统一般通过 CPU 芯片中的一个重要组件MMU(Memory Management Unit，内存管理单元) 将虚拟地址转换为物理地址，这个过程被称为地址翻译&#x2F;地址转换（Address Translation） 。</p><h4 id="什么是虚拟地址空间和物理地址空间？"><a href="#什么是虚拟地址空间和物理地址空间？" class="headerlink" title="什么是虚拟地址空间和物理地址空间？"></a>什么是虚拟地址空间和物理地址空间？</h4><ul><li>虚拟地址空间是<strong>虚拟地址的集合，是虚拟内存的范围</strong>。每一个进程都有一个一致且私有的虚拟地址空间。</li><li>物理地址空间是<strong>物理地址的集合，是物理内存的范围</strong>。</li></ul><h4 id="虚拟地址与物理内存地址是如何映射的？"><a href="#虚拟地址与物理内存地址是如何映射的？" class="headerlink" title="虚拟地址与物理内存地址是如何映射的？"></a>虚拟地址与物理内存地址是如何映射的？</h4><p>MMU 将虚拟地址翻译为物理地址的主要机制有 3 种:</p><ul><li>分段机制</li><li>分页机制</li><li>段页机制</li></ul><p>其中，现代操作系统广泛采用分页机制，需要重点关注！</p><h5 id="分段机制"><a href="#分段机制" class="headerlink" title="分段机制"></a>分段机制</h5><p>分段机制以段的形式管理&#x2F;分配物理内存。应用程序的虚拟地址空间被分为大小不等的段，每个段定义了一组逻辑信息，例如有主程序段 MAIN、子程序段 X、数据段 D 及栈段 S 等。</p><h6 id="段表有什么用？地址翻译过程是怎样的？"><a href="#段表有什么用？地址翻译过程是怎样的？" class="headerlink" title="段表有什么用？地址翻译过程是怎样的？"></a>段表有什么用？地址翻译过程是怎样的？</h6><p>分段管理通过段表（Segment Table）映射虚拟地址和物理地址。</p><p>分段机制下的虚拟地址由两部分组成：</p><ul><li>段号：标识着该虚拟地址属于整个虚拟地址空间中的哪一个段。</li><li>段内偏移量：相对于该段起始地址的偏移量。</li></ul><p>具体的地址翻译过程如下：</p><ol><li>MMU 首先解析得到虚拟地址中的<strong>段号</strong>；</li><li>通过段号去该应用程序的段表中取出对应的段信息（找到对应的段表项）；</li><li>从段信息中取出该段的起始地址（物理地址）加上虚拟地址中的段内偏移量得到最终的物理地址。</li></ol><p>MMU解析虚拟地址的段号-&gt;通过段号去段表中找到对应的段表项，从段信息中获取该段的起始地址(物理地址)加上虚拟地址中的偏移量得到最终的物理地址</p><p>通过段号一定要找到对应的段表项吗？得到最终的物理地址后对应的物理内存一定存在吗？</p><p>不一定，段表项可能并不存在：</p><ul><li>段表项被删除：软件错误、软件恶意行为等情况可能会导致段表项被删除。</li><li>段表项还未创建：如果系统内存不足或者无法分配到连续的物理内存块就会导致段表项无法被创建。</li></ul><p>分段机制容易出现外部内存碎片</p><h5 id="分页机制"><a href="#分页机制" class="headerlink" title="分页机制"></a>分页机制</h5><p>分页机制（Paging） 把主存（物理内存）分为连续等长的物理页，应用程序的虚拟地址空间划也被分为连续等长的虚拟页。现代操作系统广泛采用分页机制。</p><p><strong>注意：这里的页是连续等长的，不同于分段机制下不同长度的段。</strong></p><p>在分页机制下，应用程序虚拟地址空间中的任意虚拟页可以被映射到物理内存中的任意物理页上，因此可以实现物理内存资源的离散分配。分页机制按照固定页大小分配物理内存，使得物理内存资源易于管理，可有效避免分段机制中外部内存碎片的问题。</p><ul><li>页表有什么用？地址翻译过程是怎样的？</li></ul><p>分页管理通过 页表（Page Table） 映射虚拟地址和物理地址。</p><p>分页机制下的虚拟地址由两部分组成：</p><ul><li>页号：通过虚拟页号可以从页表中取出对应的物理页号；</li><li>页内偏移量：物理页起始地址+页内偏移量&#x3D;物理内存地址。</li></ul><p>具体的地址翻译过程如下：</p><p>MMU解析虚拟地址的页号-&gt;通过页号去段表中找到对应的页表项，从页信息中获取该段的起始地址(物理地址)加上虚拟地址中的偏移量得到最终的物理地址</p><p>通过虚拟页号也不一定要找到对应的物理页号,可能会存在<strong>页缺失</strong></p><p>多级页表属于时间换空间的典型场景，利用增加页表查询的次数减少页表占用的空间。结合数据库理解将一张表拆分为两张表，二级列表按需加载，就可以节省空间</p><h5 id="段页机制"><a href="#段页机制" class="headerlink" title="段页机制"></a>段页机制</h5><p>在段页式机制下，地址翻译的过程分为两个步骤：</p><pre><code>段式地址映射。页式地址映射。</code></pre><h4 id="⭐️操作系统师兄面试题"><a href="#⭐️操作系统师兄面试题" class="headerlink" title="⭐️操作系统师兄面试题"></a>⭐️操作系统师兄面试题</h4><p><a href="https://mubu.com/app/edit/home/5Vbsc1GjSNm">八股-操作系统</a></p><h3 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h3><h3 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h3><h2 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h2><h3 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h3><h4 id="数据库基础知识总结"><a href="#数据库基础知识总结" class="headerlink" title="数据库基础知识总结"></a>数据库基础知识总结</h4><h5 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h5><ul><li>元组(tuple) :元组（tuple）是关系数据库中的基本概念，关系是一张表，表中的每行（即数据库中的每条记录）就是一个元组，每列就是一个属性。 在二维表里，元组也称为行。</li><li>码：就是能唯一标识实体的属性，对应表中的列</li><li>候选码：若关系中的某一属性或属性组的值能唯一的标识一个元组，而其任何、子集都不能再标识，则称该属性组为候选码。</li><li>主码:主码是从候选码中选出来的。 一个实体集中只能有一个主码，但可以有多个候选码。</li><li>外码：</li><li>主属性：候选码中出现过的属性称为主属性</li><li>非主属性： 不包含在任何一个候选码中的属性称为非主属性。</li></ul><h5 id="什么是ER图-Entity-Relationship-Diagram"><a href="#什么是ER图-Entity-Relationship-Diagram" class="headerlink" title="什么是ER图(Entity Relationship Diagram)"></a>什么是ER图(Entity Relationship Diagram)</h5><h5 id="数据库的范式"><a href="#数据库的范式" class="headerlink" title="数据库的范式"></a>数据库的范式</h5><ul><li>1NF(第一范式)：属性不可再分。</li><li>2NF(第二范式)：1NF 的基础之上，消除了非主属性对于码的部分函数依赖。</li><li>3NF(第三范式)：3NF 在 2NF 的基础之上，消除了非主属性对于码的传递函数依赖 。符合 3NF 要求的数据库设计，基本上解决了数据冗余过大，插入异常，修改异常，删除异常的问题。比如在关系 R(学号 , 姓名, 系名，系主任)中，学号 → 系名，系名 → 系主任，所以存在非主属性系主任对于学号的传递函数依赖，所以该表的设计，不符合 3NF 的要求。</li></ul><p>一些重要概念：</p><ul><li>函数依赖：X 的值确定的情况下，必定能确定属性 Y 的值，那么就可以说 Y 函数依赖于 X，写作 X → Y。</li><li>部分函数依赖：如果 X→Y,且存在X的子集X0→Y，则称 Y 对 X 部分函数依赖</li><li>完全函数依赖: 在一个关系中，若某个非主属性数据项依赖于<strong>全部</strong>关键字称之为完全函数依赖</li><li>传递函数依赖: 在关系模式 R(U)中，设 X，Y，Z 是 U 的不同的属性子集，如果 X 确定 Y、Y 确定 Z，且有 X 不包含 Y，Y 不确定 X，（X∪Y）∩Z&#x3D;空集合，则称 Z 传递函数依赖(transitive functional dependency) 于 X</li></ul><h5 id="为什么不推荐使用外键和级联？"><a href="#为什么不推荐使用外键和级联？" class="headerlink" title="为什么不推荐使用外键和级联？"></a>为什么不推荐使用外键和级联？</h5><p>说明: 以学生和成绩的关系为例，学生表中的 student_id 是主键，那么成绩表中的 student_id 则为外键。如果更新学生表中的 student_id，同时触发成绩表中的 student_id 更新，即为级联更新。外键与级联更新适用于单机低并发，不适合分布式、高并发集群；级联更新是强阻塞，存在数据库更新风暴的风险；外键影响数据库的插入速度。</p><p>为什么不要用外键呢？大部分人可能会这样回答：</p><ol><li>增加了复杂性： a. 每次做 DELETE 或者 UPDATE 都必须考虑外键约束，会导致开发的时候很痛苦, 测试数据极为不方便; b. 外键的主从关系是定的，假如那天需求有变化，数据库中的这个字段根本不需要和其他表有关联的话就会增加很多麻烦。</li><li>对分库分表不友好：因为分库分表下外键是无法生效的。……</li></ol><p>但是,外键也是有很多好处的，比如：</p><ol><li>保证了数据库数据的一致性和完整性；</li><li>级联操作方便，减轻了程序代码量；<br>……<br>不要一股脑的就抛弃了外键这个概念，既然它存在就有它存在的道理，如果系统不涉及分库分表，并发量不是很高的情况还是可以考虑使用外键的。</li></ol><h5 id="什么是存储过程"><a href="#什么是存储过程" class="headerlink" title="什么是存储过程?"></a>什么是存储过程?</h5><p>一些 SQL 语句的集合，中间加了点逻辑控制语句。</p><p>存储过程在互联网公司应用不多，因为存储过程难以调试和扩展，而且没有移植性，还会消耗数据库资源。</p><h5 id="drop、delete-与-truncate-区别？"><a href="#drop、delete-与-truncate-区别？" class="headerlink" title="drop、delete 与 truncate 区别？"></a>drop、delete 与 truncate 区别？</h5><p>用法不同</p><ul><li>drop(丢弃数据): drop table 表名,在<strong>删除表</strong>的时候使用。</li><li>truncate (清空数据) : truncate table 表名 ，<strong>只删除表中的数据</strong>，再插入数据的时候自增长 id 又从 1 开始，在清空表中数据的时候使用。</li><li>delete（删除数据） : delete from 表名 where 列名&#x3D;值，删除<strong>某一行</strong>的数据，如果不加 where 子句和truncate table 表名作用类似。</li></ul><p>truncate 和不带 where子句的 delete、以及 drop 都会删除表内的数据，<br>但是 **truncate 和 delete 只删除数据不删除表的结构(定义)**，<br>执行 drop 语句，此表的结构也会删除，也就是执行drop 之后对应的表不复存在。</p><p>属于不同的数据库语言</p><ul><li>truncate 和 drop 属于 DDL(数据定义语言)语句，操作立即生效，原数据不放到 rollback segment 中，不能回滚，操作不触发 trigger。</li><li>delete 语句是 DML (数据库操作语言)语句，这个操作会放到 rollback segment 中，事务提交之后才生效。</li></ul><h6 id="DML-语句和-DDL-语句区别"><a href="#DML-语句和-DDL-语句区别" class="headerlink" title="DML 语句和 DDL 语句区别"></a>DML 语句和 DDL 语句区别</h6><ul><li>DML 是数据库操作语言（Data <strong>Manipulation</strong> Language）的缩写，是指对数据库中表记录的操作，主要包括表记录的插入、更新、删除和查询，是开发人员日常使用最频繁的操作。</li><li>DDL （Data <strong>Definition</strong> Language）是数据定义语言的缩写，简单来说，就是对数据库内部的对象进行创建、删除、修改的操作语言。它和 DML 语言的最大区别是 DML 只是对表内部数据的操作，而不涉及到表的定义、结构的修改，更不会涉及到其他对象。DDL 语句更多的被数据库管理员（DBA）所使用，一般的开发人员很少使用。另外，由于select不会对表进行破坏，所以有的地方也会把select单独区分开叫做数据库查询语言 DQL（Data Query Language）。</li></ul><h4 id="NoSQL基础知识总结"><a href="#NoSQL基础知识总结" class="headerlink" title="NoSQL基础知识总结"></a>NoSQL基础知识总结</h4><h5 id="NoSQL是什么"><a href="#NoSQL是什么" class="headerlink" title="NoSQL是什么"></a>NoSQL是什么</h5><p>Not Only SQL 泛指非关系型的数据库。<br>主要针对的是键值、文档以及图形类型数据存储。<br>并且，NoSQL 数据库天生支持分布式，数据冗余和数据分片等特性，旨在提供可扩展的高可用高性能数据存储解决方案。</p><h5 id="NoSQL-数据库有哪些类型？"><a href="#NoSQL-数据库有哪些类型？" class="headerlink" title="NoSQL 数据库有哪些类型？"></a>NoSQL 数据库有哪些类型？</h5><p>NoSQL 数据库主要可以分为下面四种类型：</p><ul><li>键值：键值数据库是一种较简单的数据库，其中每个项目都包含键和值。这是极为灵活的 NoSQL 数据库类型，因为应用可以完全控制 value 字段中存储的内容，没有任何限制。Redis 和 DynanoDB 是两款非常流行的键值数据库。</li><li>文档：文档数据库中的数据被存储在类似于 JSON（JavaScript 对象表示法）对象的文档中，非常清晰直观。每个文档包含成对的字段和值。这些值通常可以是各种类型，包括字符串、数字、布尔值、数组或对象等，并且它们的结构通常与开发者在代码中使用的对象保持一致。MongoDB 就是一款非常流行的文档数据库。</li><li>图形：图形数据库旨在轻松构建和运行与高度连接的数据集一起使用的应用程序。图形数据库的典型使用案例包括社交网络、推荐引擎、欺诈检测和知识图形。Neo4j 和 Giraph 是两款非常流行的图形数据库。’</li><li>宽列：宽列存储数据库非常适合需要存储大量的数据。</li></ul><h3 id="字符集详解"><a href="#字符集详解" class="headerlink" title="字符集详解"></a>字符集详解</h3><p>MySQL 字符编码集中有两套 UTF-8 编码实现：utf8 和 utf8mb4。</p><p>如果使用 utf8 的话，存储 emoji 符号和一些比较复杂的汉字、繁体字就会出错。</p><p>为什么会这样呢？</p><h4 id="字符编码是什么？"><a href="#字符编码是什么？" class="headerlink" title="字符编码是什么？"></a>字符编码是什么？</h4><p>字符编码是一种将字符集中的字符与计算机中的二进制数据相互转换的方法，可以看作是一种映射规则。也就是说，字符编码的目的是为了让计算机能够存储和传输各种文字信息。</p><p>乱码的本质：编码和解码时用了不同或者不兼容的字符集 。</p><h3 id="SQL"><a href="#SQL" class="headerlink" title="SQL"></a>SQL</h3><h4 id="SQL语法基础知识总结"><a href="#SQL语法基础知识总结" class="headerlink" title="SQL语法基础知识总结"></a>SQL语法基础知识总结</h4><h5 id="SQL-分类"><a href="#SQL-分类" class="headerlink" title="SQL 分类"></a>SQL 分类</h5><ul><li>DDL 数据定义语言<br>DDL 的核心指令是 CREATE、ALTER、DROP。<br>DDL 的主要功能是定义数据库对象。</li><li>DML 数据操纵语言<br>DML 的主要功能是 访问数据，因此其语法都是以读写数据库为主。<br>DML 的核心指令是 INSERT、UPDATE、DELETE、SELECT。这四个指令合称 CRUD(Create, Read, Update, Delete)，即增删改查。</li><li>TCL 事务控制语言<br>TCL 的核心指令是 COMMIT、ROLLBACK。</li><li>DCL 数据控制语言<br>数据控制语言 (Data Control Language, DCL) 是一种可对数据访问权进行控制的指令，它可以控制特定用户账户对数据表、查看表、预存程序、用户自定义函数等数据库对象的控制权。<br>DCL 的核心指令是 GRANT、REVOKE。DCL 以控制用户的访问权限为主，因此其指令作法并不复杂，可利用 DCL 控制的权限有：CONNECT、SELECT、INSERT、UPDATE、DELETE、EXECUTE、USAGE、REFERENCES。</li></ul><h3 id="MySQL"><a href="#MySQL" class="headerlink" title="MySQL"></a>MySQL</h3><h4 id="整数类型的-UNSIGNED-属性有什么用？"><a href="#整数类型的-UNSIGNED-属性有什么用？" class="headerlink" title="整数类型的 UNSIGNED 属性有什么用？"></a>整数类型的 UNSIGNED 属性有什么用？</h4><p>MySQL 中的整数类型可以使用可选的 UNSIGNED 属性来表示不允许负值的无符号整数</p><h4 id="CHAR-和-VARCHAR-的区别是什么？"><a href="#CHAR-和-VARCHAR-的区别是什么？" class="headerlink" title="CHAR 和 VARCHAR 的区别是什么？"></a>CHAR 和 VARCHAR 的区别是什么？</h4><p>CHAR 是<strong>定长</strong>字符串，VARCHAR 是<strong>变长</strong>字符串。</p><h4 id="VARCHAR-100-和-VARCHAR-10-的区别是什么？"><a href="#VARCHAR-100-和-VARCHAR-10-的区别是什么？" class="headerlink" title="VARCHAR(100)和 VARCHAR(10)的区别是什么？"></a>VARCHAR(100)和 VARCHAR(10)的区别是什么？</h4><p>VARCHAR(100)和 VARCHAR(10)都是变长类型，表示能存储最多 100 个字符和 10 个字符。</p><h4 id="DECIMAL-和-FLOAT-DOUBLE-的区别是什么？"><a href="#DECIMAL-和-FLOAT-DOUBLE-的区别是什么？" class="headerlink" title="DECIMAL 和 FLOAT&#x2F;DOUBLE 的区别是什么？"></a>DECIMAL 和 FLOAT&#x2F;DOUBLE 的区别是什么？</h4><p>DECIMAL 和 FLOAT 的区别是：DECIMAL 是定点数，FLOAT&#x2F;DOUBLE 是浮点数。<br>DECIMAL 可以存储<strong>精确</strong>的小数值，FLOAT&#x2F;DOUBLE 只能存储<strong>近似</strong>的小数值。</p><h5 id="DATETIME-和-TIMESTAMP-的区别是什么？"><a href="#DATETIME-和-TIMESTAMP-的区别是什么？" class="headerlink" title="DATETIME 和 TIMESTAMP 的区别是什么？"></a>DATETIME 和 TIMESTAMP 的区别是什么？</h5><p>DATETIME 类型没有时区信息<br>TIMESTAMP 和时区有关。</p><h4 id="NULL-和-‘’-的区别是什么"><a href="#NULL-和-‘’-的区别是什么" class="headerlink" title="NULL 和 ‘’ 的区别是什么?"></a>NULL 和 ‘’ 的区别是什么?</h4><ul><li>NULL 代表一个不确定的值,就算是两个 NULL,它俩也不一定相等。<br>例如，SELECT NULL&#x3D;NULL的结果为 false，但是在我们使用DISTINCT,GROUP BY,ORDER BY时,NULL又被认为是相等的</li><li>‘’的长度是 0，是不占用空间的，而NULL 是需要占用空间的。</li><li>NULL 会影响聚合函数的结果。</li><li>符。而’’是可以使用这些比较运算符的。</li></ul><p>综上，MySQL 不建议使用 NULL 作为列默认值。</p><h4 id="Boolean-类型如何表示？"><a href="#Boolean-类型如何表示？" class="headerlink" title="Boolean 类型如何表示？"></a>Boolean 类型如何表示？</h4><p>MySQL 中没有专门的布尔类型，而是用 TINYINT(1) 类型来表示布尔值。TINYINT(1) 类型可以存储 0 或 1，分别对应 false 或 true。</p><h3 id="MySQL基础架构"><a href="#MySQL基础架构" class="headerlink" title="MySQL基础架构"></a>MySQL基础架构</h3><h3 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a>Redis</h3><h2 id="常用框架"><a href="#常用框架" class="headerlink" title="常用框架"></a>常用框架</h2><h2 id="系统设计"><a href="#系统设计" class="headerlink" title="系统设计"></a>系统设计</h2><h2 id="分布式"><a href="#分布式" class="headerlink" title="分布式"></a>分布式</h2><h2 id="高性能"><a href="#高性能" class="headerlink" title="高性能"></a>高性能</h2><h2 id="高可用"><a href="#高可用" class="headerlink" title="高可用"></a>高可用</h2><h3 id="前端"><a href="#前端" class="headerlink" title="前端"></a>前端</h3><h4 id="Axios"><a href="#Axios" class="headerlink" title="Axios"></a>Axios</h4><p>Axios 是一个流行的基于 Promise 的 HTTP 客户端，用于浏览器和 Node.js 环境。它使得在 JavaScript 中发送 AJAX 请求变得更加简单和便捷。<br>使用 Axios，你可以轻松地执行各种 HTTP 请求，例如 GET、POST 等，并处理响应数据。</p><h4 id="Java中session和cookie的使用"><a href="#Java中session和cookie的使用" class="headerlink" title="Java中session和cookie的使用"></a>Java中session和cookie的使用</h4><h5 id="Session简单介绍"><a href="#Session简单介绍" class="headerlink" title="Session简单介绍"></a>Session简单介绍</h5><blockquote><p>[!TIP]<br>session通常是基于cookie实现的,每一个session都会有一个sessionid保存在浏览器的cookie中</p></blockquote><p>session和cookie都是Java开发中实现会话跟踪的技术。</p><p>在WEB开发中，服务器可以为每个用户浏览器创建一个会话对象（session对象），注意：一个浏览器独占一个session对象(默认情况下)。</p><p>因此，在需要保存用户数据时，服务器程序可以把用户数据写到用户浏览器独占的session中，当用户使用浏览器访问其它程序时，其它程序可以从用户的session中取出该用户的数据，为用户服务。</p><h5 id="Cookie简单介绍"><a href="#Cookie简单介绍" class="headerlink" title="Cookie简单介绍"></a>Cookie简单介绍</h5><p>浏览器与WEB服务器之间是使用HTTP协议进行通信的，当某个用户发出页面请求时，WEB服务器只是简单的进行响应，然后就关闭与该用户的连接。<br>因此当一个请求发送到WEB服务器时，无论其是否是第一次来访，服务器都会把它当作第一次来对待，这样的不好之处可想而知。为了弥补这个缺陷，Netscape开发出了cookie这个有效的工具来保存某个用户的识别信息，因此人们昵称为“小甜饼”。</p><p>cookies是一种WEB服务器通过浏览器在访问者的硬盘上存储信息的手段：Netscape Navigator使用一个名为cookies.txt本地文件保存从所有站点接收的Cookie信息；而IE浏览器把Cookie信息保存在类似于C:\windows\cookies的目录下。当用户再次访问某个站点时，服务端将要求浏览器查找并返回先前发送的Cookie信息，来识别这个用户。</p><h5 id="⭐️Session和Cookie的主要区别"><a href="#⭐️Session和Cookie的主要区别" class="headerlink" title="⭐️Session和Cookie的主要区别"></a>⭐️Session和Cookie的主要区别</h5><p>Cookie 和 Session 都是用来跟踪浏览器用户身份的会话方式，但是两者的应用场景不太一样。</p><p>Cookie一般用来保存用户信息</p><ol><li><p>我们在 Cookie 中保存已经登录过得用户信息，下次访问网站的时候页面可以自动帮你登录的一些基本信息给填了</p></li><li><p>一般的网站都会有保持登录也就是说下次你再访问网站的时候就不需要重新登录了<br>这是因为用户登录的时候我们可以存放了一个 Token 在 Cookie 中，下次登录的时候只需要根据 Token 值来查找用户即可<br>(为了安全考虑，重新登录一般要将 Token 重写)</p></li><li><p>登录一次网站后访问网站其他页面不需要重新登录。Session 的主要作用就是通过服务端记录用户的状态。<br>典型的场景是购物车，当你要添加商品到购物车的时候，系统不知道是哪个用户操作的，因为 HTTP 协议是无状态的。<br>服务端给特定的用户创建特定的 Session 之后就可以标识这个用户并且跟踪这个用户了。</p></li></ol><p>Cookie 数据保存在客户端(浏览器端)，Session 数据保存在服务器端。</p><p>Cookie 存储在客户端中，而 Session 存储在服务器上，相对来说 Session 安全性更高。<br>如果使用 Cookie 的一些敏感信息不要写入 Cookie 中，最好能将 Cookie 信息加密然后使用到的时候再去服务器端解密。</p><h5 id="Session实现原理"><a href="#Session实现原理" class="headerlink" title="Session实现原理"></a>Session实现原理</h5><p>服务器创建session出来后，会把session的id号，以cookie的形式回写给客户机。<br>这样，只要客户机的浏览器不关，再去访问服务器时，都会带着session的id号去，服务器发现客户机浏览器带session id过来了，就会使用内存中与之对应的session为之服务。</p><h5 id="Session的创建和销毁时机"><a href="#Session的创建和销毁时机" class="headerlink" title="Session的创建和销毁时机"></a>Session的创建和销毁时机</h5><ul><li>session对象的创建</li></ul><p>在程序中第一次调用request.getSession()方法时就会创建一个新的Session，可以用isNew()方法来判断Session是不是新创建的</p><ul><li>session对象的销毁</li></ul><p>session对象默认30分钟没有使用，则服务器会自动销毁session，在web.xml文件中可以手工配置session的失效时间</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>黑马点评项目记录</title>
      <link href="/undefined/c6c80d57.html"/>
      <url>/undefined/c6c80d57.html</url>
      
        <content type="html"><![CDATA[<h2 id="基于-Session-短信登录"><a href="#基于-Session-短信登录" class="headerlink" title="基于 Session 短信登录"></a>基于 Session 短信登录</h2><ul><li>@RequestBody注解是用来接收前端发送过来的json字符串</li></ul><h3 id="发送短信验证码"><a href="#发送短信验证码" class="headerlink" title="发送短信验证码"></a>发送短信验证码</h3><p>用户提交手机号，服务器生成验证码并保存到session,然后将验证码发给用户</p><h3 id="短信验证码登录和注册"><a href="#短信验证码登录和注册" class="headerlink" title="短信验证码登录和注册"></a>短信验证码登录和注册</h3><p>用户提交手机号和验证码，服务器先校验验证码，然后根据手机号去数据库查询用户，若不存在，则创建新用户，然后保存用户信息到session</p><ul><li>前台发送的数据格式是json的样式 后台要用@RequestBody注解 实现用LoginFormDTO实体类接收</li><li>登录成功之后要把用户信息存储到session中。</li></ul><h3 id="登录校验-验证登录状态"><a href="#登录校验-验证登录状态" class="headerlink" title="登录校验(验证登录状态)"></a>登录校验(验证登录状态)</h3><p>用户请求(request)中携带cookie(cookie中带有sessionid,而登录的凭证就是sessionid就保存在cookie中)</p><p>服务器从session中获取用户 获取到之后将用户缓存到<code>ThreadLocal</code>中,方便后续的使用</p><blockquote><p>[!TIP]<br>在业务中用户的每个请求都是一个独立的线程，所以不能将用户信息保存到本地变量中，这样会出现多线程并发修改的安全问题，因此要使用ThreadLocal技术</p></blockquote><h4 id="登录拦截校验功能"><a href="#登录拦截校验功能" class="headerlink" title="登录拦截校验功能"></a>登录拦截校验功能</h4><ul><li>⚠️有有很多controller(业务)都需要校验登录状态，不能在每一个controller中都写一遍校验登录状态的业务代码，所以引入spiringmvc中的拦截器，拦截器可以在所有controller执行之前执行，将校验用户登录的流程都统一放在拦截器中</li><li>同时要注意将拦截到的用户信息传递给每一个controller的时候不能出现线程安全问题，所以用到<code>ThreadLocal</code>,让用户的每一个请求都拥有独立的线程。然后每个controller都从对应的<code>ThreadLocal</code>中取出用户即可。</li></ul><h4 id="隐藏用户敏感信息"><a href="#隐藏用户敏感信息" class="headerlink" title="隐藏用户敏感信息"></a>隐藏用户敏感信息</h4><p>在<code>/me</code>中,是从UserHolder中获取的用户信息直接返回，而UserHolder是从拦截器session中取出来的，</p><p>而session中的信息是在登录业务中存入的</p><p>这里会有两个问题：</p><p>session是tomcat的内存空间,存太多信息也会增加服务器的负担</p><p>登录校验返回的信息有些太多了，时间密码等敏感信息不需要返回。</p><ul><li>所以定义UserDTO类来简化存入session的用户信息，即在登录业务的时候将User转为UserDTO</li></ul><h4 id="基于session登录的集群的session共享问题"><a href="#基于session登录的集群的session共享问题" class="headerlink" title="基于session登录的集群的session共享问题"></a>基于session登录的集群的session共享问题</h4><p>问题：为了服务器的负载均衡，通常会配置多个tomcat服务器进行轮循访问，而多台tomcat不共享session的存储空间(每个tomcat有独立的session)，当请求切换到不同的tomcat服务器的时候会导致用户登录数据的丢失</p><p>解决方法：让session共享,且应满足：</p><ol><li>数据共享(让任何一台tomcat访问)</li><li>内存存储</li><li>key，value结构</li></ol><p>(即使用Redis代替session)</p><h4 id="Redis代替session"><a href="#Redis代替session" class="headerlink" title="Redis代替session"></a>Redis代替session</h4><h5 id="发送短信验证码业务"><a href="#发送短信验证码业务" class="headerlink" title="发送短信验证码业务"></a>发送短信验证码业务</h5><p>保存验证码到Redis，且要设置一个有效期</p><ul><li>以手机号为key(为了确保每一个手机号都有不一样的key,且有助于后面根据手机号获取验证码) 验证码为value</li></ul><h5 id="短信验证码登录、注册业务"><a href="#短信验证码登录、注册业务" class="headerlink" title="短信验证码登录、注册业务"></a>短信验证码登录、注册业务</h5><ul><li>保存用户信息到redis,key用随机token(使用UUID生成)</li><li>value是用户对象,保存对象可以使用string结构(将java对象序列化为json字符串,优点是比较直观)或hash结构(再次将value分为key和value两个部分，将对象中的每个字段独立存储,优点是可以针对单个字段做crud，且内存占用更少),所以优先推荐使用hash结构</li><li>然后需要将token作为登录凭证(使用手机号作为key的话有泄露的风险)，登录之后需要手动把生成的token返回给前端</li></ul><h5 id="token有效期的设置"><a href="#token有效期的设置" class="headerlink" title="token有效期的设置"></a>token有效期的设置</h5><ul><li>更新校验登录状态的代码（写在拦截器中），在里面设置token的更新逻辑</li></ul><h5 id="登录拦截器的优化"><a href="#登录拦截器的优化" class="headerlink" title="登录拦截器的优化"></a>登录拦截器的优化</h5><ul><li>问题1： 此时的拦截器只拦截了部分请求，所以并不是所有请求都能刷新token有效期</li></ul><p>solution：在现在的拦截器之前再加一个拦截器，在这个拦截器中拦截一切路径，但只做刷新token和保存用户信息的工作，第二个用户才做登录拦截</p><ul><li>问题2: 控制拦截器的先后顺序</li></ul><p>solution：在注册拦截器的时候添加.order</p><h2 id="商户查询缓存"><a href="#商户查询缓存" class="headerlink" title="商户查询缓存"></a>商户查询缓存</h2><h3 id="什么是缓存？-cache"><a href="#什么是缓存？-cache" class="headerlink" title="什么是缓存？(cache)"></a>什么是缓存？(cache)</h3><p>缓存就是数据交换的缓冲区，是存储数据的临时的地方，读写性能较高</p><h4 id="如何使用缓存？"><a href="#如何使用缓存？" class="headerlink" title="如何使用缓存？"></a>如何使用缓存？</h4><p>实际开发中,会构筑多级缓存来使系统运行速度进一步提升,例如:本地缓存与redis中的缓存并发使用</p><p><strong>浏览器缓存</strong>：主要是存在于浏览器端的缓存</p><p><strong>应用层缓存</strong>: 可以分为tomcat本地缓存，比如之前提到的map，或者是使用redis作为缓存</p><p><strong>数据库缓存</strong>: 在数据库中有一片空间是 buffer pool，增改查数据都会先加载到mysql的缓存中</p><p><strong>CPU缓存</strong>: 当代计算机最大的问题是 cpu性能提升了，但内存读写速度没有跟上，所以为了适应当下的情况，增加了cpu的L1，L2，L3级的缓存</p><h4 id="缓存的成本"><a href="#缓存的成本" class="headerlink" title="缓存的成本"></a>缓存的成本</h4><ul><li>数据一致性</li><li>代码维护</li><li>运维成本</li><li>硬件成本</li></ul><h3 id="添加商户缓存"><a href="#添加商户缓存" class="headerlink" title="添加商户缓存"></a>添加商户缓存</h3><h4 id="缓存模型和思路"><a href="#缓存模型和思路" class="headerlink" title="缓存模型和思路"></a>缓存模型和思路</h4><p>标准的操作方式就是查询数据库之前先查询缓存</p><p>如果缓存数据存在，则直接从缓存中返回</p><p>如果缓存数据不存在，再查询数据库，然后将数据存入redis,然后将信息返回</p><h3 id="缓存更新策略"><a href="#缓存更新策略" class="headerlink" title="缓存更新策略"></a>缓存更新策略</h3><p>缓存更新是redis为了节约内存而设计出来的一个东西，主要是因为内存数据宝贵，当我们向redis插入太多数据，此时就可能会导致缓存中的数据过多，所以redis会对部分数据进行更新，或者把他叫为淘汰更合适</p><p>常见的几个策略如下：</p><p><strong>内存淘汰：</strong>redis自动进行，当redis内存达到咱们设定的max-memery的时候，会自动触发淘汰机制，淘汰掉一些不重要的数据(可以自己设置策略方式),一致性比较差,无维护成本。</p><p><strong>超时剔除：</strong>当我们给redis设置了过期时间ttl之后，redis会将超时的数据进行删除，方便咱们继续使用缓存。一致性的强弱取决于ttl时间，一致性一般，低维护成本(只要在缓存逻辑上添加一个超时)。</p><p><strong>主动更新：</strong>我们可以手动调用方法把缓存删掉，通常用于解决缓存和数据库不一致问题。一致性好，维护成本较高。</p><p>具体选哪个方法主要看业务场景。</p><h3 id="数据库缓存不一致解决方案"><a href="#数据库缓存不一致解决方案" class="headerlink" title="数据库缓存不一致解决方案"></a>数据库缓存不一致解决方案</h3><p>由于我们的<strong>缓存的数据源来自于数据库</strong>,而数据库的<strong>数据是会发生变化的</strong>,因此,如果当数据库中<strong>数据发生变化,而缓存却没有同步</strong>,此时就会有<strong>一致性问题存在</strong>,其后果是:</p><p>用户使用缓存中的过时数据,就会产生类似多线程数据安全问题,从而影响业务,产品口碑等;怎么解决呢？有如下几种方案</p><p>Cache Aside Pattern（旁路缓存） 人工编码方式：缓存调用者在更新完数据库后再去更新缓存，也称之为双写方案✅</p><p>Read&#x2F;Write Through Pattern : 由系统本身完成，数据库与缓存的问题交由系统本身去处理</p><p>Write Behind Caching Pattern ：调用者只操作缓存，其他线程去异步处理数据库，实现最终一致</p><h3 id="数据库和缓存不一致采用什么方案"><a href="#数据库和缓存不一致采用什么方案" class="headerlink" title="数据库和缓存不一致采用什么方案"></a>数据库和缓存不一致采用什么方案</h3><p>综合考虑使用方案一，但是方案一调用者如何处理呢？这里有几个问题</p><p>操作缓存和数据库时有三个问题需要考虑：</p><p>如果采用第一个方案，那么假设我们每次操作数据库后，都操作缓存，但是中间如果没有人查询，那么这个更新动作实际上只有最后一次生效(发生了写远大于读的操作,则无效写的操作很多)，中间的更新动作意义并不大，我们可以把缓存删除，等待再次查询时，将缓存中的数据加载出来</p><ul><li><p>删除缓存还是更新缓存？</p><ul><li>更新缓存：每次更新数据库都更新缓存，无效写操作较多❎</li><li>删除缓存：更新数据库时让缓存失效，查询时再更新缓存✅</li></ul></li><li><p>如何保证缓存与数据库的操作的<strong>同时</strong>成功或失败？（保证事务的原子性）</p><ul><li>单体系统，将缓存与数据库操作放在一个事务</li><li>分布式系统，利用<code>TCC</code>(微服务内容)等分布式事务方案</li></ul></li></ul><blockquote><p>[!TIP]<br>事务的原子性是指事务中的所有操作要么全部执行成功，要么全部执行失败回滚，没有中间状态。原子性保证了事务的完整性和一致性，即事务中的所有操作要么都生效，要么都不生效，不会出现部分操作生效而部分操作失败的情况。</p></blockquote><p>应该具体操作缓存还是操作数据库，我们应当是先操作数据库，再删除缓存，原因在于，如果你选择第一种方案，在两个线程并发来访问时，假设线程1先来，他先把缓存删了，此时线程2过来，他查询缓存数据并不存在，此时他写入缓存，当他写入缓存后，线程1再执行更新动作时，实际上写入的就是旧的数据，新的数据被旧数据覆盖了。</p><ul><li>先操作缓存还是先操作数据库？(线程安全性问题)<ul><li>先删除缓存，再操作数据库</li><li>先操作数据库，再删除缓存✅(该方案的出现问题的可能性较低，因为操作数据库的时间要远长于操作缓存)</li></ul></li></ul><h3 id="缓存更新策略方案的最佳实践总结"><a href="#缓存更新策略方案的最佳实践总结" class="headerlink" title="缓存更新策略方案的最佳实践总结"></a>缓存更新策略方案的最佳实践总结</h3><h4 id="低一致性需求"><a href="#低一致性需求" class="headerlink" title="低一致性需求"></a>低一致性需求</h4><ul><li>使用Redis自带的内存淘汰机制</li></ul><h4 id="高一致性需求：主动更新，并以超时剔除作为兜底方案"><a href="#高一致性需求：主动更新，并以超时剔除作为兜底方案" class="headerlink" title="高一致性需求：主动更新，并以超时剔除作为兜底方案"></a>高一致性需求：主动更新，并以超时剔除作为兜底方案</h4><ul><li>读操作：<ul><li>缓存命中则直接返回</li><li>缓存未命中则查询数据库，并写入缓存，设定超时时间</li></ul></li><li>写操作：<ul><li>先写数据库，然后再删除缓存</li><li>要确保数据库与缓存操作的原子性</li></ul></li></ul><h3 id="缓存穿透"><a href="#缓存穿透" class="headerlink" title="缓存穿透"></a>缓存穿透</h3><p>缓存穿透 ：缓存穿透是指客户端请求的数据在缓存中和数据库中都不存在，这样缓存永远不会生效，这些请求都会打到数据库。(只要有请求那么一定会到达数据库)</p><h4 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h4><p>常见的解决方案有两种：</p><ul><li>缓存空对象<ul><li>优点：实现简单，维护方便</li><li>缺点：<ul><li>额外的内存消耗</li><li>可能造成短期的不一致</li></ul></li></ul></li><li>布隆过滤<ul><li>优点：内存占用较少，没有多余key</li><li>缺点：<ul><li>实现复杂</li><li>存在误判可能</li></ul></li></ul></li></ul><p><strong>缓存空对象思路分析：</strong>当我们客户端访问不存在的数据时，先请求redis，但是此时redis中没有数据，此时会访问到数据库，但是数据库中也没有数据，这个数据穿透了缓存，直击数据库，我们都知道数据库能够承载的并发不如redis这么高，如果大量的请求同时过来访问这种不存在的数据，这些请求就都会访问到数据库，简单的解决方案就是哪怕这个数据在数据库中也不存在，我们也把这个数据存入到redis中去，这样，下次用户过来访问这个不存在的数据，那么在redis中也能找到这个数据就不会进入到缓存了</p><p><strong>布隆过滤器：</strong>在客户端和缓存之间再添加一层布隆过滤器的拦截，请求来了之后让布隆过滤器判断这个数据是否存在，若不存在则直接返回,若存在则放行到缓存，后续的流程不变</p><p>这种方式优点在于节约内存空间，存在误判，误判原因在于：布隆过滤器是哈希思想，只要哈希思想，就可能存在哈希冲突</p><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>缓存穿透产生的原因是什么？</p><ul><li>用户请求的数据在缓存中和数据库中都不存在，不断发起这样的请求，给数据库带来巨大压力</li></ul><p>缓存穿透的解决方案有哪些？</p><p>被动方案（亡羊补牢）:</p><ul><li>缓存null值</li><li>布隆过滤</li></ul><p>主动方案（未雨绸缪）:</p><ul><li>增强id的复杂度，避免被猜测id规律</li><li>做好数据的基础格式校验</li><li>加强用户权限校验</li><li>做好热点参数的限流</li></ul><h3 id="缓存雪崩"><a href="#缓存雪崩" class="headerlink" title="缓存雪崩"></a>缓存雪崩</h3><p>缓存雪崩：缓存中的大量key同时失效或者缓存服务器Redis突然宕机，导致大量请求到达数据库，给服务器带来巨大压力</p><h4 id="解决思路"><a href="#解决思路" class="headerlink" title="解决思路"></a>解决思路</h4><ul><li>给不同的Key的TTL添加随机值(解决key同时失效)</li><li>利用Redis集群提高服务的可用性(解决Redis宕机)</li><li>给缓存业务添加降级限流策略</li><li>给业务添加多级缓存(可以在反向代理nginx等等部分也建立缓存，类似于多层防弹衣)</li></ul><h3 id="缓存击穿-热点key问题"><a href="#缓存击穿-热点key问题" class="headerlink" title="缓存击穿(热点key问题)"></a>缓存击穿(热点key问题)</h3><p>缓存击穿问题也叫热点Key问题，就是一个被高并发访问并且缓存重建业务较复杂的key突然失效了，无数的请求访问会在瞬间给数据库带来巨大的冲击(大量线程同时缓存重建)。</p><p>常见的解决方案:</p><ul><li><p>互斥锁(排队依次重建)</p></li><li><p>逻辑过期(不是真的过期 而是由程序员判断是否真的过期,本质上是设置热点key永久有效)</p></li></ul><p>方案分析：我们之所以会出现这个缓存击穿问题，<strong>主要原因是在于我们对key设置了过期时间</strong>，假设我们不设置过期时间，其实就不会有缓存击穿的问题，但是不设置过期时间，这样数据不就一直占用我们内存了吗，我们可以采用逻辑过期方案。</p><p>我们把过期时间设置在redis热点key的value中，注意：这个过期时间并不会直接作用于redis，而是我们后续通过逻辑去处理。实际流程如下:</p><p>假设线程1去查询缓存，然后从value中判断当前的数据是否过期(如果直接在缓存中未命中，则直接返回空)</p><p>如果未过期，那么直接返回信息。</p><p>如果过期了，此时线程1去尝试获得互斥锁<br>  如果获取失败了，那么代表以及有线程在缓存重建，线程1直接返回旧信息<br>  如果获取成功了，那么线程1会开启另外一个独立线程2去执行缓存重建，自己依旧返回旧信息。</p><p>假设现在线程3过来访问，由于线程线程2持有着锁，所以线程3无法获得锁，线程3也直接返回数据，只有等到新开的线程2把重建数据构建完后，其他线程才能走返回正确的数据。</p><p>这种方案巧妙在于，异步的构建缓存，缺点在于在构建完缓存之前，返回的都是脏数据。</p><h4 id="两种方案的对比"><a href="#两种方案的对比" class="headerlink" title="两种方案的对比"></a>两种方案的对比</h4><p>两种方案都是在解决缓存重建过程中的并发问题</p><p><strong>互斥锁方案：</strong> 强调一致性</p><p>由于保证了互斥性，所以数据一致，且实现简单，因为仅仅只需要加一把锁而已，也没其他的事情需要操心，所以没有额外的内存消耗，</p><p>缺点在于有锁就有死锁问题的发生，且只能串行执行性能肯定受到影响</p><p><strong>逻辑过期方案：</strong> 强调可用性</p><p>线程读取过程中不需要等，性能好，有一个额外的线程持有锁去进行重构数据，</p><p>但是在重构数据完成前，其他的线程只能返回之前的数据，且实现起来麻烦</p><h3 id="利用互斥锁解决缓存击穿问题"><a href="#利用互斥锁解决缓存击穿问题" class="headerlink" title="利用互斥锁解决缓存击穿问题"></a>利用互斥锁解决缓存击穿问题</h3><p>核心思路：相较于原来从缓存中查询不到数据后直接查询数据库而言，现在的方案是进行查询之后，如果从缓存没有查询到数据，则进行互斥锁的获取，获取互斥锁后，判断是否获得到了锁，如果没有获得到，则休眠，过一会再进行尝试，直到获取到锁为止，才能进行查询。</p><p><strong>操作锁的代码：</strong></p><p>核心思路就是利用redis的setnx方法来表示获取锁（锁其实就是redis中存储的一个key），<br>该方法含义是redis中如果没有这个key，则插入成功，返回1，在stringRedisTemplate中返回true，、如果有这个key则插入失败，则返回0，<br>在stringRedisTemplate返回false，我们可以通过true，或者是false，来表示是否有线程成功插入key，成功插入的key的线程我们认为他就是获得到锁的线程。</p><h3 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h3><p>在 Java 中，Boolean 是一个包装类，用于封装基本数据类型 boolean 的值。<br>当使用 Boolean 类型进行自动拆箱（Unboxing）时，如果 Boolean 对象的值为 null，就会触发 NullPointerException 异常。</p><p>例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Boolean</span> <span class="variable">boolObj</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"><span class="type">boolean</span> <span class="variable">boolPrimitive</span> <span class="operator">=</span> boolObj; <span class="comment">// 自动拆箱，触发 NullPointerException</span></span><br></pre></td></tr></table></figure><p>在上面的例子中，当试图将 null 的 Boolean 对象自动拆箱为基本数据类型 boolean 时，会导致 NullPointerException 异常。</p><p>为了避免这种情况，应该在进行自动拆箱之前先检查 Boolean 对象是否为 null，或者使用条件语句处理可能为 null 的情况。</p><h3 id="利用逻辑过期解决缓存击穿问题"><a href="#利用逻辑过期解决缓存击穿问题" class="headerlink" title="利用逻辑过期解决缓存击穿问题"></a>利用逻辑过期解决缓存击穿问题</h3><ul><li>添加过期时间</li></ul><p>因为现在redis中存储的数据的value需要带上过期时间，此时要么你去修改原来的实体类，但是这个方案修改了原来的代码，不符合代码的ocp(开闭原则)。</p><p>因此我们选择新建一个实体类，此时又有两种选择，一个是继承原来的shop类，优点是较为简单，但是依然需要对原来的代码进行少量修改；而另一种方案是在该类中新建一个存储数据的对象。</p><ul><li>开启缓存重建的线程的时候调用线程池</li></ul><h3 id="缓存工具封装-⭐️"><a href="#缓存工具封装-⭐️" class="headerlink" title="缓存工具封装(⭐️)"></a>缓存工具封装(⭐️)</h3><p>基于StringRedisTemplate封装一个缓存工具类，满足下列需求：</p><p>存：</p><ul><li>方法1：将<strong>任意Java对象</strong>序列化为json并存储在string类型的key中，并且可以<strong>设置TTL过期时间</strong>(往redis中存数据)</li><li>方法2：将任意Java对象序列化为json并存储在string类型的key中，并且可以<strong>设置逻辑过期时间</strong>，用于处理缓存击穿问题</li></ul><p>取：</p><ul><li>方法3：根据指定的key查询缓存，并反序列化为指定类型，利用缓存空值的方式解决缓存穿透问题</li><li>方法4：根据指定的key查询缓存，并反序列化为指定类型，需要利用逻辑过期解决缓存击穿问题</li></ul><p>方法1、3用来解决普通缓存问题；方法2、4是用来解决热点key问题的</p><h2 id="⭐️优惠券秒杀"><a href="#⭐️优惠券秒杀" class="headerlink" title="⭐️优惠券秒杀"></a>⭐️优惠券秒杀</h2><h3 id="全局唯一ID"><a href="#全局唯一ID" class="headerlink" title="全局唯一ID"></a>全局唯一ID</h3><p><strong>全局ID生成器</strong>，是一种在分布式系统下用来生成全局唯一ID的工具，一般要满足下列特性：</p><ul><li>唯一性</li><li>高可用</li><li>高性能</li><li>递增性</li><li>安全性</li></ul><h3 id="Redis实现全局唯一ID"><a href="#Redis实现全局唯一ID" class="headerlink" title="Redis实现全局唯一ID"></a>Redis实现全局唯一ID</h3><p>为了增加ID的安全性，我们可以不直接使用Redis自增的数值，而是拼接一些其它信息：</p><p>ID的组成部分(⭐️)：</p><ul><li><p>符号位：1bit，永远为0</p></li><li><p>时间戳：31bit，以秒为单位，可以使用69年</p></li><li><p>序列号：32bit，秒内的计数器，支持每秒产生2^32个不同ID</p></li></ul><p>在序列号上添加日期部分(每天一个key)可以避免序列号数量超过redis的存储上限（2^64,其实此处最多只能达到2^32，其次还可以便于基于日期部分统计每一天的下单量。)</p><h3 id="全局唯一ID的生成策略"><a href="#全局唯一ID的生成策略" class="headerlink" title="全局唯一ID的生成策略"></a>全局唯一ID的生成策略</h3><ul><li>UUID</li><li>Redis自增</li><li>snowflake(雪花)算法</li><li>数据库自增(用一张额外的表来专门实现自增)</li></ul><h3 id="优惠券-这一块细节很多，可以作为项目的难点"><a href="#优惠券-这一块细节很多，可以作为项目的难点" class="headerlink" title="优惠券(这一块细节很多，可以作为项目的难点)"></a>优惠券(这一块细节很多，可以作为项目的难点)</h3><h4 id="普通券和秒杀券"><a href="#普通券和秒杀券" class="headerlink" title="普通券和秒杀券"></a>普通券和秒杀券</h4><h4 id="库存超卖问题"><a href="#库存超卖问题" class="headerlink" title="库存超卖问题"></a>库存超卖问题</h4><h5 id="问题原因"><a href="#问题原因" class="headerlink" title="问题原因"></a>问题原因</h5><p>假设线程1过来查询库存，判断出来库存大于1，正准备去扣减库存，但是还没有来得及去扣减，此时线程2过来，线程2也去查询库存，发现这个数量一定也大于1，那么这两个线程都会去扣减库存，最终多个线程相当于一起去扣减库存，此时就会出现库存的超卖问题。</p><h5 id="解决方法-1"><a href="#解决方法-1" class="headerlink" title="解决方法"></a>解决方法</h5><p>悲观锁：认为线程安全问题一定会发生，因此在操作数据之前一定要先获取锁，确保线程串行执行</p><p>乐观锁：认为线程安全问题不一定会发生，因此不加所锁，只是在数据更新时才去判断有没有别的线程对数据进行了修改。</p><ul><li>如果没有修改则认为是安全的,自己更新数据</li><li>如果已被其他线程修改过说明发生了安全问题，此时可以重试或异常</li></ul><h5 id="乐观锁CAS法解决超卖问题"><a href="#乐观锁CAS法解决超卖问题" class="headerlink" title="乐观锁CAS法解决超卖问题"></a>乐观锁CAS法解决超卖问题</h5><p>乐观锁的关键是判断之前查询的数据是否被修改过，常见的方法有两种</p><ul><li>版本号法:简单来说就是给数据添加一个版本号字段，一旦执行修改数据的操作，那么同时就要修改版本号，修改的之前要确认此时的版本号和查询数据库的时候的版本号是否一致，一致则说明在查询和修改的这段时间内没有其他线程修改过数据,不一致则不执行操作</li><li>CAS法(compare and switch):版本号法的简化，由于每次查询和修改的时候版本号和数据数量都做了修改，那么就不用多此一举多设置一个版本号，只要在修改之前再一次比较一下当前的数量是否和查询时的数量一致即可。</li></ul><h4 id="一人一单问题"><a href="#一人一单问题" class="headerlink" title="一人一单问题"></a>一人一单问题</h4><p>只需要在秒杀业务中添加一个判断：在判断库存是否足够之后再根据优惠卷id和用户id查询是否已经下过这个订单，如果下过这个订单，则不再下单，否则进行下单。</p><p>也会出现高并发问题,需要给减库存操作和创建订单操作添加悲观锁,要注意因为是一人一单，所以只要对userid加锁，而不用对整个方法加锁；这里还有一个细节，在判断userid前后是否一致的时候，由于是一个字符串对象，所以必须要对该对象调用.intern()方法才能到字符串常量池中去找原先的对象，否则就会new一个新的对象，导致即使数值一致，但判断依然是不一致（因为是两个不同的对象）</p><h3 id="集群环境下的并发问题-syn锁失效"><a href="#集群环境下的并发问题-syn锁失效" class="headerlink" title="集群环境下的并发问题(syn锁失效)"></a>集群环境下的并发问题(syn锁失效)</h3><p>通过加锁可以解决在单机情况下的一人一单安全问题，但是在集群模式下就不行了。</p><p><strong>有关锁失效原因分析</strong>:</p><p>由于现在我们部署了多个tomcat，每个tomcat都有一个属于自己的jvm，那么假设在服务器A的tomcat内部，有两个线程，这两个线程由于使用的是同一份代码，那么他们的锁对象是同一个，是可以实现互斥的，但是如果现在是服务器B的tomcat内部，又有两个线程，但是他们的锁对象写的虽然和服务器A一样，但是锁对象却不是同一个，所以线程3和线程4可以实现互斥，但是却无法和线程1和线程2实现互斥，这就是 集群环境下，syn锁失效的原因，在这种情况下，我们就需要使用分布式锁来解决这个问题。</p><h2 id="分布式锁"><a href="#分布式锁" class="headerlink" title="分布式锁"></a>分布式锁</h2><h3 id="基本原理和实现方式"><a href="#基本原理和实现方式" class="headerlink" title="基本原理和实现方式"></a>基本原理和实现方式</h3><p>分布式锁：满足分布式系统或集群模式下<strong>多进程可见并且互斥的锁</strong>。</p><p>分布式锁的核心思想就是让大家都使用同一把锁，只要大家使用的是同一把锁，那么我们就能锁住线程，不让线程进行，让程序串行执行，这就是分布式锁的核心思路。</p><p>那么分布式锁他应该满足一些什么样的条件呢？</p><p>可见性：多个线程都能看到相同的结果，注意：这个地方说的可见性并不是并发编程中指的内存可见性，只是说多个进程之间都能感知到变化的意思</p><p>互斥：互斥是分布式锁的最基本的条件，使得程序串行执行</p><p>高可用：程序不易崩溃，时时刻刻都保证较高的可用性</p><p>高性能：由于加锁本身就让性能降低，所有对于分布式锁本身需要他就较高的加锁性能和释放锁性能</p><p>安全性：安全也是程序中必不可少的一环</p><p>常见的分布式锁有三种</p><p>Mysql：mysql本身就带有锁机制，但是由于mysql性能本身一般，所以采用分布式锁的情况下，其实使用mysql作为分布式锁比较少见</p><p>Redis：redis作为分布式锁是非常常见的一种使用方式，现在企业级开发中基本都使用redis或者zookeeper作为分布式锁，利用setnx(当我们尝试往数据库中set一个数据的时候，只有数据不存在才能set成功)这个方法，如果插入key成功，则表示获得到了锁，如果有人插入成功，其他人插入失败则表示无法获得到锁，利用这套逻辑来实现分布式锁</p><p>Zookeeper：zookeeper也是企业级开发中较好的一个实现分布式锁的方案，由于本套视频并不讲解zookeeper的原理和分布式锁的实现，所以不过多阐述</p><h3 id="Redis分布式锁的实现核心思路"><a href="#Redis分布式锁的实现核心思路" class="headerlink" title="### Redis分布式锁的实现核心思路"></a>### Redis分布式锁的实现核心思路</h3><p>实现分布式锁时需要实现的两个基本方法：</p><ul><li><p>获取锁：</p><ul><li>互斥：确保只能有一个线程获取锁</li><li>非阻塞：<strong>尝试一次</strong>，成功返回true，失败返回false</li></ul></li><li><p>释放锁：</p><ul><li>手动释放</li><li>超时释放：获取锁时添加一个超时时间,如果服务器发生了宕机或者别的意外，锁始终会自动释放，从而避免了死锁的发生</li></ul></li></ul><p>核心思路：</p><p>我们利用redis 的setNx 方法，当有多个线程进入时，我们就利用该方法，第一个线程进入时，redis 中就有这个key 了，返回了1，如果结果是1，则表示他抢到了锁，那么他去执行业务，然后再删除锁，退出锁逻辑，没有抢到锁的哥们，等待一定时间后重试即可</p><blockquote><p>[!TIP]<br>在使用自动拆箱的时候一定要记得考虑发生空指针异常的可能性。</p></blockquote><h3 id="实现分布式锁"><a href="#实现分布式锁" class="headerlink" title="实现分布式锁"></a>实现分布式锁</h3><h4 id="加锁逻辑"><a href="#加锁逻辑" class="headerlink" title="加锁逻辑"></a>加锁逻辑</h4><ul><li><p>利用setnx方法进行加锁，同时增加过期时间，防止死锁，此方法可以保证加锁和增加过期时间具有原子性</p></li><li><p>获取锁的时候还需要存入线程标识（可以用UUID表示）</p></li></ul><h4 id="释放锁的逻辑"><a href="#释放锁的逻辑" class="headerlink" title="释放锁的逻辑"></a>释放锁的逻辑</h4><ul><li>释放锁的时候要确认锁的线程标识，判断是否与当前线程标示一致,如果一致则释放锁，如果不一致则不释放</li></ul><h3 id="分布式锁的原子性问题"><a href="#分布式锁的原子性问题" class="headerlink" title="分布式锁的原子性问题"></a>分布式锁的原子性问题</h3><p>线程1现在持有锁之后，在执行业务逻辑过程中，他正准备删除锁，而且已经走到了条件判断的过程中，比如他已经拿到了当前这把锁确实是属于他自己的，正准备删除锁，但是此时他的锁到期了(发生了阻塞或其他原因导致超时自动释放)，那么此时线程2进来，但是线程1他会接着往后执行，当他卡顿结束后，他直接就会执行删除锁那行代码，相当于条件判断并没有起到作用，这就是删锁时的原子性问题，之所以有这个问题，是因为线程1的拿锁，比锁，删锁，实际上并不是原子性(一起执行，中间没有间隔)的，我们要防止刚才的情况发生，</p><h3 id="Lua脚本解决多条命令原子性问题"><a href="#Lua脚本解决多条命令原子性问题" class="headerlink" title="Lua脚本解决多条命令原子性问题"></a>Lua脚本解决多条命令原子性问题</h3><p>Redis提供了Lua脚本功能，在一个脚本中编写多条Redis命令，确保多条命令执行时的原子性。</p><p>这里重点介绍Redis提供的调用函数，语法如下：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redis.call(<span class="string">&#x27;命令名称&#x27;</span>, <span class="string">&#x27;key&#x27;</span>, <span class="string">&#x27;其它参数&#x27;</span>, ...)␍</span><br></pre></td></tr></table></figure><p>我们可以使用lua去操作redis，又能保证他的原子性，这样就可以实现拿锁比锁删锁是一个原子性动作了，作为Java程序员这一块并不作一个简单要求，并不需要大家过于精通，只需要知道他有什么作用即可。</p><h3 id="利用Java代码调用Lua脚本改造分布式锁"><a href="#利用Java代码调用Lua脚本改造分布式锁" class="headerlink" title="利用Java代码调用Lua脚本改造分布式锁"></a>利用Java代码调用Lua脚本改造分布式锁</h3><p>接下来我们来回一下我们释放锁的逻辑：</p><p>释放锁的业务流程是这样的:</p><ol><li>获取锁中的线程标示</li><li>判断是否与指定的标示（当前线程标示）一致</li><li>如果一致则释放锁（删除）</li><li>如果不一致则什么都不做</li></ol><p>最终我们操作redis的拿锁比锁删锁的lua脚本就会变成这样:</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 这里的 KEYS[1] 就是锁的key，这里的ARGV[1] 就是当前线程标示</span></span><br><span class="line"><span class="comment">-- 获取锁中的标示，判断是否与当前线程标示一致</span></span><br><span class="line"><span class="keyword">if</span> (redis.call(<span class="string">&#x27;GET&#x27;</span>, KEYS[<span class="number">1</span>]) == ARGV[<span class="number">1</span>]) <span class="keyword">then</span></span><br><span class="line">  <span class="comment">-- 一致，则删除锁</span></span><br><span class="line">  <span class="keyword">return</span> redis.call(<span class="string">&#x27;DEL&#x27;</span>, KEYS[<span class="number">1</span>])</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="comment">-- 不一致，则直接返回</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span></span><br></pre></td></tr></table></figure><p><strong>Java代码</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> DefaultRedisScript&lt;Long&gt; UNLOCK_SCRIPT;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        UNLOCK_SCRIPT = <span class="keyword">new</span> <span class="title class_">DefaultRedisScript</span>&lt;&gt;();</span><br><span class="line">        UNLOCK_SCRIPT.setLocation(<span class="keyword">new</span> <span class="title class_">ClassPathResource</span>(<span class="string">&quot;unlock.lua&quot;</span>));</span><br><span class="line">        UNLOCK_SCRIPT.setResultType(Long.class);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">unlock</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 调用lua脚本</span></span><br><span class="line">    stringRedisTemplate.execute(</span><br><span class="line">            UNLOCK_SCRIPT,</span><br><span class="line">            Collections.singletonList(KEY_PREFIX + name),</span><br><span class="line">            ID_PREFIX + Thread.currentThread().getId());</span><br><span class="line">&#125;</span><br><span class="line">经过以上代码改造后，我们就能够实现 拿锁比锁删锁的原子性动作了</span><br></pre></td></tr></table></figure><p>小总结：</p><p>基于Redis的分布式锁实现思路：</p><ul><li>利用set nx ex获取锁，并设置过期时间，保存线程标示</li><li>释放锁时先判断线程标示是否与自己一致，一致则删除锁<ul><li>特性：<ul><li>利用set nx满足互斥性</li><li>利用set ex保证故障时锁依然能释放，避免死锁，提高安全性</li><li>利用Redis集群保证高可用和高并发特性</li></ul></li></ul></li></ul><p>笔者总结：我们一路走来，利用添加过期时间，防止死锁问题的发生，但是有了过期时间之后，可能出现误删别人锁的问题，这个问题我们开始是利用删之前 通过拿锁，比锁，删锁这个逻辑来解决的，也就是删之前判断一下当前这把锁是否是属于自己的，但是现在还有原子性问题，也就是我们没法保证拿锁比锁删锁是一个原子性的动作，最后通过lua表达式来解决这个问题</p><p>但是目前还剩下一个问题锁不住，什么是锁不住呢，你想一想，如果当过期时间到了之后，我们可以给他续期一下，比如续个30s，就好像是网吧上网， 网费到了之后，然后说，来，网管，再给我来10块的，是不是后边的问题都不会发生了，那么续期问题怎么解决呢，可以依赖于我们接下来要学习redission啦</p><p><strong>测试逻辑：</strong></p><p>第一个线程进来，得到了锁，手动删除锁，模拟锁超时了，其他线程会执行lua来抢锁，当第一天线程利用lua删除锁时，lua能保证他不能删除他的锁，第二个线程删除锁时，利用lua同样可以保证不会删除别人的锁，同时还能保证原子性。</p><h2 id="分布式锁redisson"><a href="#分布式锁redisson" class="headerlink" title="分布式锁redisson"></a>分布式锁redisson</h2><p>Redisson是一个在Redis的基础上实现的Java驻内存数据网格（In-Memory Data Grid）。它不仅提供了一系列的分布式的Java常用对象，还提供了许多分布式服务，其中就包含了各种分布式锁的实现。</p><h3 id="分布式锁-redisson功能介绍"><a href="#分布式锁-redisson功能介绍" class="headerlink" title="分布式锁-redisson功能介绍"></a>分布式锁-redisson功能介绍</h3><p>基于setnx实现的分布式锁存在下面的问题：</p><p><strong>重入问题</strong>：重入问题是指获得锁的线程可以再次进入到相同的锁的代码块中，可重入锁的意义在于防止死锁，比如HashTable这样的代码中，他的方法都是使用synchronized修饰的，假如他在一个方法内，调用另一个方法，那么此时如果是不可重入的，不就死锁了吗？所以可重入锁他的主要意义是防止死锁，我们的synchronized和Lock锁都是可重入的。</p><p><strong>不可重试</strong>：是指目前的分布式只能尝试一次，我们认为合理的情况是：当线程在获得锁失败后，他应该能再次尝试获得锁。</p><p><strong>超时释放：</strong>我们在加锁时增加了过期时间，这样的我们可以防止死锁，但是如果卡顿的时间超长，虽然我们采用了lua表达式防止删锁的时候，误删别人的锁，但是毕竟没有锁住，有安全隐患</p><p><strong>主从一致性：</strong> (可简单理解为读写分离模式,主节点和从节点可能分别负责写和读的操作,这样就可以同时在多个节点上进行写和读的操作,如果主节点宕机了，那么还可以从分节点中挑一个继续作为主节点,但是主从节点之间的同步是有延迟的)如果Redis提供了主从集群(一个主节点和多个分节点)，当我们向集群写数据时，主机需要异步的将数据同步给从机，而万一在同步过去之前，主机宕机了，就会出现死锁问题。</p><h3 id="redisson-入门"><a href="#redisson-入门" class="headerlink" title="redisson 入门"></a>redisson 入门</h3><ol><li>引入依赖</li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.redisson<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>redisson<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>3.13.6<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br></pre></td></tr></table></figure><ol start="2"><li>配置Redisson客户端</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RedissonConfig</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> RedissonClient <span class="title function_">redissonClient</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">// 配置</span></span><br><span class="line">        <span class="type">Config</span> <span class="variable">config</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Config</span>();</span><br><span class="line">        config.useSingleServer().setAddress(<span class="string">&quot;redis://192.168.150.101:6379&quot;</span>)</span><br><span class="line">            .setPassword(<span class="string">&quot;123321&quot;</span>);</span><br><span class="line">        <span class="comment">// 创建RedissonClient对象</span></span><br><span class="line">        <span class="keyword">return</span> Redisson.create(config);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="number">3.</span> 使用Redisson的分布式锁</span><br><span class="line">```java</span><br><span class="line"><span class="meta">@Resource</span></span><br><span class="line"><span class="keyword">private</span> RedissionClient redissonClient;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">testRedisson</span><span class="params">()</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line">    <span class="comment">//获取锁(可重入)，指定锁的名称</span></span><br><span class="line">    <span class="type">RLock</span> <span class="variable">lock</span> <span class="operator">=</span> redissonClient.getLock(<span class="string">&quot;anyLock&quot;</span>);</span><br><span class="line">    <span class="comment">//尝试获取锁，参数分别是：获取锁的最大等待时间(期间会重试)，锁自动释放时间，时间单位</span></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">isLock</span> <span class="operator">=</span> lock.tryLock(<span class="number">1</span>,<span class="number">10</span>,TimeUnit.SECONDS);</span><br><span class="line">    <span class="comment">//判断获取锁成功</span></span><br><span class="line">    <span class="keyword">if</span>(isLock)&#123;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;执行业务&quot;</span>);          </span><br><span class="line">        &#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">            <span class="comment">//释放锁</span></span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="redisson可重入锁的原理"><a href="#redisson可重入锁的原理" class="headerlink" title="redisson可重入锁的原理"></a>redisson可重入锁的原理</h3><p>在尝试获取锁的时候，如果发现现在的锁已经被人持有，会去再判断一下持有锁的人是不是自己,如果是，那么也会获取锁，同时也会设置一个计数器来计算获取锁的次数</p><p>在Lock锁中，他是借助于底层的一个voaltile的一个state变量来记录重入的状态的，比如当前没有人持有这把锁，那么state&#x3D;0，假如有人持有这把锁，那么state&#x3D;1，如果持有这把锁的人再次持有这把锁，那么state就会+1 ，如果是对于synchronized而言，他在c语言代码中会有一个count，原理和state类似，也是重入一次就加一，释放一次就-1 ，直到减少成0 时，表示当前这把锁没有被人持有。</p><h3 id="redisson锁重试和watchdog机制"><a href="#redisson锁重试和watchdog机制" class="headerlink" title="redisson锁重试和watchdog机制"></a>redisson锁重试和watchdog机制</h3><p>看门狗机制是用来在获取锁的时候更新锁的失效时间的</p><p>为了解决基于setnx实现的分布式锁的不可重入、不可重试、超时释放和主从一致性的问题,redisson分布式锁的解决方案</p><ul><li><p>可重入：利用hash结构记录线程id和重入次数</p></li><li><p>可重试：利用信号量和PubSub功能实现等待(等待释放锁的消息)、唤醒，获取锁失败的重试机制</p></li><li><p>超时续约：利用watchDog，每隔一段时间（releaseTime &#x2F; 3），重置超时时间</p></li></ul><h3 id="redisson锁的mutilock原理"><a href="#redisson锁的mutilock原理" class="headerlink" title="redisson锁的mutilock原理"></a>redisson锁的mutilock原理</h3><p>为了提高redis的可用性，我们会搭建集群或者主从，现在以主从为例</p><p>此时我们去写命令，写在主机上， 主机会将数据同步给从机，但是假设在主机还没有来得及把数据写入到从机去的时候，此时主机宕机，哨兵会发现主机宕机，并且选举一个slave变成master，而此时新的master中实际上并没有锁信息，此时锁信息就已经丢掉了</p><p>为了解决这个问题，redission提出来了MutiLock锁，使用这把锁咱们就不使用主从了，<strong>每个节点的地位都是一样的</strong>， 这把锁加锁的逻辑需要写入到每一个主丛节点上，只有 <strong>所有的服务器都写入成功，此时才是加锁成功</strong>，假设现在某个节点挂了，那么他去获得锁的时候，只要有一个节点拿不到，都不能算是加锁成功，就保证了加锁的可靠性。</p><p>所谓的联锁，就是多个独立的锁，而每一个独立的锁就和前面的锁完全一样</p><h3 id="redisson分布式锁原理总结"><a href="#redisson分布式锁原理总结" class="headerlink" title="redisson分布式锁原理总结"></a>redisson分布式锁原理总结</h3><p>1）不可重入Redis分布式锁：</p><p>原理：利用setnx的互斥性；利用ex避免死锁；释放锁时判断线程标示</p><p>缺陷：不可重入、无法重试、锁超时失效</p><p>2）可重入的Redis分布式锁：</p><p>原理：利用hash结构，记录线程标示和重入次数；利用watchDog延续锁时间；利用信号量控制锁重试等待</p><p>缺陷：redis宕机引起锁失效问题</p><p>3）Redisson的multiLock(可看作多个可重入式锁的集合)：</p><p>原理：多个独立的Redis节点，必须在所有节点都获取重入锁，才算获取锁成功</p><p>缺陷：运维成本高、实现复杂</p><h2 id="Redis优化秒杀"><a href="#Redis优化秒杀" class="headerlink" title="Redis优化秒杀"></a>Redis优化秒杀</h2><h3 id="秒杀优化-异步秒杀思路"><a href="#秒杀优化-异步秒杀思路" class="headerlink" title="秒杀优化-异步秒杀思路"></a>秒杀优化-异步秒杀思路</h3><p>当用户发起请求，此时会请求nginx，nginx会访问到tomcat，而tomcat中的程序，会进行串行操作，分成如下几个步骤：</p><ol><li><p>查询优惠卷</p></li><li><p>判断秒杀库存是否足够</p></li><li><p>查询订单</p></li><li><p>校验是否是一人一单</p></li><li><p>扣减库存</p></li><li><p>创建订单</p></li></ol><p>优化方案：<br>们将耗时比较短的逻辑判断放入到redis中，比如是否库存足够，比如是否一人一单，这样的操作，只要这种逻辑可以完成，就意味着我们是一定可以下单完成的，我们只需要进行快速的逻辑判断，根本就不用等下单逻辑走完，我们直接给用户返回成功， 再在后台开一个线程，后台线程<strong>慢慢</strong>的去执行queue里边的消息，这样程序不就超级快了吗？而且也不用担心线程池消耗殆尽的问题，因为这里我们的程序中并没有手动使用任何线程池，当然这里边有两个难点:</p><p>第一个难点是我们怎么在redis中去快速校验一人一单，还有库存判断</p><p>第二个难点是由于我们校验和tomct下单是两个线程，那么我们如何知道到底哪个单他最后是否成功，或者是下单完成，为了完成这件事我们在redis操作完之后，我们会将一些信息返回给前端，同时也会把这些信息丢到<strong>异步queue</strong>中去，后续操作中，可以通过这个id来查询我们tomcat中的下单逻辑是否完成了</p><h3 id="redis完成秒杀资格判断"><a href="#redis完成秒杀资格判断" class="headerlink" title="redis完成秒杀资格判断"></a>redis完成秒杀资格判断</h3><h3 id="基于阻塞队列实现秒杀优化"><a href="#基于阻塞队列实现秒杀优化" class="headerlink" title="基于阻塞队列实现秒杀优化"></a>基于阻塞队列实现秒杀优化</h3><p>阻塞队列：当一个线程从队列中获取元素的时候，如果队列中有元素会返回,如果队列中没有元素则会被阻塞，直到队列中有元素才会被唤醒去获取元素。</p><blockquote><p>[!TIP]<br>@PostConstruct注解：在 Java 中，@PostConstruct 注解用于指定一个方法在构造函数执行之后、依赖注入完成之后执行。它标识了一个初始化方法，该方法会在对象的所有依赖项都注入完成后自动被调用。</p></blockquote><p>使用 @PostConstruct 注解的方法必须满足以下条件：</p><p>方法不应该有任何参数。<br>方法的返回类型应该为 void。<br>方法不能是静态的。</p><p>总结：</p><p>秒杀优化的思路：</p><ul><li>改同步下单为异步下单,将业务分为两部分，利用Redis完成下单资格(库存余量、一人一单)的判断，及时响应</li><li>具体下单的业务则放入阻塞队列,开启独立线程慢慢完成。</li></ul><p>基于阻塞队列的异步秒杀有什么问题？</p><ul><li>内存限制问题<br>  现在使用的是jdk的阻塞队列，使用的是jdk的内存，在该并发的情况下可能会有无数的订单被创建放进阻塞队列里，可能导致内存溢出的问题(OOM),虽然在创建阻塞的队列时候设置了上限,但是如果队列满了，那么有新的订单来的时候就存不进去了。</li><li>数据安全问题<br>  现在是基于内存来保存订单信息的，但是如果服务器突然宕机了，那么内存中的所有订单信息就会消失。<br>  有一个线程从队列中取出了一个订单要去执行，此时突然发生异常导致该任务执行失败，由于任务从队列中取出来就没有了，那么该任务以后再也不会被执行，导致任务丢失。</li></ul><h2 id="Redis消息队列（Message-Queue）实现异步秒杀"><a href="#Redis消息队列（Message-Queue）实现异步秒杀" class="headerlink" title="Redis消息队列（Message Queue）实现异步秒杀"></a>Redis消息队列（Message Queue）实现异步秒杀</h2><h3 id="认识消息队列"><a href="#认识消息队列" class="headerlink" title="认识消息队列"></a>认识消息队列</h3><p>什么是消息队列：字面意思就是存放消息的队列。最简单的消息队列模型包括3个角色：</p><ul><li>消息队列：存储和管理消息，也被称为消息代理（Message Broker</li><li>生产者：发送消息到消息队列</li><li>消费者：从消息队列获取消息并处理消息</li></ul><p>使用队列的好处在于 <strong>解耦：</strong>所谓解耦，举一个生活中的例子就是：快递员(生产者)把快递放到快递柜里边(Message Queue)去，我们(消费者)从快递柜里边去拿东西，这就是一个异步，如果耦合，那么这个快递员相当于直接把快递交给你，这事固然好，但是万一你不在家，那么快递员就会一直等你，这就浪费了快递员的时间，所以这种思想在我们日常开发中，是非常有必要的。</p><p>这里我们可以使用一些现成的mq，比如kafka，rabbitmq等等，但是呢，如果没有安装mq，我们也可以直接使用redis提供的mq方案，降低我们的部署和学习成本。</p><h3 id="redis-消息队列"><a href="#redis-消息队列" class="headerlink" title="redis 消息队列"></a>redis 消息队列</h3><h4 id="基于List结构模拟消息队列"><a href="#基于List结构模拟消息队列" class="headerlink" title="基于List结构模拟消息队列"></a>基于List结构模拟消息队列</h4><p>双向链表很容易模拟出队列的效果</p><p>不过要注意的是，当队列中没有消息时RPOP或LPOP操作会返回null，并不像JVM的阻塞队列那样会阻塞并等待消息。因此这里应该使用<strong>BRPOP</strong>或者<strong>BLPOP</strong>来实现阻塞效果。</p><p>基于List的消息队列有哪些优缺点？<br>优点：</p><ul><li>利用Redis存储，不受限于JVM内存上限</li><li>基于Redis的持久化机制，数据安全性有保证</li><li>可以满足消息有序性</li></ul><p>缺点</p><ul><li>无法避免消息丢失</li><li>只支持单消费者</li></ul><h4 id="基于PubSub-发布订阅-的消息队列"><a href="#基于PubSub-发布订阅-的消息队列" class="headerlink" title="基于PubSub(发布订阅)的消息队列"></a>基于PubSub(发布订阅)的消息队列</h4><p>顾名思义，消费者可以订阅一个或多个channel，生产者向对应channel发送消息后，所有订阅者都能收到相关消息。与基于list 结构的消息队列相比最大的改进就是能支持多个消费者,但是不支持数据持久化。</p><p> SUBSCRIBE channel [channel] ：订阅一个或多个频道</p><p> PUBLISH channel msg ：向一个频道发送消息</p><p> PSUBSCRIBE pattern[pattern] ：订阅与pattern(通配符)格式匹配的所有频道</p><p>基于PubSub的消息队列有哪些优缺点？<br>优点：</p><ul><li>采用发布订阅模型，支持多生产、多消费</li></ul><p>缺点：</p><ul><li>不支持数据持久化</li><li>无法避免消息丢失</li><li>消息堆积有上限，超出时数据丢失(消息不在内存中保存，当发布消息的时候，如果有消费者监听，那么消息会放在消费者客户端的缓存区域，如果在消费者处理的时间段内，又来了很多消息，那么就会导致消费者缓存区域的堆积，超出数据会丢失)</li></ul><h3 id="基于Stream的消息队列"><a href="#基于Stream的消息队列" class="headerlink" title="基于Stream的消息队列"></a>基于Stream的消息队列</h3><p>Stream 是 Redis 5.0 引入的一种新<strong>数据类型</strong>，可以实现一个功能非常完善的消息队列。</p><p>STREAM类型消息队列的XREAD命令特点：</p><ul><li>消息可回溯</li><li>一个消息可以被多个消费者读取</li><li>可以阻塞读取</li><li>有消息漏读的风险</li></ul><h3 id="基于stream的消息队列-消费者组-XREADGROUP"><a href="#基于stream的消息队列-消费者组-XREADGROUP" class="headerlink" title="基于stream的消息队列-消费者组(XREADGROUP)"></a>基于stream的消息队列-消费者组(XREADGROUP)</h3><p>STREAM类型消息队列的XREADGROUP命令特点：</p><ul><li>消息可回溯</li><li>可以多消费者争抢消息，加快消费速度</li><li>可以阻塞读取</li><li>没有消息漏读的风险</li><li>有消息确认机制，保证消息至少被消费一次</li></ul><h3 id="总结redis在秒杀场景的应用"><a href="#总结redis在秒杀场景的应用" class="headerlink" title="总结redis在秒杀场景的应用"></a>总结redis在秒杀场景的应用</h3><ul><li>缓存</li><li>分布式锁</li><li>超卖问题</li><li>lua脚本</li><li>Redis 消息队列</li></ul><h2 id="达人探店"><a href="#达人探店" class="headerlink" title="达人探店"></a>达人探店</h2><h3 id="发布探店笔记"><a href="#发布探店笔记" class="headerlink" title="发布探店笔记"></a>发布探店笔记</h3><h3 id="查看探店笔记"><a href="#查看探店笔记" class="headerlink" title="查看探店笔记"></a>查看探店笔记</h3><h3 id="点赞功能"><a href="#点赞功能" class="headerlink" title="点赞功能"></a>点赞功能</h3><p>完善点赞功能</p><p>需求：</p><ul><li>同一个用户只能点赞一次，再次点击则取消点赞</li><li>如果当前用户已经点赞，则点赞按钮高亮显示（前端已实现，判断字段Blog类的isLike属性）</li></ul><p>实现步骤：</p><ul><li>给Blog类中添加一个isLike字段，标示是否被当前用户点赞</li><li>修改点赞功能，利用Redis的set集合判断是否点赞过，未点赞过则点赞数+1，已点赞过则点赞数-1</li><li>修改根据id查询Blog的业务，判断当前登录用户是否点赞过，赋值给isLike字段</li><li>修改分页查询Blog业务，判断当前登录用户是否点赞过，赋值给isLike字段</li></ul><p>为什么采用set集合：</p><p>因为我们的数据是不能重复的。</p><h3 id="点赞排行榜-展示最先给笔记点赞的几个人"><a href="#点赞排行榜-展示最先给笔记点赞的几个人" class="headerlink" title="点赞排行榜(展示最先给笔记点赞的几个人)"></a>点赞排行榜(展示最先给笔记点赞的几个人)</h3><p>之前的点赞是放到set集合，但是set集合是不能排序的，所以这个时候，咱们可以采用一个可以排序的set集合，就是咱们的<strong>sortedSet</strong></p><p>我们接下来来对比一下这些集合的区别是什么</p><p>所有点赞的人，需要是唯一的，所以我们应当使用set或者是sortedSet</p><p>其次我们需要排序，就可以直接锁定使用sortedSet</p><h2 id="好友关注功能"><a href="#好友关注功能" class="headerlink" title="好友关注功能"></a>好友关注功能</h2><h3 id="关注和区关"><a href="#关注和区关" class="headerlink" title="关注和区关"></a>关注和区关</h3><p>针对用户的操作：可以对用户进行关注和取消关注功能。</p><p>实现思路：</p><p>需求：基于该表数据结构，实现两个接口：</p><ul><li><p>关注和取关接口</p></li><li><p>判断是否关注的接口</p></li><li><p>用户与用户之间关注的关系是一种多对多的关系，所以在数据库中专门创建一张表，设计博主id和粉丝id，用插入和删除来表示关注和取关，存在则关注，不存在则没关注。</p></li></ul><h3 id="共同关注"><a href="#共同关注" class="headerlink" title="共同关注"></a>共同关注</h3><p>需求：利用Redis中恰当的数据结构，实现共同关注功能。在博主个人页面展示出当前用户与博主的共同关注呢。</p><p>当然是使用我们之前学习过的set集合咯，在set集合中，有交集并集补集的api，我们可以把两人的关注的人分别放入到一个set集合中，然后再通过api去查看这两个set集合中的交集数据。</p><h3 id="关注推送"><a href="#关注推送" class="headerlink" title="关注推送"></a>关注推送</h3><p>当我们关注了用户后，这个用户发了动态，那么我们应该把这些数据推送给用户，这个需求，其实我们又把他叫做Feed流，关注推送也叫做Feed流，直译为投喂。为用户持续的提供“沉浸式”的体验，通过无限下拉刷新获取新的信息。</p><p>对于传统的模式的内容解锁：我们是需要用户去通过搜索引擎或者是其他的方式去解锁想要看的内容</p><p>对于新型的Feed流的的效果：不需要我们用户再去推送信息，而是系统分析用户到底想要什么，然后直接把内容推送给用户，从而使用户能够更加的节约时间，不用主动去寻找</p><p>Feed流的实现有两种模式：</p><p>Feed流产品有两种常见模式：<br>Timeline：不做内容筛选，简单的按照内容发布时间排序，常用于好友或关注。例如朋友圈␍</p><ul><li>优点：信息全面，不会有缺失。并且实现也相对简单</li><li>缺点：信息噪音较多，用户不一定感兴趣，内容获取效率低</li></ul><p>智能排序：利用智能算法屏蔽掉违规的、用户不感兴趣的内容。推送用户感兴趣信息来吸引用户</p><ul><li>优点：投喂用户感兴趣信息，用户粘度很高，容易沉迷␍</li><li>缺点：如果算法不精准，可能起到反作用␍<br>本例中的个人页面，是基于关注的好友来做Feed流，因此采用Timeline的模式。该模式的实现方案有三种：</li></ul><p>我们本次针对好友的操作，采用的就是Timeline的方式，只需要拿到我们关注用户的信息，然后按照时间排序即可</p><p>因此采用Timeline的模式。该模式的实现方案有三种：</p><ul><li>拉模式</li><li>推模式</li><li>推拉结合</li></ul><p><strong>拉模式</strong>：也叫做读扩散</p><p>该模式的核心含义就是：当张三和李四和王五发了消息后，都会保存在自己的邮箱中，假设赵六要读取信息，那么他会从他关注的所人的发件箱中的读取到他自己的收件箱,再进行排序</p><p>优点：比较节约空间，因为赵六在读信息时，并没有重复读取，而且读取完之后可以把他的收件箱进行清楚。</p><p>缺点：比较延迟，当用户读取数据时才去关注的人里边去读取数据，假设用户关注了大量的用户，那么此时就会拉取海量的内容，对服务器压力巨大。</p><p><strong>推模式</strong>：也叫做写扩散。(群发)</p><p>推模式是没有写邮箱的，当张三写了一个内容，此时会主动的把张三写的内容发送到他的粉丝收件箱中去，假设此时李四再来读取，就不用再去临时拉取了</p><p>优点：时效快，不用临时拉取␍</p><p>缺点：内存压力大，假设一个大V写信息，很多人关注他， 就会写很多分数据到粉丝那边去</p><p><strong>推拉结合模式</strong>：也叫做读写混合，兼具推和拉两种模式的优点。(粉丝多的用主要用拉模式，但是会主动推到活跃粉丝，粉丝少的用推模式)</p><p>推拉模式是一个折中的方案，站在发件人这一段，如果是个普通的人，那么我们采用写扩散的方式，直接把数据写入到他的粉丝中去，因为普通的人他的粉丝关注量比较小，所以这样做没有压力，如果是大V，那么他是直接将数据先写入到一份到发件箱里边去，然后再直接写一份到活跃粉丝收件箱里边去，现在站在收件人这端来看，如果是活跃粉丝，那么大V和普通的人发的都会直接写入到自己收件箱里边来，而如果是普通的粉丝，由于他们上线不是很频繁，所以等他们上线时，再从发件箱里边去拉信息。</p><h3 id="推送到粉丝收件箱"><a href="#推送到粉丝收件箱" class="headerlink" title="推送到粉丝收件箱"></a>推送到粉丝收件箱</h3><p>需求：</p><ul><li>修改新增探店笔记的业务，在保存blog到数据库的同时，推送到粉丝的收件箱</li><li>收件箱满足可以根据时间戳排序，必须用Redis的数据结构实现</li><li>查询收件箱数据时，可以实现分页查询</li></ul><p>Feed流中的数据会不断更新，所以数据的角标也在变化，因此不能采用传统的分页模式。</p><p>传统了分页在feed流是不适用的，因为我们的数据会随时发生变化</p><p>假设在t1 时刻，我们去读取第一页，此时page &#x3D; 1 ，size &#x3D; 5 ，那么我们拿到的就是10 ~ 6 这几条记录，假设现在t2时候又发布了一条记录，此时t3 时刻，我们来读取第二页，读取第二页传入的参数是page&#x3D;2 ，size&#x3D;5 ，那么此时读取到的第二页实际上是从6 开始，然后是6~2 ，那么我们就读取到了重复的数据，所以feed流的分页，不能采用原始方案来做</p><p>Feed流的滚动分页</p><p><strong>我们需要记录每次操作的最后一条，然后从这个位置开始去读取数据</strong></p><p>举个例子：我们从t1时刻开始，拿第一页数据，拿到了10~6，然后记录下当前最后一次拿取的记录，就是6，t2时刻发布了新的记录，此时这个11放到最顶上，但是不会影响我们之前记录的6，此时t3时刻来拿第二页，第二页这个时候拿数据，还是从6后一点的5去拿，就拿到了5-1的记录。我们这个地方可以采用sortedSet来做，可以进行范围查询，并且还可以记录当前获取数据时间戳最小值，就可以实现滚动分页了</p><blockquote><p>[!TIP]<br>如果在数据会发生变化的情况下，不要用list，用sortedSet</p></blockquote><h3 id="实现分页查询邮箱"><a href="#实现分页查询邮箱" class="headerlink" title="实现分页查询邮箱"></a>实现分页查询邮箱</h3><ul><li>首先不能按照角标查，必须按照score滚动分页(最大值，最小值，偏移量(第一次0 ，以后取决于上一次查询的最小值的个数)，查询的数量)</li></ul><h2 id="附近商户的功能"><a href="#附近商户的功能" class="headerlink" title="附近商户的功能"></a>附近商户的功能</h2><h3 id="GEO数据结构的基本用法"><a href="#GEO数据结构的基本用法" class="headerlink" title="GEO数据结构的基本用法"></a>GEO数据结构的基本用法</h3><p>GEO就是Geolocation的简写形式，代表地理坐标。Redis在3.2版本中加入了对GEO的支持，允许存储地理坐标信息，帮助我们根据经纬度来检索数据。常见的命令有：</p><ul><li>GEOADD：添加一个地理空间信息，包含：经度（longitude）、纬度（latitude）、值（member）</li><li>GEODIST：计算指定的两个点之间的距离并返回</li><li>GEOHASH：将指定member的坐标转为hash字符串形式并返回</li><li>GEOPOS：返回指定member的坐标</li><li>GEORADIUS：指定圆心、半径，找到该圆内包含的所有member，并按照与圆心之间的距离排序后返回。6.以后已废弃</li><li>GEOSEARCH：在指定范围内搜索member，并按照与指定点之间的距离排序后返回。范围可以是圆形或矩形。6.2.新功能</li><li>GEOSEARCHSTORE：与GEOSEARCH功能一致，不过可以把结果存储到一个指定的key。 6.2.新功能</li></ul><h3 id="将数据库中的店铺信息导入到Redis中的Geolocation"><a href="#将数据库中的店铺信息导入到Redis中的Geolocation" class="headerlink" title="将数据库中的店铺信息导入到Redis中的Geolocation"></a>将数据库中的店铺信息导入到Redis中的Geolocation</h3><p>将数据库表中的数据导入到redis中去，redis中的GEO，GEO在redis中就一个menber和一个经纬度，我们把x和y轴传入到redis做的经纬度位置去，但我们不能把所有的数据都放入到menber中去，毕竟作为redis是一个内存级数据库，如果存海量数据，redis还是力不从心，所以我们在这个地方存储他的id即可。</p><p>但是这个时候还有一个问题，就是在redis中并没有存储type，所以我们无法根据type来对数据进行筛选，<br>所以我们可以按照商户类型做分组，<strong>类型相同的商户作为同一组</strong>，<br>以typeId为key存入同一个GEO集合中</p><h2 id="用户签到功能"><a href="#用户签到功能" class="headerlink" title="用户签到功能"></a>用户签到功能</h2><h3 id="BitMap"><a href="#BitMap" class="headerlink" title="BitMap"></a>BitMap</h3><p>把每一个bit位对应当月的每一天，形成了映射关系。用0和1标示业务状态，这种思路就称为位图（BitMap）。</p><p>Redis中是利用string类型数据结构实现BitMap，因此最大上限是512M，转换为bit则是 2^32个bit位。</p><p>BitMap中常见操作指令：</p><ul><li>SETBIT：向指定位置（offset）存入一个0或1</li><li>GETBIT ：获取指定位置（offset）的bit值</li><li>BITCOUNT ：统计BitMap中值为1的bit位的数量</li><li>BITFIELD ：操作（查询、修改、自增）BitMap中bit数组中的指定位置（offset）的值,读多个比特位。</li><li>BITFIELD_RO ：获取BitMap中bit数组，并以十进制形式返回</li><li>BITOP ：将多个BitMap的结果做位运算（与 、或、异或）</li><li>BITPOS ：查找bit数组中指定范围内第一个0或1出现的位置</li></ul><h3 id="实现签到功能"><a href="#实现签到功能" class="headerlink" title="实现签到功能"></a>实现签到功能</h3><p>需求：实现签到接口，将当前用户当天签到信息保存到Redis中</p><p>思路：我们可以把年和月作为bitMap的key，然后保存到一个bitMap中，每次签到就到对应的位上把数字从0变成1，只要对应是1，就表明说明这一天已经签到了，反之则没有签到。</p><p>我们通过接口文档发现，此接口并没有传递任何的参数，没有参数怎么确实是哪一天签到呢？这个很容易，可以通过后台代码直接获取即可，然后到对应的地址上去修改bitMap。</p><h3 id="签到统计"><a href="#签到统计" class="headerlink" title="签到统计"></a>签到统计</h3><p><strong>问题1：</strong>什么叫做连续签到天数？ 从最后一次签到开始向前统计，直到遇到第一次未签到为止，计算总的签到次数，就是连续签到天数。</p><p>Java逻辑代码：获得当前这个月的最后一次签到数据，定义一个计数器，然后不停的向前统计，直到获得第一个非0的数字即可，每得到一个非0的数字计数器+1，直到遍历完所有的数据，就可以获得当前月的签到总天数了</p><p><strong>问题2：</strong>如何得到本月到今天为止的所有签到数据？</p><p>BITFIELD key GET u[dayOfMonth] 0</p><p>假设今天是10号，那么我们就可以从当前月的第一天开始，获得到当前这一天的位数，是10号，那么就是10位，去拿这段时间的数据，就能拿到所有的数据了，那么这10天里边签到了多少次呢？统计有多少个1即可。</p><p>问题3：如何从后向前遍历每个bit位？</p><p>需要让得到的10进制数字和1做与运算就可以了，因为1只有遇见1 才是1，其他数字都是0 ，我们把签到结果和1进行与操作，每与一次，<strong>就把签到结果向右移动一位</strong>，依次内推，我们就能完成逐个遍历的效果了。(优雅)</p><p>关键逻辑代码:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 6.循环遍历</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">      <span class="comment">// 6.1.让这个数字与1做与运算，得到数字的最后一个bit位 // 判断这个bit位是否为0</span></span><br><span class="line">      <span class="keyword">if</span> ((num &amp; <span class="number">1</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 如果为0，说明未签到，结束</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 如果不为0，说明已签到，计数器+1</span></span><br><span class="line">        count++;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 把数字右移一位，抛弃最后一个bit位，继续下一个bit位</span></span><br><span class="line">      num &gt;&gt;&gt;= <span class="number">1</span>;<span class="comment">//无符号右移，抛弃最后一位。</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> Result.ok(count);</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="UV统计"><a href="#UV统计" class="headerlink" title="UV统计"></a>UV统计</h2><h3 id="HyperLoglog"><a href="#HyperLoglog" class="headerlink" title="HyperLoglog"></a>HyperLoglog</h3><p>首先我们搞懂两个概念：</p><ul><li><code>UV</code>：全称Unique Visitor，也叫独立访客量，是指通过互联网访问、浏览这个网页的自然人。1天内同一个用户多次访问该网站，只记录1次。</li><li><code>PV</code>：全称Page View，也叫页面访问量或点击量，用户每访问网站的一个页面，记录1次PV，用户多次打开页面，则记录多次PV。往往用来衡量网站的流量。</li></ul><p>UV统计在服务端做会比较麻烦，因为要判断该用户是否已经统计过了，需要将统计过的用户信息保存。但是如果每个访问的用户都保存到Redis中，数据量会非常恐怖，那怎么处理呢？</p><p><code>Hyperloglog</code>(HLL)是从Loglog算法派生的概率算法，用于确定非常大的集合的基数，而不需要存储其所有值。相关算法原理可以参考：<a href="https://juejin.cn/post/6844903785744056333#heading-0">https://juejin.cn/post/6844903785744056333#heading-0</a></p><p>Redis中的HLL是基于string结构实现的，单个HLL的内存<strong>永远小于16kb</strong>，<strong>内存占用低</strong>的令人发指！作为代价，其测量结果是概率性的，<strong>有小于0.81％的误差</strong>。不过对于UV统计来说，这完全可以忽略。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Spring6启示录</title>
      <link href="/undefined/38bc4ed6.html"/>
      <url>/undefined/38bc4ed6.html</url>
      
        <content type="html"><![CDATA[<blockquote><p>[!TIP]<br>基于动力节点spring6总结</p></blockquote><h2 id="Spring启示录"><a href="#Spring启示录" class="headerlink" title="Spring启示录"></a>Spring启示录</h2><h3 id="OCP开闭原则"><a href="#OCP开闭原则" class="headerlink" title="OCP开闭原则"></a>OCP开闭原则</h3><p>在软件开发过程中应当对扩展开放，对修改关闭</p><h3 id="依赖倒置"><a href="#依赖倒置" class="headerlink" title="依赖倒置"></a>依赖倒置</h3><ul><li><p>Dependence Inversion Principle(DIP)</p></li><li><p>要倡导面向抽象编程，面向接口编程，不要面向具体编程，让上层不再依赖下层，下面改动了，上面的代码不会受到牵连。这样可以大大降低程序的耦合度，耦合度低了，扩展力就强了，同时代码复用性也会增强。（软件七大开发原则都是在为解耦合服务）</p></li><li><p>Spring框架可以帮助我们创建对象，并且可以帮助我们维护对象和对象之间的关系</p></li><li><p>Spring其实就是一个管理Bean对象的工厂</p></li></ul><h3 id="控制反转"><a href="#控制反转" class="headerlink" title="控制反转"></a>控制反转</h3><ul><li>Inversion of Control(IoC)</li></ul><p>控制反转的核心是：将对象的创建权交出去，将对象和对象之间关系的管理权交出去，由第三方容器来负责创建与维护。</p><ul><li>控制反转常见的实现方式：依赖注入（Dependency Injection，简称DI。</li></ul><h2 id="Spring概述"><a href="#Spring概述" class="headerlink" title="Spring概述"></a>Spring概述</h2><p>spring &#x3D; IOC + AOP(面向切面编程)</p><h3 id="Spring8大模块"><a href="#Spring8大模块" class="headerlink" title="Spring8大模块"></a>Spring8大模块</h3><h3 id="Spring-特点"><a href="#Spring-特点" class="headerlink" title="Spring 特点"></a>Spring 特点</h3><ol><li>轻量<br>  a. 小<br>  b. 非侵入式：Spring应用中的对象不依赖于Spring的特定类，也就是说 我们自己创建的对象不依赖spring容器</li><li>IoC</li><li>面向切面(AOP)</li><li>容器<br> Spring包含并管理应用对象的配置和生命周期，在这个意义上它是一种容器，你可以配置你的每个bean如何被创建——基于一个可配置原型（prototype），你的bean可以创建一个单独的实例或者每次需要时都生成一个新的实例——以及它们是如何相互关联的。</li><li>框架<br> Spring可以将简单的组件配置、组合成为复杂的应用。在Spring中，应用对象被声明式地组合，典型地是在一个XML文件里。Spring也提供了很多基础功能（事务管理、持久化框架集成等等），将应用逻辑的开发留给了你。</li></ol><h2 id="Spring-入门程序"><a href="#Spring-入门程序" class="headerlink" title="Spring 入门程序"></a>Spring 入门程序</h2><h3 id="第一个Spring程序"><a href="#第一个Spring程序" class="headerlink" title="第一个Spring程序"></a>第一个Spring程序</h3><ul><li><p>Spring的配置文件：beans.xml 放在类的根路径下。<br>配置文件中进行bean的配置</p><ul><li>id属性：代表对象的唯一标识。</li><li>class属性:用来指定要创建的java类的类名，这个类名必须是全限定类名（包含包名</li></ul></li><li><p>Spring是通过反射机制调用类的无参构造方法来创建对象的。</p></li></ul><h3 id="Spring6-启用Log4j2日志框架"><a href="#Spring6-启用Log4j2日志框架" class="headerlink" title="Spring6 启用Log4j2日志框架"></a>Spring6 启用Log4j2日志框架</h3><p>第一步：引入Log4j2的依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--log4j2的依赖--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.logging.log4j<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>log4j-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.19.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.logging.log4j<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>log4j-slf4j2-impl<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.19.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>第二步：在类的根路径下提供log4j2.xml配置文件（文件名固定为：log4j2.xml，文件必须放到类根路径下。）</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">loggers</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">            level指定日志级别，从低到高的优先级：</span></span><br><span class="line"><span class="comment">                ALL &lt; TRACE &lt; DEBUG &lt; INFO &lt; WARN &lt; ERROR &lt; FATAL &lt; OFF</span></span><br><span class="line"><span class="comment">        --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">root</span> <span class="attr">level</span>=<span class="string">&quot;DEBUG&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">appender-ref</span> <span class="attr">ref</span>=<span class="string">&quot;spring6log&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">root</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">loggers</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">appenders</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--输出日志信息到控制台--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">console</span> <span class="attr">name</span>=<span class="string">&quot;spring6log&quot;</span> <span class="attr">target</span>=<span class="string">&quot;SYSTEM_OUT&quot;</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--控制日志输出的格式--&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">PatternLayout</span> <span class="attr">pattern</span>=<span class="string">&quot;%d&#123;yyyy-MM-dd HH:mm:ss SSS&#125; [%t] %-3level %logger&#123;1024&#125; - %msg%n&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">console</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">appenders</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>第三步：使用日志框架</p><h2 id="四、Spring对IoC的实现"><a href="#四、Spring对IoC的实现" class="headerlink" title="四、Spring对IoC的实现"></a>四、Spring对IoC的实现</h2><h3 id="IoC控制反转"><a href="#IoC控制反转" class="headerlink" title="IoC控制反转"></a>IoC控制反转</h3><ul><li><p>控制反转是一种思想。</p></li><li><p>控制反转是为了降低程序耦合度，提高程序扩展力，达到OCP原则，达到DIP原则。</p></li><li><p>控制反转，反转的是什么？</p><ul><li><p>将对象的创建权利交出去，交给第三方容器负责。</p></li><li><p>将对象和对象之间关系的维护权交出去，交给第三方容器负责。</p></li></ul></li><li><p>控制反转这种思想如何实现呢？</p><ul><li>DI（Dependency Injection）：依赖注入</li></ul></li></ul><h3 id="IoC依赖注入"><a href="#IoC依赖注入" class="headerlink" title="IoC依赖注入"></a>IoC依赖注入</h3><p>依赖注入实现了控制反转的思想。</p><p>Spring通过依赖注入的方式来完成Bean管理的。</p><p>Bean管理说的是：Bean对象的创建，以及Bean对象中属性的赋值（或者叫做Bean对象之间关系的维护）。</p><p>依赖注入：</p><ul><li><p>依赖指的是对象和对象之间的关联关系。</p></li><li><p>注入指的是一种数据传递行为，通过注入行为来让对象和对象产生关系。</p></li></ul><p>依赖注入常见的实现方式包括两种：</p><p>set注入:基于<strong>set方法</strong>实现，底层通过反射机制调用属性对应的set方法然后给属性赋值。因此这种方法要求属性必须对外暴露set方法。</p><p>总结：set注入的核心实现原理：通过反射机制调用set方法来给属性赋值，让两个对象之间产生关系。</p><p>构造注入:通过调用<strong>构造方法</strong>来给属性赋值。</p><p>通过测试得知，通过构造方法注入的时候：</p><ul><li>可以通过下标</li><li>可以通过参数名</li><li>也可以不指定下标和参数名，可以类型自动推断。</li></ul><h3 id="p命名空间注入"><a href="#p命名空间注入" class="headerlink" title="p命名空间注入"></a>p命名空间注入</h3><p>p命名空间注入是基于setter方法的，所以需要对应的属性提供setter方法。</p><h3 id="c命名空间注入"><a href="#c命名空间注入" class="headerlink" title="c命名空间注入"></a>c命名空间注入</h3><p>c命名空间是简化构造方法注入的,需要提供构造方法</p><ul><li>注意：不管是p命名空间还是c命名空间，注入的时候都可以注入简单类型以及非简单类型。</li></ul><h3 id="util命名空间"><a href="#util命名空间" class="headerlink" title="util命名空间"></a>util命名空间</h3><p>使用util命名空间可以让配置复用。</p><h3 id="基于XML的自动装配"><a href="#基于XML的自动装配" class="headerlink" title="基于XML的自动装配"></a>基于XML的自动装配</h3><p>Spring还可以完成自动化的注入，自动化注入又被称为自动装配。它可以根据名字进行自动装配，也可以根据类型进行自动装配。</p><p>如果根据名称装配(byName)，底层会调用set方法进行注入。<br>例如：setAge() 对应的名字是age，setPassword()对应的名字是password，setEmail()对应的名字是email。</p><p>当byType进行自动装配的时候，配置文件中某种类型的Bean必须是唯一的</p><h3 id="Spring-引入外部配置文件"><a href="#Spring-引入外部配置文件" class="headerlink" title="Spring 引入外部配置文件"></a>Spring 引入外部配置文件</h3><h2 id="Bean的作用域"><a href="#Bean的作用域" class="headerlink" title="Bean的作用域"></a>Bean的作用域</h2><h3 id="单例-singleton"><a href="#单例-singleton" class="headerlink" title="单例 singleton"></a>单例 singleton</h3><p>默认情况下，Spring的IoC容器创建的Bean对象是单例的。</p><p>Bean对象的创建是在初始化Spring上下文的时候就完成的。</p><h3 id="多例-prototype"><a href="#多例-prototype" class="headerlink" title="多例 prototype"></a>多例 prototype</h3><p>如果想让Spring的Bean对象以多例的形式存在，可以在bean标签中指定scope属性的值为：prototype</p><p>scope如果没有配置，它的默认值是什么呢？默认值是singleton，单例的。</p><h3 id="其他scope"><a href="#其他scope" class="headerlink" title="其他scope"></a>其他scope</h3><h2 id="Gof-gang-of-four-之工厂模式"><a href="#Gof-gang-of-four-之工厂模式" class="headerlink" title="Gof (gang of four) 之工厂模式"></a>Gof (gang of four) 之工厂模式</h2><p>设计模式: 一种可以被重复利用的方案</p><p>工厂模式是解决对象创建问题的，所以工厂模式属于创建型设计模式。这里为什么学习工厂模式呢？这是因为Spring框架底层使用了大量的工厂模式。</p><p>GoF23种设计模式可分为三大类:</p><ul><li>创建型（5个）：解决对象创建问题。</li><li>结构型(7个)：一些类或对象组合在一起的经典结构。</li><li>行为型（11个）：解决类或对象之间的交互问题。</li></ul><h3 id="工厂模式的三种形态"><a href="#工厂模式的三种形态" class="headerlink" title="工厂模式的三种形态"></a>工厂模式的三种形态</h3><ol><li>简单工厂模式（Simple Factory）：不属于23种设计模式之一。简单工厂模式又叫做：静态 工厂方法模式。简单工厂模式是工厂方法模式的一种特殊实现。</li><li>工厂方法模式（Factory Method）：是23种设计模式之一。</li><li>抽象工厂模式（Abstract Factory）：是23种设计模式之一。</li></ol><h3 id="简单工厂模式"><a href="#简单工厂模式" class="headerlink" title="简单工厂模式"></a>简单工厂模式</h3><p>单工厂模式的角色包括三个：</p><ol><li>抽象产品角色</li><li>具体产品角色</li><li>工厂类角色</li></ol><p>抽象产品角色：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.powernode.factory;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 武器（抽象产品角色）</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> 动力节点</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> 1.0</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@className</span> Weapon</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 1.0</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Weapon</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 所有的武器都有攻击行为</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">attack</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>具体产品角色：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.powernode.factory;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 坦克（具体产品角色）</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> 动力节点</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> 1.0</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@className</span> Tank</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 1.0</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Tank</span> <span class="keyword">extends</span> <span class="title class_">Weapon</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">attack</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;坦克开炮！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.powernode.factory;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 战斗机（具体产品角色）</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> 动力节点</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> 1.0</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@className</span> Fighter</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 1.0</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Fighter</span> <span class="keyword">extends</span> <span class="title class_">Weapon</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">attack</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;战斗机投下原子弹！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.powernode.factory;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 匕首（具体产品角色）</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> 动力节点</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> 1.0</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@className</span> Dagger</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 1.0</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Dagger</span> <span class="keyword">extends</span> <span class="title class_">Weapon</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">attack</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;砍他丫的！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>工厂类角色：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.powernode.factory;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 工厂类角色</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> 动力节点</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> 1.0</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@className</span> WeaponFactory</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 1.0</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WeaponFactory</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据不同的武器类型生产武器</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> weaponType 武器类型</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 武器对象</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Weapon <span class="title function_">get</span><span class="params">(String weaponType)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (weaponType == <span class="literal">null</span> || weaponType.trim().length() == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">Weapon</span> <span class="variable">weapon</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (<span class="string">&quot;TANK&quot;</span>.equals(weaponType)) &#123;</span><br><span class="line">            weapon = <span class="keyword">new</span> <span class="title class_">Tank</span>();</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">&quot;FIGHTER&quot;</span>.equals(weaponType)) &#123;</span><br><span class="line">            weapon = <span class="keyword">new</span> <span class="title class_">Fighter</span>();</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">&quot;DAGGER&quot;</span>.equals(weaponType)) &#123;</span><br><span class="line">            weapon = <span class="keyword">new</span> <span class="title class_">Dagger</span>();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;不支持该武器！&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> weapon;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>测试程序（客户端程序）：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.powernode.factory;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> 动力节点</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> 1.0</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@className</span> Client</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 1.0</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Weapon</span> <span class="variable">weapon1</span> <span class="operator">=</span> WeaponFactory.get(<span class="string">&quot;TANK&quot;</span>);</span><br><span class="line">        weapon1.attack();</span><br><span class="line"></span><br><span class="line">        <span class="type">Weapon</span> <span class="variable">weapon2</span> <span class="operator">=</span> WeaponFactory.get(<span class="string">&quot;FIGHTER&quot;</span>);</span><br><span class="line">        weapon2.attack();</span><br><span class="line"></span><br><span class="line">        <span class="type">Weapon</span> <span class="variable">weapon3</span> <span class="operator">=</span> WeaponFactory.get(<span class="string">&quot;DAGGER&quot;</span>);</span><br><span class="line">        weapon3.attack();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="依赖注入"><a href="#依赖注入" class="headerlink" title="依赖注入"></a>依赖注入</h2><h3 id="set-注入-主要应用"><a href="#set-注入-主要应用" class="headerlink" title="set 注入(主要应用)"></a>set 注入(主要应用)</h3><ul><li><input disabled="" type="checkbox"> set注入的核心实现原理：通过反射机制调用set方法来给属性赋值，让两个对象之间产生关系。</li><li><input disabled="" type="checkbox"> property标签的name是：setUserDao()方法名演变得到的</li><li><input disabled="" type="checkbox"> 注入外部bean</li></ul><blockquote><blockquote><ul><li><input disabled="" type="checkbox"> 外部Bean的特点：bean定义到外面，在property标签中使用ref属性进行注入。通常这种方式是常用。 [ ] 注入内部bean</li></ul></blockquote></blockquote><ul><li><input disabled="" type="checkbox"> 注入简单类型</li></ul><blockquote><blockquote><ul><li><input disabled="" type="checkbox"> 如果给简单类型赋值，使用value属性或value标签。而不是ref。</li><li><input disabled="" type="checkbox"> 简单类型包括哪些呢？</li></ul></blockquote></blockquote><ul><li>基本数据类型</li><li>基本数据类型对应的包装类</li><li>String或其他的CharSequence子类</li><li>Number子类</li><li>Date子类</li><li>Enum子类</li><li>URI</li><li>URL</li><li>Temporal子类</li><li>Locale</li><li>Class</li><li>另外还包括以上简单值类型对应的数组类型<blockquote><blockquote><ul><li><input disabled="" type="checkbox"> 需要注意的是：</li></ul></blockquote></blockquote></li><li>如果把Date当做简单类型的话，日期字符串格式不能随便写。格式必须符合Date的toString()方法格式。显然这就比较鸡肋了。如果我们提供一个这样的日期字符串：2010-10-11，在这里是无法赋值给Date类型的属性的。</li><li>spring6之后，当注入的是URL，那么这个url字符串是会进行有效性检测的。如果是一个存在的url，那就没问题。如果不存在则报错。</li></ul><hr><ul><li><input disabled="" type="checkbox"> 级联属性赋值</li></ul><blockquote><blockquote><ul><li><input disabled="" type="checkbox"> 要点：</li></ul></blockquote></blockquote><ul><li><p>在spring配置文件中，如上，注意顺序。</p></li><li><p>在spring配置文件中，clazz属性必须提供getter方法。</p></li><li><p><input disabled="" type="checkbox"> 注入数组<br>要点：</p></li><li><p>如果数组中是简单类型，使用value标签。</p></li><li><p>如果数组中是非简单类型，使用ref标签。</p></li><li><p><input disabled="" type="checkbox"> 注入list集合(有序可重复)</p><ul><li>同上，只要把array标签改为list</li><li>注意：注入List集合的时候使用list标签，如果List集合中是简单类型使用value标签，反之使用ref标签。</li></ul></li><li><p><input disabled="" type="checkbox"> 注入set集合(无序不可重复)</p><ul><li><p>使用<code>&lt;set&gt;</code>标签</p></li><li><p>set集合中元素是简单类型的使用value标签，反之使用ref标签。</p></li><li><p><input disabled="" type="checkbox"> 注入map集合<br>要点：</p></li><li><p>使用<code>&lt;map&gt;</code>标签</p></li><li><p>如果key是简单类型，使用 key 属性，反之使用 key-ref 属性。</p></li><li><p>如果value是简单类型，使用 value 属性，反之使用 value-ref 属性。</p></li><li><p><input disabled="" type="checkbox"> p命名空间注入</p></li></ul><p>使用p命名空间注入的前提条件包括两个：</p><ul><li><p>第一：在XML头部信息中添加p命名空间的配置信息：xmlns:p&#x3D;”<a href="http://www.springframework.org/schema/p">http://www.springframework.org/schema/p</a>“</p></li><li><p>第二：p命名空间注入是基于setter方法的，所以需要对应的属性提供setter方法。</p></li><li><p><input disabled="" type="checkbox"> c命名空间注入</p></li></ul><p>c命名空间是简化构造方法注入的。</p><ul><li><p>使用c命名空间的两个前提条件：<br>第一：需要在xml配置文件头部添加信息：xmlns:c&#x3D;”<a href="http://www.springframework.org/schema/c">http://www.springframework.org/schema/c</a>“</p></li><li><p>第二：需要提供构造方法。</p></li><li><p><input disabled="" type="checkbox"> util 命名空间</p></li><li><p>使用util命名空间可以让配置复用。</p></li></ul></li></ul><h3 id="构造注入"><a href="#构造注入" class="headerlink" title="构造注入"></a>构造注入</h3><ul><li><p><input disabled="" type="checkbox"> 通过测试得知，通过构造方法注入的时候</p></li><li><p>可以通过下标</p></li><li><p>可以通过参数名</p></li><li><p>也可以不指定下标和参数名，可以类型自动推断。</p></li><li><p>spring在装配方面做的还是比较健壮的</p></li></ul><h3 id="基于XML的自动装配-1"><a href="#基于XML的自动装配-1" class="headerlink" title="基于XML的自动装配"></a>基于XML的自动装配</h3><ul><li><p><input disabled="" type="checkbox"> 根据名称自动装配</p></li><li><p>Spring还可以完成自动化的注入，自动化注入又被称为自动装配。它可以根据名字进行自动装配，也可以根据类型进行自动装配</p></li><li><p>这说明，如果根据名称装配(byName)，底层会调用set方法进行注入。<br>例如：setAge() 对应的名字是age，setPassword()对应的名字是password，setEmail()对应的名字是email。</p></li><li><p><input disabled="" type="checkbox"> 根据类型自动装配</p></li><li><p>配置文件中某种类型的Bean必须是唯一的，不能出现多个。</p></li></ul><h3 id="spring引入外部属性配置文件"><a href="#spring引入外部属性配置文件" class="headerlink" title="spring引入外部属性配置文件"></a>spring引入外部属性配置文件</h3><h3 id="Bean的作用域-1"><a href="#Bean的作用域-1" class="headerlink" title="Bean的作用域"></a>Bean的作用域</h3><ul><li><p><input disabled="" type="checkbox"> Spring的IoC容器中，默认情况下，Bean对象是单例的</p></li><li><p><input disabled="" type="checkbox"> 默认情况下，Bean对象的创建是在初始化Spring上下文的时候就完成的</p></li><li><p><input disabled="" type="checkbox"> 如果想让Spring的Bean对象以多例的形式存在，可以在bean标签中指定scope属性的值为：prototype，<strong>这样Spring会在每一次执行getBean()方法的时候创建Bean对象</strong>，调用几次则创建几次。</p></li><li><p>scope属性的值不止两个，它一共包括8个选项：</p></li><li><p>singleton：默认的，单例。</p></li><li><p>prototype：原型。每调用一次getBean()方法则获取一个新的Bean对象。或每次注入的时候都是新对象。</p></li><li><p>request：一个请求对应一个Bean。仅限于在WEB应用中使用。</p></li><li><p>session：一个会话对应一个Bean。仅限于在WEB应用中使用。</p></li><li><p>global session：portlet应用中专用的。如果在Servlet的WEB应用中使用global session的话，和session一个效果。（portlet和servlet都是规范。servlet运行在servlet容器中，例如Tomcat。portlet运行在portlet容器中。）</p></li><li><p>application：一个应用对应一个Bean。仅限于在WEB应用中使用。</p></li><li><p>websocket：一个websocket生命周期对应一个Bean。仅限于在WEB应用中使用。</p></li><li><p>自定义scope：很少使用。</p></li></ul><h3 id="Gof-FactoryMode-工厂模式"><a href="#Gof-FactoryMode-工厂模式" class="headerlink" title="Gof FactoryMode 工厂模式"></a>Gof FactoryMode 工厂模式</h3><ul><li><input disabled="" type="checkbox"> 简单工厂模式</li></ul><blockquote><blockquote><ul><li><input disabled="" type="checkbox"> 简单工厂模式的优点：</li></ul></blockquote></blockquote><ul><li><p>客户端程序不需要关心对象的创建细节，需要哪个对象时，只需要向工厂索要即可，初步实现了责任的分离。客户端只负责“消费”，工厂负责“生产”。生产和消费分离。</p><blockquote><blockquote><ul><li><input disabled="" type="checkbox"> 简单工厂模式的缺点：</li></ul></blockquote></blockquote></li><li><p>缺点1：工厂类集中了所有产品的创造逻辑，形成一个无所不知的全能类，有人把它叫做上帝类。显然工厂类非常关键，不能出问题，一旦出问题，整个系统瘫痪。</p></li><li><p>缺点2：不符合OCP开闭原则，在进行系统扩展时，需要修改工厂类。Spring中的BeanFactory就使用了简单工厂模式。</p></li><li><p><input disabled="" type="checkbox"> 工厂方法模式</p></li></ul><blockquote><blockquote><ul><li><input disabled="" type="checkbox"> 工厂方法模式既保留了简单工厂模式的优点，同时又解决了简单工厂模式的缺点。<br>工厂方法模式的角色包括：</li></ul></blockquote></blockquote><ul><li>抽象工厂角色</li><li>具体工厂角色</li><li>抽象产品角色</li><li>具体产品角色</li></ul><h2 id="Bean的实例化方式"><a href="#Bean的实例化方式" class="headerlink" title="Bean的实例化方式"></a>Bean的实例化方式</h2><h3 id="1-构造方法"><a href="#1-构造方法" class="headerlink" title="1. 构造方法"></a>1. 构造方法</h3><ul><li><input disabled="" type="checkbox"> 在配置文件中配置类的全路径，spirng直接调用该类的无参构造方法获取bean对象</li></ul><h3 id="2-简单工厂模式"><a href="#2-简单工厂模式" class="headerlink" title="2. 简单工厂模式"></a>2. 简单工厂模式</h3><ul><li><input disabled="" type="checkbox"> 通过简单工厂模式，调用<code>工厂</code>的静态方法<code>get()</code>获取bean对象</li><li><input disabled="" type="checkbox"> 工厂类里的方法是静态方法，所以不需要spring工厂的实例</li></ul><h3 id="3-通过factory-bean实例化-本质上是工厂方法模式"><a href="#3-通过factory-bean实例化-本质上是工厂方法模式" class="headerlink" title="3. 通过factory-bean实例化(本质上是工厂方法模式)"></a>3. 通过factory-bean实例化(本质上是工厂方法模式)</h3><ul><li><input disabled="" type="checkbox"> 工厂类里的方法是非静态方法，所工厂类也必须被spring管理起来</li><li><input disabled="" type="checkbox"> 标签也要多一个 因为得告诉spring是创建哪个<code>工厂</code> 的 哪个<code>对象</code><br>所以得指定哪个对象(factory-bean)的哪个方法(factory-method)</li></ul><h3 id="4-通过FactoryBean接口实例化"><a href="#4-通过FactoryBean接口实例化" class="headerlink" title="4. 通过FactoryBean接口实例化"></a>4. 通过FactoryBean接口实例化</h3><ul><li><input disabled="" type="checkbox"> 只要实现接口和接口的抽象方法 就可以不需要指定factory-bean 和<br>factory-method。是对第三种方法的简化</li><li><input disabled="" type="checkbox"> 因为实现了接口所以直接认为你这个类的对象就是一个豆子<br>td因为实现了接口所以直接认为你这个类的对象就是一个豆子</li></ul><h3 id="BeanFactory-和-FactoryBean-的区别"><a href="#BeanFactory-和-FactoryBean-的区别" class="headerlink" title="BeanFactory 和 FactoryBean 的区别"></a>BeanFactory 和 FactoryBean 的区别</h3><ul><li><p><input disabled="" type="checkbox"> BeanFactory</p></li><li><p>Spring IoC容器的顶级对象，BeanFactory被翻译为“Bean工厂”，在Spring的IoC容器中，“Bean工厂”负责创建Bean对象。<br>BeanFactory是工厂。</p></li><li><p><input disabled="" type="checkbox"> FactoryBean</p></li><li><p>它是一个<strong>Bean</strong>，是一个能够辅助Spring实例化其它Bean对象的一个Bean。<br>在Spring中，Bean可以分为两类：<br>● 第一类：普通Bean<br>● 第二类：工厂Bean（记住：工厂Bean也是一种Bean，只不过这种Bean比较特殊，它可以辅助Spring实例化其它Bean对象。）</p></li></ul><h3 id="注入自定义-Date-工厂Bean的实际应用"><a href="#注入自定义-Date-工厂Bean的实际应用" class="headerlink" title="注入自定义 Date (工厂Bean的实际应用)"></a>注入自定义 Date (工厂Bean的实际应用)</h3><h3 id="Bean-的生命周期-可分为5步7步10步-也就是bean对象从开始创建到消亡的整个过程"><a href="#Bean-的生命周期-可分为5步7步10步-也就是bean对象从开始创建到消亡的整个过程" class="headerlink" title="Bean 的生命周期(可分为5步7步10步)(也就是bean对象从开始创建到消亡的整个过程)"></a>Bean 的生命周期(可分为5步7步10步)(也就是bean对象从开始创建到消亡的整个过程)</h3><ul><li><input disabled="" type="checkbox"> 当想在具体某个生命周期做指定操作时可以用到</li><li>第一步：实例化Bean</li><li>第二步：Bean属性赋值</li><li>第三步：初始化Bean 需要手动指定 使用init-method标签<br>** bean后处理器的before方法</li><li>第四步：使用Bean<br>** bean后处理器的after方法</li><li>第五步：销毁Bean 使用手动指定 用destory-method标签</li></ul><h3 id="Bean的作用域不同，管理方式不同"><a href="#Bean的作用域不同，管理方式不同" class="headerlink" title="Bean的作用域不同，管理方式不同"></a>Bean的作用域不同，管理方式不同</h3><ul><li>对于singleton作用域的Bean，Spring 能够精确地知道该Bean何时被创建，何时初始化完成，以及何时被销毁；</li><li>而对于 prototype 作用域的 Bean，Spring 只负责创建，当容器创建了<br>Bean 的实例后，Bean 的实例就交给客户端代码管理，Spring 容器将不再跟踪其生命周期。</li></ul><h3 id="自己new的对象可以让Spring管理"><a href="#自己new的对象可以让Spring管理" class="headerlink" title="自己new的对象可以让Spring管理"></a>自己new的对象可以让Spring管理</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RegisterBeanTest</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testBeanRegister</span><span class="params">()</span>&#123;</span><br><span class="line">      <span class="comment">// 自己new的对象</span></span><br><span class="line">      <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>();</span><br><span class="line">      System.out.println(user);</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 创建 默认可列表BeanFactory 对象</span></span><br><span class="line">      <span class="type">DefaultListableBeanFactory</span> <span class="variable">factory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DefaultListableBeanFactory</span>();</span><br><span class="line">      <span class="comment">// 注册Bean</span></span><br><span class="line">      factory.registerSingleton(<span class="string">&quot;userBean&quot;</span>, user);</span><br><span class="line">      <span class="comment">// 从spring容器中获取bean</span></span><br><span class="line">      <span class="type">User</span> <span class="variable">userBean</span> <span class="operator">=</span> factory.getBean(<span class="string">&quot;userBean&quot;</span>, User.class);</span><br><span class="line">      System.out.println(userBean);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="Bean的循环依赖问题"><a href="#Bean的循环依赖问题" class="headerlink" title="Bean的循环依赖问题"></a>Bean的循环依赖问题</h2><h3 id="singleton-set注入"><a href="#singleton-set注入" class="headerlink" title="singleton + set注入"></a><code>singleton</code> + set注入</h3><p>循环依赖没有问题,解决方法如下:</p><ul><li><input disabled="" type="checkbox"> spring容器一旦将bean创建出来就立刻进行<code>曝光</code><br>(不赋值就告诉大家我可以被使用啦！！)</li><li><input disabled="" type="checkbox"> 曝光之后再进行赋值</li></ul><h3 id="prototype-set注入"><a href="#prototype-set注入" class="headerlink" title="prototype + set注入"></a><code>prototype</code> + set注入</h3><ul><li><input disabled="" type="checkbox"> 当循环依赖的 <strong>所有</strong> Bean的scope&#x3D;”prototype”的时候，产生的循环依赖，Spring是无法解决的，会出现BeanCurrentlyInCreationException异常。<blockquote><blockquote><ul><li><input disabled="" type="checkbox"> new ClassPathApplicationContext的时候不会new对象<br>，只有在getBean的时候才会创建对象,会无限递归</li></ul></blockquote></blockquote></li><li><input disabled="" type="checkbox"> 当循环依赖的一个是单例时，就不会出现问题</li></ul><h3 id="singleton-prototype-构造注入"><a href="#singleton-prototype-构造注入" class="headerlink" title="singleton&#x2F;prototype+ 构造注入"></a><code>singleton</code>&#x2F;<code>prototype</code>+ 构造注入</h3><ul><li><input disabled="" type="checkbox"> 有异常，因为创建对象和给属性赋值是同时进行的，不给属性赋值对象就创建不出来</li></ul><h3 id="Spring解决循环依赖的机理"><a href="#Spring解决循环依赖的机理" class="headerlink" title="Spring解决循环依赖的机理"></a>Spring解决循环依赖的机理</h3><ul><li><input disabled="" type="checkbox"> Spring只能解决setter方法注入的单例bean之间的循环依赖。<br>ClassA依赖ClassB，ClassB又依赖ClassA，形成依赖闭环。<br>Spring在创建ClassA对象后，不需要等给属性赋值，直接将其曝光到bean缓存当中。在解析ClassA的属性时，又发现依赖于ClassB，再次去获取ClassB，当解析ClassB的属性时，又发现需要ClassA的属性，但此时的ClassA已经被提前曝光加入了正在创建的bean的缓存中，则无需创建新的的ClassA的实例，直接从缓存中获取即可。从而解决循环依赖问题。</li></ul><h2 id="回顾反射机制"><a href="#回顾反射机制" class="headerlink" title="回顾反射机制"></a>回顾反射机制</h2><h3 id="方法调用的四个要素"><a href="#方法调用的四个要素" class="headerlink" title="方法调用的四个要素"></a>方法调用的四个要素</h3><ul><li>哪个对象 </li><li>哪个方法 </li><li>哪个参数</li><li>返回什么值</li></ul><h2 id="全注解式开发"><a href="#全注解式开发" class="headerlink" title="全注解式开发"></a>全注解式开发</h2><h3 id="负责声明bean的注解"><a href="#负责声明bean的注解" class="headerlink" title="负责声明bean的注解"></a>负责声明bean的注解</h3><ul><li>@Component</li><li>@Controller</li><li>@Service</li><li>@Repository</li></ul><p>@Controller、@Service、@Repository这三个注解都是@Component注解的别名。其实这四个注解的功能一样，但是为了增强程序的可读性</p><ul><li>控制器类上使用：Controller</li><li>service类上使用：Service</li><li>dao类上使用：Repository</li></ul><p>他们都是只有一个value属性。value属性用来指定bean的id，也就是bean的名字。</p><h3 id="spring注解的使用"><a href="#spring注解的使用" class="headerlink" title="spring注解的使用"></a>spring注解的使用</h3><ol><li>加入AOP依赖(一般会加入spring-context依赖后会关联加入，所以这一步不用做)</li><li>配置文件中配置context命名空间</li><li>配置包扫描</li><li>Bean上使用注解</li></ol><blockquote><p>[!TIP]<br>如果注解的属性名是value，那么可以省略<br>  如果把value属性彻底去掉，spring会被Bean自动取名，并且默认名字的规律是：Bean类名首字母小写后面不变。</p></blockquote><p>如果是多个包怎么办？有两种解决方案：</p><ul><li>第一种：在配置文件中指定多个包，用逗号隔开。</li><li>第二种：指定多个包的共同父包。</li></ul><h3 id="选择性实例化Bean"><a href="#选择性实例化Bean" class="headerlink" title="选择性实例化Bean"></a>选择性实例化Bean</h3><p>假设在某个包下有很多Bean，有的Bean上标注了Component，有的标注了Controller，有的标注了Service，有的标注了Repository，现在由于某种特殊业务的需要，只允许其中所有的Controller参与Bean管理</p><ul><li>修改配置文件就行，用到再去查</li></ul><h3 id="负责注入的注解"><a href="#负责注入的注解" class="headerlink" title="负责注入的注解"></a>负责注入的注解</h3><p>@Component @Controller @Service @Repository 这四个注解是用来<strong>声明</strong>Bean的，声明后这些Bean将被实例化。接下来我们看一下，如何给Bean的属性赋值。给Bean属性<strong>赋值</strong>需要用到这些注解：</p><ul><li><p>@Value 负责注入简单类型</p><ul><li>@Value注解可以直接使用在属性上，也可以使用在setter方法上,以及构造方法的形参上。</li><li>为了简化代码，以后我们一般不提供setter方法，直接在属性上使用@Value注解完成属性赋值。</li></ul></li><li><p>@Autowired 单独使用@Autowired注解，默认根据类型装配。【默认是byType】</p><ul><li>@Autowired注解可以用来注入非简单类型。被翻译为：自动连线的，或者自动装配。单独使用@Autowired注解，默认根据类型装配。【默认是byType】</li><li>当有参数的构造方法只有一个时，@Autowired注解可以省略。如果有多个构造方法，@Autowired肯定是不能省略的。</li><li>可以直接使用在属性上，也可以使用在setter方法上,以及构造方法、构造方法参数上</li></ul></li><li><p>如一个要装配的接口有不止一个实现类，则配合@Qualified使用才能byName进行装配</p></li><li><p>@Resource注解默认根据属性名进行装配。</p><ul><li>@Resource注解也可以完成非简单类型注入。</li><li>与@Autowired注解的区别：<ul><li>@Resource注解是JDK扩展包中的，也就是说属于JDK的一部分。所以该注解是标准注解，更加具有通用性。</li><li>@Autowired注解是Spring框架自己的。</li><li>@Resource注解默认根据名称装配byName，未指定name时，使用属性名作为name。通过name找不到的话会自动启动通过类型byType装配。</li><li>@Resource注解用在属性上、setter方法上。</li><li>@Autowired注解用在属性上、setter方法上、构造方法上、构造方法参数上。</li></ul></li></ul></li></ul><h2 id="GOF代理模式"><a href="#GOF代理模式" class="headerlink" title="GOF代理模式"></a>GOF代理模式</h2><h3 id="对代理模式的理解"><a href="#对代理模式的理解" class="headerlink" title="对代理模式的理解"></a>对代理模式的理解</h3><p>代理模式中有一个非常重要的特点：对于客户端程序来说，使用代理对象时就像在使用目标对象一样。【在程序中，目标需要被保护时】</p><p>代理模式是GoF23种设计模式之一。属于结构型设计模式。</p><p>代理模式的作用是：为其他对象提供一种代理以控制对这个对象的访问。在某些情况下，一个客户不想或者不能直接引用一个对象，此时可以通过一个称之为“代理”的第三者来实现间接引用。代理对象可以在客户端和目标对象之间起到<strong>中介</strong>的作用，并且可以通过代理对象去掉客户不应该看到的内容和服务或者添加客户需要的额外服务。 通过<strong>引入一个新的对象</strong>来实现对真实对象的操作或者将新的对象作为真实对象的一个替身，这种实现机制即为代理模式，<strong>通过引入代理对象来间接访问一个对象</strong>，这就是代理模式的模式动机。<br>代理模式中的角色：</p><ul><li>代理类（代理主题）</li><li>目标类（真实主题）</li><li>代理类和目标类的公共接口（抽象主题）：客户端在使用代理类时就像在使用目标类，不被客户端所察觉，所以代理类和目标类要有共同的行为，也就是实现共同的接口。</li></ul><h3 id="动态代理"><a href="#动态代理" class="headerlink" title="动态代理"></a>动态代理</h3><p>在内存当中动态生成类的技术常见的包括：</p><ul><li>JDK动态代理技术：只能代理接口。</li><li>CGLIB动态代理技术：CGLIB(Code Generation Library)是一个开源项目。是一个强大的，高性能，高质量的Code生成类库，它可以在运行期扩展Java类与实现Java接口。它既可以代理接口，又可以代理类，底层是通过<strong>继承</strong>的方式实现的,因此被代理的目标类不能用<code>final</code>修饰。性能比JDK动态代理要好。（底层有一个小而快的字节码处理框架ASM。）</li><li>Javassist动态代理技术：Javassist是一个开源的分析、编辑和创建Java字节码的类库。是由东京工业大学的数学和计算机科学系的 Shigeru Chiba （千叶 滋）所创建的。它已加入了开放源代码JBoss 应用服务器项目，通过使用Javassist对字节码操作为JBoss实现动态”AOP”框架。</li></ul><h3 id="静态代理和动态代理的区别"><a href="#静态代理和动态代理的区别" class="headerlink" title="静态代理和动态代理的区别"></a>静态代理和动态代理的区别</h3><p>静态代理和动态代理都是在面向对象编程中常见的设计模式，它们都允许一个对象在另一个对象的基础上提供额外的功能。它们的主要区别在于代理类的创建时间和绑定方式。</p><ol><li>静态代理：<br>静态代理是在编译时就已经确定了的代理关系。在静态代理中，代理类在编译期间就已经创建好，并且代理类和被代理类的关系在编译时确定，不能动态改变。</li></ol><p>特点：<br>代理类和被代理类在编译期间确定。<br>需要为每一个被代理类编写一个对应的代理类。<br>编译时就已确定代理关系，不灵活。</p><ol start="2"><li>动态代理：<br>动态代理是在运行时创建的代理对象，代理类在程序运行时动态生成，而不是在编译期间确定。Java 中的动态代理主要是通过 java.lang.reflect.Proxy 类来实现。</li></ol><p>特点：<br>代理类是在运行时动态生成的。<br>不需要为每一个被代理类编写一个对应的代理类，可以通过反射机制动态处理。<br>在运行时可以动态改变代理关系，更加灵活。</p><p>应用场景：</p><ul><li>静态代理： 适用于被代理类较少且不需要频繁变更代理关系的情况，比如安全检查、日志记录等。</li><li>动态代理： 适用于被代理类较多或者代理关系需要经常变更的情况，比如 AOP（面向切面编程）、RPC（远程过程调用）等。</li></ul><p>总的来说，动态代理相对于静态代理更加灵活，因为它允许在运行时动态生成代理对象，而无需在编译时确定。这使得动态代理在一些需要动态管理和调整代理关系的场景下更为实用。</p><h2 id="面向切面编程的AOP-Aspect-Oriented-Programming"><a href="#面向切面编程的AOP-Aspect-Oriented-Programming" class="headerlink" title="面向切面编程的AOP(Aspect Oriented Programming)"></a>面向切面编程的AOP(Aspect Oriented Programming)</h2><ul><li>AOP底层使用的是动态代理实现</li><li>Spring的AOP使用的动态代理是：JDK动态代理 + CGLIB动态代理技术。Spring在这两种动态代理中灵活切换，如果是代理接口，会默认使用JDK动态代理，如果要代理某个类，这个类没有实现接口，就会切换使用CGLIB</li></ul><h3 id="AOP介绍"><a href="#AOP介绍" class="headerlink" title="AOP介绍"></a>AOP介绍</h3><p>一般一个系统当中都会有一些系统服务，例如：日志、事务管理、安全等。这些系统服务被称为：交叉业务</p><p>如果在每一个业务处理过程当中，都掺杂这些交叉业务代码进去的话，存在两方面问题：</p><ul><li><p>第一：交叉业务代码在多个业务流程中反复出现，显然这个交叉业务代码没有得到复用。并且修改这些交叉业务代码的话，需要修改多处。</p></li><li><p>第二：程序员无法专注核心业务代码的编写，在编写核心业务代码的同时还需要处理这些交叉业务。</p></li><li><p>用一句话总结AOP：将与核心业务无关的代码独立的抽取出来，形成一个独立的组件，然后以横向交叉的方式应用到业务流程当中的过程被称为AOP。</p></li></ul><p>AOP的优点:</p><ul><li>第一：代码复用性增强。</li><li>第二：代码易维护。</li><li>第三：使开发者更关注业务逻辑。</li></ul><h3 id="AOP七大术语"><a href="#AOP七大术语" class="headerlink" title="AOP七大术语"></a>AOP七大术语</h3><ul><li><p><input disabled="" type="checkbox"> 切面：程序中和业务逻辑没有关系的通用代码(交叉业务)</p><ul><li><p><input disabled="" type="checkbox"> 连接点 Joinpoint</p><blockquote><blockquote><ul><li><input disabled="" type="checkbox"> 在程序的整个执行流程中，可以织入切面的位置。方法的执行前后，异常抛出之后等位置。</li></ul></blockquote></blockquote></li><li><p><input disabled="" type="checkbox"> 切点 Pointcut</p><blockquote><blockquote><ul><li><input disabled="" type="checkbox"> 在程序执行流程中，真正织入切面的方法。（一个切点对应多个连接点）</li></ul></blockquote></blockquote></li><li><p><input disabled="" type="checkbox"> 通知 Advice</p><blockquote><blockquote><ul><li><input disabled="" type="checkbox"> 通知又叫增强，就是具体你要织入的代码。</li></ul></blockquote></blockquote></li><li><p><input disabled="" type="checkbox"> 切面Aspect</p><blockquote><blockquote><ul><li><input disabled="" type="checkbox"> 切点 + 通知就是切面。</li></ul></blockquote></blockquote></li><li><p><input disabled="" type="checkbox"> 织入 Weaving</p><blockquote><blockquote><ul><li><input disabled="" type="checkbox"> 把通知应用到目标对象上的过程。</li></ul></blockquote></blockquote></li><li><p><input disabled="" type="checkbox"> 代理对象 Proxy</p><blockquote><blockquote><ul><li><input disabled="" type="checkbox"> 一个目标对象被织入通知后产生的新对象。</li></ul></blockquote></blockquote></li><li><p><input disabled="" type="checkbox"> 目标对象 Target</p><blockquote><blockquote><ul><li><input disabled="" type="checkbox"> 被织入通知的对象。</li></ul></blockquote></blockquote></li></ul></li></ul><p> 切点表达式</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">execution([访问控制权限修饰符] 返回值类型 [全限定类名]方法名(形式参数列表) [异常])</span><br></pre></td></tr></table></figure><h3 id="使用Spring的AOP"><a href="#使用Spring的AOP" class="headerlink" title="使用Spring的AOP"></a>使用Spring的AOP</h3><h4 id="切面的先后顺序"><a href="#切面的先后顺序" class="headerlink" title="切面的先后顺序"></a>切面的先后顺序</h4><ul><li><input disabled="" type="checkbox"> 可以使用@Order注解来标识切面类，为@Order注解的value指定一个整数型的数字，数字越小，优先级越高。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Order(1)</span> <span class="comment">//设置优先级</span></span><br></pre></td></tr></table></figure><h4 id="通用切点"><a href="#通用切点" class="headerlink" title="通用切点"></a>通用切点</h4><ul><li>将切点表达式单独的定义出来，在需要的位置引入即可</li></ul><h4 id="连接点-Joinpoint"><a href="#连接点-Joinpoint" class="headerlink" title="连接点(Joinpoint)"></a>连接点(Joinpoint)</h4><ul><li><input disabled="" type="checkbox"> getSignature 获取目标方法的签名</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> 开始一直到&#123;&#125;之前</span><br></pre></td></tr></table></figure><h4 id="全注解开发AOP"><a href="#全注解开发AOP" class="headerlink" title="全注解开发AOP"></a>全注解开发AOP</h4><ul><li><input disabled="" type="checkbox"> 编写一个类来代替spring配置文件</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.powernode.spring6.service;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.ComponentScan;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.EnableAspectJAutoProxy;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ComponentScan(&quot;com.powernode.spring6.service&quot;)</span></span><br><span class="line"><span class="meta">@EnableAspectJAutoProxy(proxyTargetClass = true)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Spring6Configuration</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><input disabled="" type="checkbox"> 因为xml文件没了 所以生成对象的时候也要有所变化</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testAOPWithAllAnnotation</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">ApplicationContext</span> <span class="variable">applicationContext</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AnnotationConfigApplicationContext</span>(Spring6Configuration.class);</span><br><span class="line">    <span class="type">OrderService</span> <span class="variable">orderService</span> <span class="operator">=</span> applicationContext.getBean(<span class="string">&quot;orderService&quot;</span>, OrderService.class);</span><br><span class="line">    orderService.generate();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="spring-对事务的支持"><a href="#spring-对事务的支持" class="headerlink" title="spring 对事务的支持"></a>spring 对事务的支持</h2><h3 id="事务概述"><a href="#事务概述" class="headerlink" title="事务概述"></a>事务概述</h3><ul><li>什么是事务<ul><li>在一个业务流程当中，通常需要多条DML（insert delete update）语句共同联合才能完成，这多条DML语句必须同时成功，或者同时失败，这样才能保证数据的安全。</li><li>多条DML要么同时成功，要么同时失败，这叫做事务。</li><li>事务：Transaction（tx）</li></ul></li><li>事务的四个处理过程：<ul><li>第一步：开启事务 (start transaction)</li><li>第二步：执行核心业务代码</li><li>第三步：提交事务（如果核心业务处理过程中没有出现异常）(commit transaction)</li><li>第四步：回滚事务（如果核心业务处理过程中出现异常）(rollback transaction)</li></ul></li><li>事务的四个特性：<ul><li>A 原子性：事务是最小的工作单元，不可再分。</li><li>C 一致性：事务要求要么同时成功，要么同时失败。事务前和事务后的总量不变。</li><li>I 隔离性：事务和事务之间因为有隔离性，才可以保证互不干扰。</li><li>D 持久性：持久性是事务结束的标志。</li></ul></li></ul><h3 id="事务的传播行为"><a href="#事务的传播行为" class="headerlink" title="事务的传播行为"></a>事务的传播行为</h3><ul><li><input disabled="" type="checkbox"> 在service类中有a()方法和b()方法，a()方法上有事务，b()方法上也有事务，当a()方法执行过程中调用了b()方法，事务是如何传递的？合并到一个事务里？还是开启一个新的事务？这就是事务传播行为。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Transactional(propagation = Propagation.REQUIRED)</span></span><br></pre></td></tr></table></figure><p>一共有七种传播行为：</p><ul><li>REQUIRED：支持当前事务，如果不存在就新建一个(默认)【没有就新建，有就加入】</li><li>SUPPORTS：支持当前事务，如果当前没有事务，就以非事务方式执行【有就加入，没有就不管了】</li><li>MANDATORY：必须运行在一个事务中，如果当前没有事务正在发生，将抛出一个异常【有就加入，没有就抛异常】</li><li>REQUIRES_NEW：开启一个新的事务，如果一个事务已经存在，则将这个存在的事务挂起【不管有没有，直接开启一个新事务，开启的新事务和之前的事务不存在嵌套关系，之前事务被挂起】</li><li>NOT_SUPPORTED：以非事务方式运行，如果有事务存在，挂起当前事务【不支持事务，存在就挂起】</li><li>NEVER：以非事务方式运行，如果有事务存在，抛出异常【不支持事务，存在就抛异常】</li><li>NESTED：如果当前正有一个事务在进行中，则该方法应当运行在一个嵌套式事务中。被嵌套的事务可以独立于外层事务进行提交或回滚。如果外层事务不存在，行为就像REQUIRED一样。【有事务的话，就在这个事务里再嵌套一个完全独立的事务，嵌套的事务可以独立的提交和回滚。没有事务就和REQUIRED一样。】</li></ul><h3 id="事物的隔离级别"><a href="#事物的隔离级别" class="headerlink" title="事物的隔离级别"></a>事物的隔离级别</h3><ul><li>脏读：读取到没有提交到数据库的数据(缓存中的数据)，叫做脏读。</li><li>不可重复读：在同一个事务当中，第一次和第二次读取的数据不一样。</li><li>幻读：读到的数据是假的。多事务并发一定会产生幻读问题。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Transactional(isolation = Isolation.READ_COMMITTED)</span></span><br></pre></td></tr></table></figure><blockquote><blockquote><ul><li><input disabled="" type="checkbox"> 其中可以设置的隔离级别有以下四种</li></ul></blockquote></blockquote><ul><li>Default</li><li>read_uncommitted</li><li>READ_COMMITTED</li><li>repeatable_read</li><li>serializable</li></ul><h3 id="事物超时"><a href="#事物超时" class="headerlink" title="事物超时"></a>事物超时</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Transactional(timeout = 10)</span></span><br></pre></td></tr></table></figure><ul><li>以上代码表示设置事务的超时时间为10秒。</li><li>表示超过10秒如果该事务中所有的DML语句还没有执行完毕的话，最终结果会选择回滚。</li><li>默认值-1，表示没有时间限制。</li><li>这里有个坑，事务的超时时间指的是哪段时间？:在当前事务当中，最后一条DML语句执行<code>之前</code>的时间。如果最后一条DML语句后面很有很多业务逻辑，这些业务代码执行的时间不被计入超时时间。</li></ul><h3 id="只读事务"><a href="#只读事务" class="headerlink" title="只读事务"></a>只读事务</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Transactional(readOnly = true)</span></span><br></pre></td></tr></table></figure><ul><li>将当前事务设置为只读事务，在该事务执行过程中只允许select语句执行，delete insert update均不可执行。<br>该特性的作用是：启动spring的优化策略。提高select语句执行效率。<br>如果该事务中确实没有增删改操作，建议设置为只读事务。</li></ul><h3 id="设置哪些异常回滚事务"><a href="#设置哪些异常回滚事务" class="headerlink" title="设置哪些异常回滚事务"></a>设置哪些异常回滚事务</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Transactional(rollbackFor = RuntimeException.class)</span></span><br></pre></td></tr></table></figure><ul><li>表示只有发生RuntimeException异常或该异常的子类异常才回滚。</li></ul><h3 id="设置哪些异常不回滚事务"><a href="#设置哪些异常不回滚事务" class="headerlink" title="设置哪些异常不回滚事务"></a>设置哪些异常不回滚事务</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Transactional(noRollbackFor = NullPointerException.class)</span></span><br></pre></td></tr></table></figure><p>表示发生NullPointerException或该异常的子类异常不回滚，其他异常则回滚。</p><h3 id="事务的全注解开发"><a href="#事务的全注解开发" class="headerlink" title="事务的全注解开发"></a>事务的全注解开发</h3><p>编写一个类来代替配置文件</p><h2 id="Spring6整合JUnit5"><a href="#Spring6整合JUnit5" class="headerlink" title="Spring6整合JUnit5"></a>Spring6整合JUnit5</h2><h3 id="Spring对JUnit4的支持"><a href="#Spring对JUnit4的支持" class="headerlink" title="Spring对JUnit4的支持"></a>Spring对JUnit4的支持</h3><p>:wq<br>Spring提供的方便主要是这几个注解：</p><ul><li><p>@RunWith(SpringJUnit4ClassRunner.class)</p></li><li><p>@ContextConfiguration(“classpath:spring.xml”)</p></li><li><p>在单元测试类上使用这两个注解之后，在单元测试类中的属性上可以使用@Autowired。比较方便。</p></li></ul><h3 id="Spring对JUnit5的支持"><a href="#Spring对JUnit5的支持" class="headerlink" title="Spring对JUnit5的支持"></a>Spring对JUnit5的支持</h3><p>在JUnit5当中，可以使用Spring提供的以下两个注解，标注到单元测试类上，这样在类当中就可以使用@Autowired注解了。</p><ul><li>@ExtendWith(SpringExtension.class)</li><li>@ContextConfiguration(“classpath:spring.xml”)</li></ul><h2 id="Spring6集成MyBatis3-5"><a href="#Spring6集成MyBatis3-5" class="headerlink" title="Spring6集成MyBatis3.5"></a>Spring6集成MyBatis3.5</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">AccountMapper</span> &#123;</span><br><span class="line">    <span class="comment">// 接口定义的方法</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Repository</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AccountMapperImpl</span> <span class="keyword">implements</span> <span class="title class_">AccountMapper</span> &#123;</span><br><span class="line">    <span class="comment">// 实现接口定义的方法</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AccountService</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> AccountMapper accountMapper;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 类的其余部分</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li><input disabled="" type="checkbox"> 在这个例子中，AccountMapper 是一个接口，AccountMapperImpl 是实现了这个接口的类。在 AccountService 类中，通过 @Autowired 注解将 accountMapper 字段注入为 AccountMapper 接口的实现类的一个实例。</li></ul><h2 id="spring中的八大模式"><a href="#spring中的八大模式" class="headerlink" title="spring中的八大模式"></a>spring中的八大模式</h2><h3 id="简单工厂模式-1"><a href="#简单工厂模式-1" class="headerlink" title="简单工厂模式"></a>简单工厂模式</h3><p>BeanFactory的getBean()方法，通过唯一标识来获取Bean对象。是典型的简单工厂模式（静态工厂模式）；</p><h3 id="工厂方法模式"><a href="#工厂方法模式" class="headerlink" title="工厂方法模式"></a>工厂方法模式</h3><p>FactoryBean是典型的工厂方法模式。在配置文件中通过factory-method属性来指定工厂方法，该方法是一个实例方法。</p><h3 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h3><p>Spring用的是双重判断加锁的单例模式。</p><h3 id="代理模式"><a href="#代理模式" class="headerlink" title="代理模式"></a>代理模式</h3><p>Spring的AOP就是使用了动态代理实现的。</p><h3 id="装饰器模式"><a href="#装饰器模式" class="headerlink" title="装饰器模式"></a>装饰器模式</h3><p>JavaSE中的IO流是非常典型的装饰器模式。</p><p>Spring 中配置 DataSource 的时候，这些dataSource可能是各种不同类型的，比如不同的数据库：Oracle、SQL Server、MySQL等，也可能是不同的数据源：比如apache 提供的org.apache.commons.dbcp.BasicDataSource、spring提供的org.springframework.jndi.JndiObjectFactoryBean等。</p><p>这时，能否在尽可能少修改原有类代码下的情况下，做到动态切换不同的数据源？此时就可以用到装饰者模式。</p><p>Spring根据每次请求的不同，将dataSource属性设置成不同的数据源，以到达切换数据源的目的。</p><p><strong>Spring中类名中带有：Decorator和Wrapper单词的类，都是装饰器模式。</strong></p><h3 id="观察者模式"><a href="#观察者模式" class="headerlink" title="观察者模式"></a>观察者模式</h3><p>定义对象间的一对多的关系，当一个对象的状态发生改变时，所有依赖于它的对象都得到通知并自动更新。Spring中观察者模式一般用在listener的实现</p><h3 id="策略模式"><a href="#策略模式" class="headerlink" title="策略模式"></a>策略模式</h3><p>策略模式是行为性模式，调用不同的方法，适应行为的变化 ，强调父类的调用子类的特性 。</p><p>getHandler是HandlerMapping接口中的唯一方法，用于根据请求找到匹配的处理器。</p><p>比如我们自己写了AccountDao接口，然后这个接口下有不同的实现类：AccountDaoForMySQL，AccountDaoForOracle。对于service来说不需要关心底层具体的实现，只需要面向AccountDao接口调用，底层可以灵活切换实现，这就是策略模式。</p><h3 id="模板方法模式"><a href="#模板方法模式" class="headerlink" title="模板方法模式"></a>模板方法模式</h3><p>Spring中的JdbcTemplate类就是一个模板类。它就是一个模板方法设计模式的体现。在模板类的模板方法execute中编写核心算法，具体的实现步骤在子类中完成。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>测试开发学习路线</title>
      <link href="/undefined/d3855f56.html"/>
      <url>/undefined/d3855f56.html</url>
      
        <content type="html"><![CDATA[<h2 id="一、编程语言入门"><a href="#一、编程语言入门" class="headerlink" title="一、编程语言入门"></a>一、编程语言入门</h2><ul><li><input checked="" disabled="" type="checkbox"> java</li></ul><h2 id="二、基础"><a href="#二、基础" class="headerlink" title="二、基础"></a>二、基础</h2><h3 id="计算机基础"><a href="#计算机基础" class="headerlink" title="计算机基础"></a>计算机基础</h3><ul><li><input disabled="" type="checkbox"> 数据结构与算法</li><li><input disabled="" type="checkbox"> 计算机网络</li><li><input disabled="" type="checkbox"> linux</li><li><input disabled="" type="checkbox"> mysql 重点是sql语句的编写</li></ul><h3 id="测试基础"><a href="#测试基础" class="headerlink" title="测试基础"></a>测试基础</h3><ul><li><input disabled="" type="checkbox"> 测试工具</li><li><input disabled="" type="checkbox"> 功能测试基础</li></ul><h2 id="三、进阶"><a href="#三、进阶" class="headerlink" title="三、进阶"></a>三、进阶</h2><h3 id="开发"><a href="#开发" class="headerlink" title="开发"></a>开发</h3><ul><li><input disabled="" type="checkbox"> 后端web开发</li><li><input disabled="" type="checkbox"> 自动化测试</li></ul><h2 id="项目实战"><a href="#项目实战" class="headerlink" title="项目实战"></a>项目实战</h2><ul><li><input disabled="" type="checkbox"> 开发项目实战</li></ul><blockquote><p>[!TIP]<br>应届校招以准备开发项目实战为佳,而不是测试项目</p></blockquote>]]></content>
      
      
      
    </entry>
    
    
  
  
    
    
    <entry>
      <title></title>
      <link href="/manifest.json"/>
      <url>/manifest.json</url>
      
        <content type="html"><![CDATA[{"name":"安知鱼`Blog","short_name":"安知鱼","theme_color":"#3b70fc","background_color":"#3b70fc","display":"standalone","scope":"/","start_url":"/","icons":[{"src":"/img/siteicon/16.png","sizes":"16x16","type":"image/png"},{"src":"/img/siteicon/32.png","sizes":"32x32","type":"image/png"},{"src":"/img/siteicon/48.png","sizes":"48x48","type":"image/png"},{"src":"/img/siteicon/64.png","sizes":"64x64","type":"image/png"},{"src":"/img/siteicon/128.png","sizes":"128x128","type":"image/png"},{"src":"/img/siteicon/144.png","sizes":"144x144","type":"image/png"},{"src":"/img/siteicon/512.png","sizes":"512x512","type":"image/png"}],"splash_pages":null}]]></content>
      
    </entry>
    
    
  
</search>
